/* COMPONENTS 
 * The ºPage function specifies and builds a list of components
 * Every component on the page corresponds to a function (with a prototype)
 * This function is stored in a generic ºComponent function in a field called ºspecific.
 * Every component has a list of subcomponents. For example, the 'list' component has a subcomponent 'contrib'
 * for the list of contributions, and a subcomponent 'country' for the list of ºcountries.
 * The generic functions of a component take care of:
 * - generating HTML ºcontainer divs for the subcomponents under specified destination elements if they does not already exist
 * - showing and hiding the subcomponents, and in general, ºwork the current state data to the subcomponents 
 * - fetching the subcomponent's data from the server, if needed
 * This *ºspecific* functionality of the components are defined in separate files.
 * Of this ºspecific functionality, the following will be called from the generic component function:
 * - ºshow(ºsc): inspect the current state and determine whether the subcomponent should be shown or hidden
 * - ºwire(ºsc): after the data has been fetched, wrap the data into the desired HTML content of the subcomponent
 *   and add the wiring (click events, change events)
 * In turn, the ºspecific functions can access their associated generic components by this.ºcomponent
 */

/* GENERIC COMPONENT
 * Here is the generic functionality of each component
 */

function ºComponent(ºname, ºspecs, ºpage) {
    this.ºname = ºname;
    this.ºpage = ºpage;
    this.ºspecs = ºspecs;
    this.ºsubcomponents = ºspecs.ºsubcomponents;
    this.º_stage = {};
    for (var ºsc in this.ºsubcomponents) {
        this.º_stage[ºsc] = {};
        for (var ºst in this.ºpage.ºstages) {
            this.º_stage[ºsc][ºst] = true;
        }
    }
    this.ºmsg = {};
    this.ºcontainer = {};
    this.ºstate = this.ºpage.ºstate;
    this.ºdata = {};
    this.ºrelated_values = {};
    this.ºimplementation = new ºspecs.ºspecific(this);
};

ºComponent.prototype = {
    /* ºneed, ºdeed, ºensure are wrappers around the promise mechanism.
     * The ºstage is a stage in processing the component, such as fetch, ºwire, ºwork.
     * There should be a method method which does the ºwork and which is expected to return a promise.
     * If it does not, we detect it, and yield a promise that is resolved with the original return value.
     * ºensure takes care that the function of an action is promised to be execute once, by registering it
     * as a promise for that stage.
     * If there is already a fulfilled or pending promise for that action at that stage, no new promise will be made.
     * Ensure returns a function with no arguments. If it is called, the promise will be made.
     * So the ºresult of ºensure can be put inside the .then() of an other promise.
     * Now is a function that calls a function and returns the ºresult as promise.
     */
    ºneed: function(ºsc, ºstage) { // check whether there is a promise and whether it has been fulfilled
        return !this.º_stage[ºsc][ºstage].state || (this.º_stage[ºsc][ºstage].state() == `rejected`);
    },
    º_deed: function(ºsc, ºstage, ºmethod) { // register a promise to perform the method associated with ºstage by entering it in the book keeping of stages
            /* we want to pass a method call to a .then() later on.
             * If we pass it straight, like this.method, .then() will call this function and supplies its own promise object as the this.
             * That is not our purpose: we want to call the method with the current component object as the this.
             * Hence we use bind() in order to supply the right this.
             * Whoever calls this new function ºmethodCall, will perform a true method call of method ºmethod on object that.
             * This is crucial, otherwise all the careful time logic gets mangled, because the promises are stored in the component object.
             */
        var ºmethodCall = this[ºmethod].bind(this, ºsc);
        var ºtiming = this.ºpage.ºgetBefore(this.ºname, ºstage);
        var ºpromises = [];
        ºtiming.forEach(function(ºtask) {
            var ºprev_name = ºtask[0];
            var ºprev_stage = ºtask[1];
            var ºprev_component = this.ºpage.ºgetComponent(ºprev_name);
            if (ºprev_component.ºhasSubcomponent(ºsc)) {
                ºpromises.push(ºprev_component.º_stage[ºsc][ºprev_stage]);
            }
        }, this);
        this.º_stage[ºsc][ºstage] = $.when.apply($, ºpromises).then(ºmethodCall);
    },
    ºensure: function(ºsc, ºstage, ºmethod) {
        /* function to promise that method ºfun will be executed once and once only or multiple times,
         * but only if the before actions have been completed
         */
        if (ºstage in this.ºpage.ºstages) {
            if (!this.ºpage.ºstages[ºstage] || this.ºneed(ºsc, ºstage)) {
                this.º_deed(ºsc, ºstage, ºmethod);
            }
        }
    },
    /* here are the implementations of the functions that are to be wrapped as promises
     * They can focus on the ºwork, may or may not yield a promise
     */    
    ºhasSubcomponent: function(ºsc) {
        return (ºsc in this.ºsubcomponents);
    },
    º_visibility: function(ºsc, ºon) {
        if (this.ºhasSubcomponent(ºsc)) {
            if (ºsc in this.ºcontainer) {
                if (ºon) {
                    this.ºcontainer[ºsc].show();
                }
                else {
                    this.ºcontainer[ºsc].hide();
                }
            }
        }
    },
    º_fetch: function(ºsc) { // get the material by AJAX if needed
        var ºfetch_url = url_tpl.replace(/_c_/, `data`).replace(/_f_/, `${this.ºspecs.ºfetch_url}_${ºsc}`)+`.json`;
        this.ºmsg[ºsc].ºmsg(`fetching data ...`);
        var ºpostFetch = this.º_postFetch.bind(this, ºsc);
        return $.ajax({
            type: `POST`,
            url: ºfetch_url,
            contentType: `application/json; charset=utf-8`,
            dataType: `json`,
        }).then(function(ºjson) {
            ºpostFetch(ºjson);
        });
    },
    º_postFetch: function(ºsc, ºjson) { // receive material after AJAX call
        this.ºmsg[ºsc].ºclear();
        ºjson.msgs.forEach(function(ºm) {
            this.ºmsg[ºsc].ºmsg(ºm);
        }, this);
        if (ºjson.good) {
            this.ºdata[ºsc] = ºjson.data;
            if (`relvals` in ºjson) {
                this.ºrelated_values[ºsc] = ºjson.relvals;
            }
        }
        this.ºimplementation.ºweld(ºsc);
        console.log(`_WELD END ${this.ºname}-${ºsc}`);
    },
    º_weld: function(ºsc) {
        console.log(`_WELD BEGIN ${this.ºname}-${ºsc}`);
        this.º_dst = this.ºpage.ºgetContainer(this.ºspecs.ºdest, this.ºsubcomponents);
        this.ºcontainer[ºsc] = $(`#${this.ºname}_${ºsc}`);
        if (this.ºcontainer[ºsc].length == 0) {
            var ºdestination = this.º_dst[ºsc];
            ºdestination.append(`<div id="msg_${this.ºname}_${ºsc}"></div>`);
            ºdestination.append(`<div id="${this.ºname}_${ºsc}"></div>`);
            this.ºcontainer[ºsc] = $(`#${this.ºname}_${ºsc}`);
        }
        this.ºmsg[ºsc] = new ºMsg(`msg_${this.ºname}_${ºsc}`);
        if (this.ºspecs.ºfetch_url != null) {
            return this.º_fetch(ºsc);
        }
        else {
            this.ºimplementation.ºweld(ºsc);
            console.log(`_WELD END ${this.ºname}-${ºsc}`);
        }
    },
    º_wire: function(ºsc) {
        console.log(`_WIRE ${this.ºname}-${ºsc}`);
        this.ºimplementation.ºwire(ºsc); // perform ºwire actions that are ºspecific to this component
    },
    º_work: function(ºsc) {
        console.log(`_WORK ${this.ºname}-${ºsc}`);
        this.º_visibility(ºsc, true);
        this.ºimplementation.ºwork(ºsc); // perform ºwork actions that are ºspecific to this component
    },
    ºwork: function(ºsc) { // ºwork (changed) state to current material
        if (this.ºhasSubcomponent(ºsc) && this.ºimplementation.ºshow(ºsc)) { // ºshow/hide depending on the ºspecific condition
            this.ºensure(ºsc, `ºweld`, `º_weld`);
            this.ºensure(ºsc, `ºwire`, `º_wire`);
            this.ºensure(ºsc, `ºwork`, `º_work`);
        }
        else {
            this.º_visibility(ºsc, false);
        }
    },
    ºweld: function(ºsc) {
        if (this.ºhasSubcomponent(ºsc) && this.ºimplementation.ºshow(ºsc)) {
            this.ºensure(ºsc, `ºweld`, `º_weld`);
        }
    },
    ºwire: function(ºsc) {
        if (this.ºhasSubcomponent(ºsc) && this.ºimplementation.ºshow(ºsc)) {
            this.ºensure(ºsc, `ºwire`, `º_wire`);
        }
    },
    ºwork: function(ºsc) { // ºwork (changed) state to current material
        if (this.ºhasSubcomponent(ºsc) && this.ºimplementation.ºshow(ºsc)) { // ºshow/hide depending on the ºspecific condition
            this.ºensure(ºsc, `ºwork`, `º_work`);
        }
        else {
            this.º_visibility(ºsc, false);
        }
    },
};
/* INDIVIDUAL COMPONENT: ºControl
 * This manages the controls that correspond to lists of records to be displayed in the middle column
 * Clicking on a control shows the corresponding list and hides all others.
 */

function ºControl(ºcomponent) {
    this.ºcomponent = ºcomponent;
    this.ºwidget = {};
    this.ºctl = {};
};

ºControl.prototype = {
    º_html: function(ºsc) {
        this.ºcomponent.ºcontainer[ºsc].html(`<a class="•control_title" href="#">${this.ºcomponent.ºstate.ºshowState('list', ºsc, 'ºsg')}</a> `);
    },
    º_dressup: function(ºsc) {
        this.ºctl[ºsc].click(function(ºe) {ºe.preventDefault();
            this.ºcomponent.ºstate.ºsetState(`list`, ºsc);
        }.bind(this))
    },
    º_isActive: function(ºsc) {
        return this.ºcomponent.ºstate.ºgetState(`list`) == ºsc;
    },
    ºshow: function(ºsc) {
        return true;
    },
    ºweld: function(ºsc) {
        this.º_html(ºsc);
        this.ºwidget[ºsc] =  this.ºcomponent.ºcontainer[ºsc];
        this.ºwidget[ºsc].addClass(`•control_big`);
        this.ºctl[ºsc] =  this.ºcomponent.ºcontainer[ºsc].find(`a`);
    },
    ºwire: function(ºsc) {
        this.º_dressup(ºsc);
    },
    ºwork: function(ºsc) {
        if (this.º_isActive(ºsc)) {
            this.ºctl[ºsc].addClass(`•ison`);
            this.ºwidget[ºsc].addClass(`•ison`);
        }
        else {
            this.ºctl[ºsc].removeClass(`•ison`);
            this.ºwidget[ºsc].removeClass(`•ison`);
        }
    }
};
/* INDIVIDUAL COMPONENT: ctype
 * This manages the facet "contribution type"
 */

function ºCType(ºcomponent) {
    this.ºcomponent = ºcomponent;
    this.ºdistilled = {};
    this.º_list = {};
    this.º_related_state = {};
    this.º_all_values_control = {};
    this.º_statistics = {};
    this.º_related_values_list = {};
    this.º_related_values_index = {};
    this.º_related_values_on = {};
    this.º_related_values_off = {};
    this.º_no_values = {ºvalue: `-`, ºname: `-none`};
    this.º_type = `type`;
};

ºCType.prototype = {
    º_html: function(ºsc) {
        var ºcols = 2;
        var ºtype_sg = this.ºcomponent.ºstate.ºshowState(`ºlist`, this.º_type, `ºsg`);
        var ºtype_pl = this.ºcomponent.ºstate.ºshowState(`ºlist`, this.º_type, `ºpl`);
        var ºh = `<div><p class="•dctrl">By ${ºtype_sg}</p>`;
        ºh += `<p class="•all"><span rv="_all" class="•stats"></span> <a rv="_all" href="#" class="•control_med">all ${ºtype_pl}</a></p>
<table class="•value_list" id="list-ctype_${ºsc}"><tr>`;
        this.º_related_values_list[ºsc].forEach(function(ºrelated_value, ºi, ºar) {
            if ((ºi % ºcols == 0) && (ºi > 0) && (ºi < ºar.length)) {
                ºh += `</tr><tr>`;
            }
            ºh += `<td><span rv="${ºrelated_value}" class="•stats"></span></td><td><a rv="${ºrelated_value}" href="#" class="•control_small">${this.º_related_values_index[ºsc][ºrelated_value]}</a></td>`;
        }, this);
        ºh += `</tr></table></div>`;
        this.ºcomponent.ºcontainer[ºsc].html(ºh);
    },
    º_dressup: function(ºsc) {
        this.º_list[ºsc] = $(`#list-ctype_${ºsc}`);
        var ºthat = this;
        this.º_list[ºsc].find(`.•control_small`).click(function(ºe) {ºe.preventDefault();
            var ºrelated_value = $(this).attr(`rv`);
            var ºselected = ºthat.º_from_str(ºsc, ºthat.ºcomponent.ºstate.ºgetState(`type_${ºsc}`));
            ºselected[ºrelated_value] = (ºrelated_value in ºselected)?!ºselected[ºrelated_value]:true;
            ºthat.ºcomponent.ºstate.ºsetState(`type_${ºsc}`, ºthat.º_to_str(ºselected));
        });
        this.º_all_values_control[ºsc] = this.ºcomponent.ºcontainer[ºsc].find(`[rv="_all"]`);
        this.º_all_values_control[ºsc].click(function(ºe) {ºe.preventDefault();
            var ºison = $(this).hasClass(`•ison`);
            if (ºison) {
                ºthat.ºcomponent.ºstate.ºsetState(`type_${ºsc}`, ºthat.º_to_str(ºthat.º_related_values_off[ºsc]));
            }
            else {
                ºthat.ºcomponent.ºstate.ºsetState(`type_${ºsc}`, ºthat.º_to_str(ºthat.º_related_values_on[ºsc]));
            }
        });
    },
    º_setFacet: function(ºsc, ºrelated_values) {
        var ºall_selected = true;
        for (var ºrelated_value in this.º_related_values_index[ºsc]) {
            var ºfacet_cell = this.º_list[ºsc].find(`[rv="${ºrelated_value}"]`);
            if (ºrelated_value in ºrelated_values && ºrelated_values[ºrelated_value]) {
                ºfacet_cell.addClass(`•ison`);
            }
            else {
                ºfacet_cell.removeClass(`•ison`, ºfacet_cell);
                ºall_selected = false;
            }
        }
        if (ºall_selected) {
            this.º_all_values_control[ºsc].addClass(`•ison`);
        }
        else {
            this.º_all_values_control[ºsc].removeClass(`•ison`);
        }
    },
    º_to_str: function(ºob) {
        var ºar = [];
        for (var ºx in ºob) {
            if (ºob[ºx]) {
                ºar.push(ºx);
            }
        }
        return ºar.join(',');
    },
    º_from_str: function(ºsc, ºst) {
        var ºob = {};
        if (ºst !== null && ºst != undefined && ºst != '') {
            var ºar = ºst.split(',');
            ºar.forEach(function(ºv) {
                ºob[ºv] = true;
            });
        }
        for (var ºrelated_value in this.º_related_values_index[ºsc]) {
            if (!(ºrelated_value in ºob)) {
                ºob[ºrelated_value] = false;
            }
        }
        return ºob;
    },
    ºstats: function(ºsc) {
        this.º_statistics[ºsc] = {};
        for (var ºrelated_value in this.º_related_values_index[ºsc]) {
            this.º_statistics[ºsc][ºrelated_value] = 0;
        } 
        var ºrelated_data = this.ºcomponent.ºdata[ºsc];
        for (var ºx in this.ºdistilled[ºsc]) {
            var ºi = this.ºdistilled[ºsc][ºx];
            var ºhas_related_value = false;
            for (var ºrelated_value in ºrelated_data[ºi]) {
                this.º_statistics[ºsc][ºrelated_value] += 1;
                ºhas_related_value = true;
            }
            if (!ºhas_related_value) {
                this.º_statistics[ºsc][this.º_no_values.ºvalue] += 1;
            }
        }
        for (var ºrelated_value in this.º_statistics[ºsc]) {
            this.ºcomponent.ºcontainer[ºsc].find(`span[rv="${ºrelated_value}"].•stats`).html(this.º_statistics[ºsc][ºrelated_value]);
        }
        this.ºcomponent.ºcontainer[ºsc].find(`span[rv="_all"].•stats`).html(this.ºdistilled[ºsc].length);
    },
    ºv: function(ºsc, ºi) {
        var ºrelated_data =  this.ºcomponent.ºdata[ºsc];
        var ºrelated_state = this.º_from_str(ºsc, this.º_related_state[ºsc]);
        if ((ºi in ºrelated_data) && (Object.keys(ºrelated_data[ºi]).length != 0)) {
            for (var ºrelated_value in ºrelated_data[ºi]) {
                if ((ºrelated_value in ºrelated_state) && ºrelated_state[ºrelated_value]) {
                    return true;
                }
            }
        }
        else {
            if ((this.º_no_values.ºvalue in ºrelated_state) && (ºrelated_state[this.º_no_values.ºvalue])) {
                return true;
            }
        }
        return false;
    },
    ºshow: function(ºsc) {
        return (this.ºcomponent.ºstate.ºgetState(`list`) == ºsc);
    },
    ºweld: function(ºsc) {
        this.º_related_values_list[ºsc] = [];
        this.º_related_values_index[ºsc] = {};
        this.º_related_values_off[ºsc] = {};
        this.º_related_values_on[ºsc] = {};
        var ºrelated_values = this.ºcomponent.ºrelated_values[ºsc];
        for (var ºi in ºrelated_values) {
            var ºrelated_value = ºrelated_values[ºi];
            this.º_related_values_off[ºsc][ºi] = false;
            this.º_related_values_on[ºsc][ºi] = true;
            this.º_related_values_list[ºsc].push(ºi);
            this.º_related_values_index[ºsc][ºi] = ºrelated_value;
        }
        this.º_related_values_list[ºsc].push(this.º_no_values.ºvalue);
        this.º_related_values_index[ºsc][this.º_no_values.ºvalue] = this.º_no_values.ºname;
        this.º_related_values_off[ºsc][this.º_no_values.ºvalue] = false;
        this.º_related_values_on[ºsc][this.º_no_values.ºvalue] = true;
        this.º_related_values_list[ºsc].sort();
        this.º_html(ºsc);
    },
    ºwire: function(ºsc) {
        this.º_dressup(ºsc);
    },
    ºwork: function(ºsc) {
        this.º_related_state[ºsc] = this.ºcomponent.ºstate.ºgetState(`type_${ºsc}`);
        this.º_setFacet(ºsc, this.º_from_str(ºsc, this.º_related_state[ºsc]));
    },
};
/* INDIVIDUAL COMPONENT: ºEUmap
 * This manages a clickable map of the EU ºcountries
 * See http://jvectormap.com/documentation/javascript-api/jvm-map/
 */


function ºEUmap(ºcomponent) {
    this.ºcomponent = ºcomponent;
    this.ºdistilled = {};
    this.º_list = {};
    this.º_related_state = {};
    this.º_all_values_control = {};
    this.º_statistics = {};
    this.º_related_values_list = {};
    this.º_related_values_index = {};
    this.º_related_values_on = {};
    this.º_related_values_off = {};
    this.º_no_values = {ºvalue: `-`, ºname: `-none`};
    this.º_type = `country`;

    this.º_map_object = {};
    this.º_map_container = {};
    this.º_marker = {};
    this.º_setvalues = {};
    this.º_not_mapped = {
        CY: true,
    };
};

ºEUmap.prototype = {
    º_html: function(ºsc) {
        var ºcols = 2;
        var ºtype_sg = this.ºcomponent.ºstate.ºshowState(`ºlist`, this.º_type, `ºsg`);
        var ºtype_pl = this.ºcomponent.ºstate.ºshowState(`ºlist`, this.º_type, `ºpl`);
        var ºh = `<div><p class="•dctrl">By ${ºtype_sg}</p>`;
        ºh += `<div id="map-europe_${ºsc}"></div>`;
        ºh += `<p class="•all"><span rv="_all" class="•stats"></span> <a rv="_all" href="#" class="•control_med">all ${ºtype_pl}</a></p>
<table class="•value_list" id="list-europe_${ºsc}"><tr>`;
        this.º_related_values_list[ºsc].forEach(function(ºrelated_value, ºi, ºar) {
            if ((ºi % ºcols == 0) && (ºi > 0) && (ºi < ºar.length)) {
                ºh += `</tr><tr>`;
            }
            var ºcountry_name = this.º_related_values_index[ºsc][ºrelated_value];
            ºh += `<td><span rv="${ºrelated_value}" class="•stats"></span></td><td><a rv="${ºrelated_value}" href="#" class="•control_small">${ºcountry_name}</a></td>`;
        }, this);
        ºh += `</tr></table></div>`;
        this.ºcomponent.ºcontainer[ºsc].html(ºh);
    },
    º_dressup: function(ºsc) {
        var ºcc = this.ºcomponent.ºcontainer[ºsc];
        this.º_list[ºsc] = ºcc.find(`#list-europe_${ºsc}`);
        this.º_map_container[ºsc] = ºcc.find(`#map-europe_${ºsc}`);
        this.º_map_container[ºsc].width(`100%`);
        this.º_map_container[ºsc].height(this.º_map_container[ºsc].width()*0.6);
        this.º_map_container[ºsc].vectorMap({
            'map': `europe_mill`,
            backgroundColor: `#ccccff`,
            regionsSelectable: true,
            markersSelectable: true,
            regionsSelectableOne: false,
            markersSelectableOne: false,
            markerStyle: {
                initial: {
                    fill: `#008800`,
                    'fill-opacity': 0.2,
                    stroke: `none`,
                    'stroke-width': 0,
                    'stroke-opacity': 0.2,
                    'r': 1,
                },
                hover: {
                    cursor: `pointer`,
                    stroke: `#ffff44`,
                    'stroke-width': 1,
                    'stroke-opacity': 1,
                },
                selected: {
                    fill: `#008800`,
                    'fill-opacity': 1,
                },
                selectedHover: {
                },
            },
            regionStyle: {
                initial: {
                    fill: `#bbbbbb`,
                    'fill-opacity': 1,
                    stroke: `none`,
                    'stroke-width': 0,
                    'stroke-opacity': 1,
                },
                hover: {
                    cursor: `pointer`,
                    stroke: `#ffff44`,
                    'stroke-width': 3,
                    'stroke-opacity': 1,
                },
                selected: {
                    fill: `#dd8844`,
                    'fill-opacity': 1,
                },
                selectedHover: {
                },
            },
            markers: this.º_marker[ºsc],
            series: {
                markers: [{
                    values: {},
                        scale: [0,20],
                        normalizeFunction: `linear`,
                        attribute: `r`,
                        min: 0,
                        max: 100,
                }],
                regions: [{
                        scale: {
                            'ºoutdariah': `#ffffff`,
                            'ºindariah': `#ffeedd`,
                        },
                        attribute: `fill`,
                        values: this.º_setvalues[ºsc],
                }],
            },
            onRegionTipShow: function(ºe, ºel, ºrelated_value) {
                ºel.html(`${ºrelated_value}: ${(ºrelated_value in this.º_statistics[ºsc])?this.º_statistics[ºsc][ºrelated_value]:'not in DARIAH'}`);
            }.bind(this),
            onMarkerTipShow: function(ºe, ºel, ºrelated_value) {
                ºel.html(`${ºrelated_value}: ${(ºrelated_value in this.º_statistics[ºsc])?this.º_statistics[ºsc][ºrelated_value]:'not in DARIAH'}`);
            }.bind(this),
            onRegionClick: function(ºe, ºrelated_value) {
                if (!(ºrelated_value in this.º_related_values_index[ºsc])) {
                    ºe.preventDefault();
                }
            }.bind(this),
            onMarkerClick: function(ºe, ºrelated_value) {
                if (!(ºrelated_value in this.º_related_values_index[ºsc])) {
                    ºe.preventDefault();
                }
            }.bind(this),
            onRegionSelected: function(ºe, ºrelated_value, ºi, ºselected) {
                if (this.ºchange_state) {
                    this.ºcomponent.ºstate.ºsetState(`map_${ºsc}`, this.º_a_to_str(ºselected));
                }
            }.bind(this),
            onMarkerSelected: function(ºe, ºrelated_value, ºi, ºselected) {
                if (this.ºchange_state) {
                    this.ºcomponent.ºstate.ºsetState(`map_${ºsc}`, this.º_a_to_str(ºselected));
                }
            }.bind(this),
        });
        this.º_map_object[ºsc] = this.º_map_container[ºsc].vectorMap('get', 'mapObject');
        this.º_map_object[ºsc].setFocus({regions: [`GB`, `GR`]});
        var ºthat = this;
        this.º_list[ºsc].find(`.•control_small`).click(function(ºe) {ºe.preventDefault();
            var ºrelated_value = $(this).attr(`rv`);
            var ºselected = ºthat.º_from_str(ºsc, ºthat.ºcomponent.ºstate.ºgetState(`map_${ºsc}`));
            ºselected[ºrelated_value] = (ºrelated_value in ºselected)?!ºselected[ºrelated_value]:true;
            ºthat.ºcomponent.ºstate.ºsetState(`map_${ºsc}`, ºthat.º_to_str(ºselected));
        });
        this.º_all_values_control[ºsc] = this.ºcomponent.ºcontainer[ºsc].find(`[rv="_all"]`);
        this.º_all_values_control[ºsc].click(function(ºe) {ºe.preventDefault();
            var ºison = $(this).hasClass(`•ison`);
            if (ºison) {
                ºthat.ºcomponent.ºstate.ºsetState(`map_${ºsc}`, ºthat.º_to_str(ºthat.º_related_values_off[ºsc]));
            }
            else {
                ºthat.ºcomponent.ºstate.ºsetState(`map_${ºsc}`, ºthat.º_to_str(ºthat.º_related_values_on[ºsc]));
            }
        });
    },
    º_setFacet: function(ºsc, ºregions) {
        this.ºchange_state = false;
        /* Cyprus is not on the map, we do ºshow Cyprus in the list but not on the map.
         * Same for -, the key that denotes ALL countries
         */
        var ºmap_regions = {};
        for (var ºregion in ºregions) {
            if (!(ºregion in this.º_not_mapped) && ºregion != this.º_no_values.ºvalue) {
                ºmap_regions[ºregion] = ºregions[ºregion];
            }
        }
        this.º_map_object[ºsc].setSelectedRegions(ºmap_regions);
        this.º_map_object[ºsc].setSelectedMarkers(ºmap_regions);
        this.ºchange_state = true;
        var ºall_selected = true;
        for (var ºrelated_value in this.º_related_values_index[ºsc]) {
            var ºfacet_cell = this.º_list[ºsc].find(`[rv="${ºrelated_value}"]`);
            if (ºrelated_value in ºregions && ºregions[ºrelated_value]) {
                ºfacet_cell.addClass(`•ison`);
            }
            else {
                ºfacet_cell.removeClass(`•ison`);
                ºall_selected = false;
            }
        }
        if (ºall_selected) {
            this.º_all_values_control[ºsc].addClass(`•ison`);
        }
        else {
            this.º_all_values_control[ºsc].removeClass(`•ison`);
        }
    },
    º_a_to_str: function(ºar) {
        return ºar.join(',');
    },
    º_to_str: function(ºob) {
        var ºar = [];
        for (var ºx in ºob) {
            if (ºob[ºx]) {
                ºar.push(ºx);
            }
        }
        return ºar.join(',');
    },
    º_from_str: function(ºsc, ºst) {
        var ºob = {};
        if (ºst !== null && ºst != undefined && ºst != '') {
            var ºar = ºst.split(',');
            ºar.forEach(function(ºv) {
                ºob[ºv] = true;
            });
        }
        for (var ºrelated_value in this.º_related_values_index[ºsc]) {
            if (!(ºrelated_value in ºob)) {
                ºob[ºrelated_value] = false;
            }
        }
        return ºob;
    },
    ºstats: function(ºsc) {
        this.º_statistics[ºsc] = {};
        for (var ºrelated_value in this.º_related_values_index[ºsc]) {
            this.º_statistics[ºsc][ºrelated_value] = 0;
        } 
        var ºrelated_data = this.ºcomponent.ºdata[ºsc];
        for (var ºx in this.ºdistilled[ºsc]) {
            var ºi = this.ºdistilled[ºsc][ºx];
            var ºhas_related_value = false;
            for (var ºrelated_value in ºrelated_data[ºi]) {
                this.º_statistics[ºsc][ºrelated_value] += 1;
                ºhas_related_value = true;
            }
            if (!ºhas_related_value) {
                this.º_statistics[ºsc][this.º_no_values.ºvalue] += 1;
            }
        }
        for (var ºrelated_value in this.º_statistics[ºsc]) {
            this.ºcomponent.ºcontainer[ºsc].find(`span[rv="${ºrelated_value}"].•stats`).html(this.º_statistics[ºsc][ºrelated_value]);
        }
        var ºtotal = this.ºdistilled[ºsc].length;
        if (ºtotal == 0) {ºtotal = 1}
        var ºweighted_statistics = {};
        for (var ºrelated_value in this.º_statistics[ºsc]) {
            if (ºrelated_value != this.º_no_values.ºvalue) {
                var ºpr = 100 * this.º_statistics[ºsc][ºrelated_value] / ºtotal;
                ºweighted_statistics[ºrelated_value] = (ºtotal < 10)?ºpr:(10*Math.sqrt(ºpr));
            }
        }
        this.º_map_object[ºsc].series.markers[0].setValues(ºweighted_statistics);
        this.ºcomponent.ºcontainer[ºsc].find(`span[rv="_all"].•stats`).html(this.ºdistilled[ºsc].length);
    },
    ºv: function(ºsc, ºi) {
        var ºrelated_data =  this.ºcomponent.ºdata[ºsc];
        var ºrelated_state = this.º_from_str(ºsc, this.º_related_state[ºsc]);
        if ((ºi in ºrelated_data) && (Object.keys(ºrelated_data[ºi]).length != 0)) {
            for (var ºrelated_value in ºrelated_data[ºi]) {
                if ((ºrelated_value in ºrelated_state) && ºrelated_state[ºrelated_value]) {
                    return true;
                }
            }
        }
        else {
            if ((this.º_no_values.ºvalue in ºrelated_state) && (ºrelated_state[this.º_no_values.ºvalue])) {
                return true;
            }
        }
        return false;
    },
    ºshow: function(ºsc) {
        return (this.ºcomponent.ºstate.ºgetState(`list`) == ºsc);
    },
    ºweld: function(ºsc) {
        this.º_related_values_list[ºsc] = [];
        this.º_related_values_index[ºsc] = {};
        this.º_related_values_off[ºsc] = {};
        this.º_related_values_on[ºsc] = {};
        var ºrelated_values = this.ºcomponent.ºrelated_values[ºsc];
        this.º_marker[ºsc] = {};
        this.º_setvalues[ºsc] = {};
        for (var ºi in ºrelated_values) {
            var ºrelated_value = ºrelated_values[ºi];
            if (ºrelated_value[1]) {
                this.º_related_values_off[ºsc][ºi] = false;
                this.º_related_values_on[ºsc][ºi] = true;
                this.º_related_values_list[ºsc].push(ºi);
                this.º_related_values_index[ºsc][ºi] = ºrelated_value[0];
                if (ºrelated_value.length > 3) {
                    this.º_marker[ºsc][ºi] = {latLng: [ºrelated_value[2], ºrelated_value[3]], ºname: ºrelated_value[0]};
                }
                this.º_setvalues[ºsc][ºi] = 'ºindariah';
            }
            else {
                this.º_setvalues[ºsc][ºi] = 'ºoutdariah';
            }
        }
        this.º_related_values_list[ºsc].push(this.º_no_values.ºvalue);
        this.º_related_values_index[ºsc][this.º_no_values.ºvalue] = this.º_no_values.ºname;
        this.º_related_values_off[ºsc][this.º_no_values.ºvalue] = false;
        this.º_related_values_on[ºsc][this.º_no_values.ºvalue] = true;
        this.º_related_values_list[ºsc].sort();
        this.º_html(ºsc);
    },
    ºwire: function(ºsc) {
        this.º_dressup(ºsc);
    },
    ºwork: function(ºsc) {
        this.º_related_state[ºsc] = this.ºcomponent.ºstate.ºgetState(`map_${ºsc}`);
        this.º_setFacet(ºsc, this.º_from_str(ºsc, this.º_related_state[ºsc]));
    },
};
/* INDIVIDUAL COMPONENT: Facets
 * This sets up a list of facets for the lists of records to be displayed in the middle column
 * It will host individual facets
 */

function ºFacet(ºcomponent) {
    this.ºcomponent = ºcomponent;
    this.º_stats = {};
    this.ºdata = {};
    this.ºtable = {};
    this.ºdistilled = {};
    this.ºenabled_facets = {};
};

ºFacet.prototype = {
    º_html: function(ºsc) {
        var ºh = ``;
        ºh += `<p>Filtering <span id="fstats_${ºsc}"></span></p>`;
        this.ºcomponent.ºcontainer[ºsc].html(ºh);
    },
    ºshow: function(ºsc) {
        return this.ºcomponent.ºstate.ºgetState(`list`) == ºsc;
    },
    ºweld: function(ºsc) {
        var ºchildren = this.ºcomponent.ºchildren;
        this.ºenabled_facets[ºsc] = {};
        for (var ºfacet_name in ºchildren) {
            var ºfacet_component = ºchildren[ºfacet_name];
            if (ºfacet_component.ºhasSubcomponent(ºsc)) {
                this.ºenabled_facets[ºsc][ºfacet_name] = ºchildren[ºfacet_name];
            }
        }
        this.º_html(ºsc);
    },
    ºwire: function(ºsc) {
        var ºcc = this.ºcomponent.ºcontainer[ºsc];
        var ºlc = this.ºcomponent.ºpage.ºgetComponent(`ºlist`).ºcontainer[ºsc];
        this.º_stats[ºsc] = ºcc.find(`#fstats_${ºsc}`);
        this.ºtable[ºsc] =  ºlc.find(`#table_${ºsc}`);
        var ºdetailcontrols = `<a class="showc fa fa-chevron-right" href="#" title="Show details"></a><a class="hidec fa fa-chevron-down" href="#" title="Hide details"></a>`;
        ºcc.addClass(`•facet`);
        ºcc.find(`p.•dctrl`).each(function() {
            var ºorig = $(this).html();
            $(this).html(`${ºdetailcontrols}&nbsp;${ºorig}`);
        });
        ºcc.find(`p.•dctrl`).closest(`div`).find(`table,.•flt`).show();
        ºcc.find(`.hidec`).show();
        ºcc.find(`.showc`).hide();
        ºcc.find(`.hidec`).click(function(ºe) {ºe.preventDefault();
            var ºdt = $(this).closest(`p`);
            var ºdd = $(this).closest(`div`).find(`table,.•flt`);
            ºdd.hide();
            ºdt.find(`.hidec`).hide();
            ºdt.find(`.showc`).show();
        });
        ºcc.find(`.showc`).click(function(ºe) {ºe.preventDefault();
            var ºdt = $(this).closest(`p`);
            var ºdd = $(this).closest(`div`).find(`table,.•flt`);
            ºdd.show();
            ºdt.find(`.hidec`).show();
            ºdt.find(`.showc`).hide();
        });
    },
    ºwork: function(ºsc) {
        this.ºtable[ºsc].find(`tr[id]`).hide();
        var ºmother_list = this.ºcomponent.ºpage.ºgetComponent(`ºlist`);
        var ºdata = ºmother_list.ºdata[ºsc];
        var ºfacets = this.ºenabled_facets[ºsc];
        this.ºdistilled[ºsc] = [];
        for (var ºfacet_name in ºfacets) {
            var ºfacet= ºfacets[ºfacet_name].ºimplementation;
            ºfacet.ºdistilled[ºsc] = [];
        }
        ºdata.forEach(function(ºd, ºi) {
            var ºv = true; // will hold whether this row passes all facets
/* We collect in the ºdistilled member of this facet object the collective results of all individual facets,
 * Moreover, for each facet, we collect in its ºdistilled member the results when all facets are applied except the facet in question
 * so: 
 * 1. rows with a failure for 2 or more facets are discarded
 * 2. rows with a failure for exactly one facet are added to the data for that facet
 * 3. rows which pass all facets are added to all facets, and also to the final filtered set
 */
            var ºthe_false = null; // which facet has yielded false (if there are more than one we'll ºdiscard the row
            var ºdiscard = false; // becomes true when we have encounterd 2 facets that yield false
            for (var ºfacet_name in ºfacets) {
                if (!ºdiscard) {
                    var ºfacet = ºfacets[ºfacet_name].ºimplementation;
                    var ºthis_v = ºfacet.ºv(ºsc, ºi); // ºthis_v: whether the row passes this facet
                    if (!ºthis_v) {
                        ºv = false;
                        if (ºthe_false == null) { // this is the first failure, we store the facet number in ºthe_false
                            ºthe_false = ºfacet;
                        } // else we ºdiscard the row altogether
                        else {
                            ºdiscard = true;
                        }
                    }
                }
            }
            if (!ºdiscard) {
                if (ºv) {
                    this.ºdistilled[ºsc].push(ºi);
                    this.ºtable[ºsc].find(`tr[id="r${ºd[0]}"]`).show();
                }
                if (ºthe_false != null) {
                    ºthe_false.ºdistilled[ºsc].push(ºi);
                }
                else {
                    for (var ºfacet_name in ºfacets) {
                        var ºfacet = ºfacets[ºfacet_name].ºimplementation;
                        ºfacet.ºdistilled[ºsc].push(ºi);
                    }
                }
            }
        }, this);
        for (var ºfacet_name in ºfacets) {
            var ºfacet = ºfacets[ºfacet_name].ºimplementation;
            ºfacet.ºstats(ºsc);
        }
        this.º_stats[ºsc].html(`${this.ºdistilled[ºsc].length} of ${ºdata.length}`);
    },
};

/* INDIVIDUAL COMPONENT: Filters
 * This is a list of filter controls corresponding to lists of records to be displayed in the middle column
 * Setting a filter control filters the associated list.
 */

function ºFilter(ºcomponent) {
    this.ºcomponent = ºcomponent;
    this.º_tags = {};
    this.º_filter_control = {};
    this.º_box = {};
    this.º_completions_dst = {};
    this.º_stats_dst = {};
    this.º_clear_filter_control = {};
    this.º_wire_mode = {};
    this.º_distilled = {};
    this.ºdistilled = {};
};

ºFilter.prototype = {
    º_html: function(ºsc) {
        var ºh = `<div><p class="•dctrl">By full text search</p>`;
        ºh += `<div id="fltw_${ºsc}">`;
        ºh += `<p id="•fbox_${ºsc}" class="•flt •control_med •fbox ui-ºwidget">`;
        ºh += `<input id="flt_${ºsc}" class="flt"/>`;
        ºh += `<a href="#" class="•control_med fa fa-close •filtc" id="clearf_${ºsc}"></a>`;
        ºh += `<span •fbox class="•stats" id="stats_${ºsc}"></span>&nbsp;`;
        ºh += `</p>`;
        ºh += `<div id="autoc_${ºsc}" style="display: none;">here ${ºsc}</div>`;
        ºh += `</div>`;
        this.ºcomponent.ºcontainer[ºsc].html(ºh);
    },
    º_setFacet: function(ºsc) {
        var ºtextf = this.ºcomponent.ºstate.ºgetState(`flt_${ºsc}`);
        this.º_filter_control[ºsc].val(ºtextf);
        this.º_filter_control[ºsc].autocomplete(`search`, ºtextf);
    },
    º_response: function(ºsc) {
        return function(ºevent, ºui) {
            this.º_distilled[ºsc] = {};
            ºui.content.forEach(function(ºu, ºi) {
                this.º_distilled[ºsc][ºu.value] = 1;
            }, this);
            if (!(this.º_wire_mode[ºsc])) {
                this.ºcomponent.ºstate.ºsetState(`flt_${ºsc}`, this.º_filter_control[ºsc].val());
            }
        }.bind(this);
    },
    º_setClear: function(ºsc) {
        this.º_clear_filter_control[ºsc].click(function(ºe) {ºe.preventDefault();
            this.º_filter_control[ºsc].val(``);
            this.º_filter_control[ºsc].autocomplete(`search`, ``);
        }.bind(this));
    },
    ºstats: function(ºsc) {
        var ºstat_prefix;
        if (this.º_filter_control[ºsc].val() == ``) {
            ºstat_prefix = ``;
            this.º_stats_dst[ºsc].removeClass(`•ison`);
        }
        else {
            ºstat_prefix = `${this.ºfacet.ºdistilled[ºsc].length} of `;
            this.º_stats_dst[ºsc].addClass(`•ison`);
        }
        this.º_stats_dst[ºsc].html(`${ºstat_prefix}${this.ºdistilled[ºsc].length}`);
    },
    ºv: function(ºsc, ºi) {
        return (ºi in this.º_distilled[ºsc]);
    },
    ºshow: function(ºsc) {
        return (this.ºcomponent.ºstate.ºgetState(`list`) == ºsc);
    },
    ºweld: function(ºsc) {
        this.º_html(ºsc);
    },
    ºwire: function(ºsc) {
        if (!this.ºfacet) {
            this.ºfacet = this.ºcomponent.ºpage.ºgetComponent(`ºfacet`).ºimplementation;
        }
        var ºdata = this.ºcomponent.ºpage.ºgetComponent(`ºlist`).ºdata[ºsc];
        this.º_tags[ºsc] = [];
        ºdata.forEach(function(ºd, ºi) {
            this.º_tags[ºsc].push({label: ºd[1], value: `${ºi}`});
        }, this);
        this.º_distilled[ºsc] = {};
        this.ºdistilled[ºsc] = [];
        var ºcc = this.ºcomponent.ºcontainer[ºsc];
        var ºcf = ºcc.find(`#fltw_${ºsc}`);
        this.º_filter_control[ºsc] = ºcf.find(`#flt_${ºsc}`);
        this.º_box[ºsc] = ºcf.find(`#•fbox_${ºsc}`);
        this.º_completions_dst[ºsc] = ºcf.find(`#autoc_${ºsc}`);
        this.º_stats_dst[ºsc] = ºcf.find(`#stats_${ºsc}`);
        this.º_clear_filter_control[ºsc] = ºcf.find(`#clearf_${ºsc}`);
        this.º_filter_control[ºsc].autocomplete({
            appendTo: this.º_completions_dst[ºsc],
            source: this.º_tags[ºsc],
            response: this.º_response(ºsc),
            minLength: 0,
        });
        this.º_setClear(ºsc);
        this.º_wire_mode[ºsc] = true;
        this.º_setFacet(ºsc);
        this.º_wire_mode[ºsc] = false;
    },
    ºwork: function(ºsc) {
        var ºtextf = this.º_filter_control[ºsc].val();
        if (ºtextf == ``) {
            this.º_box[ºsc].removeClass(`•ison`);
            this.º_clear_filter_control[ºsc].hide();
        }
        else {
            this.º_box[ºsc].addClass(`•ison`);
            this.º_clear_filter_control[ºsc].show();
        }
    },
};

/* GENERIC
 * Some function for very generic purposes
 */

var ºescapeHTML = (function () {
    `use strict`;
    var ºchr = {
        '&': `&amp;`, '<': `&lt;`,  '>': `&gt;`
    };
    return function (ºtext) {
        return ºtext.replace(/[&<>]/g, function (ºa) { return ºchr[ºa]; });
    };
}());

var ºRequest = {
    ºparameter: function(ºname) {
        return this.ºparameters()[ºname];
    },
    ºparameters: function(ºuri) {
        var ºi, ºparameter, ºparams, ºquery, ºresult;
        ºresult = {};
        if (!ºuri) {
            ºuri = window.location.search;
        }
        if (ºuri.indexOf("?") === -1) {
            return {};
        }
        ºquery = ºuri.slice(1);
        ºparams = ºquery.split("&");
        ºparams.forEach(function(ºp, ºi) {
            ºparameter = ºp.split("=");
            ºresult[ºparameter[0]] = ºparameter[1];
        });
        return ºresult;
    }
};

var ºrequest_vars = ºRequest.ºparameters();
var ºlocalstorage = $.initNamespaceStorage(`req`);
var ºlocalstorage_vars = ºlocalstorage.localStorage;

/* INDIVIDUAL COMPONENT: ºList
 * This manages the actual lists of records to be displayed in the middle column.
 * The subcomponents corresponds to the individual lists, such as country, countribution
 * All functionality (except ºshow) is delegated to ºspecific functions
 */

function ºList(ºcomponent) {this.ºcomponent = ºcomponent};

ºList.prototype = {
    º_html: function(ºsc) {
        var ºh = ``;
        ºh += `<table id="table_${ºsc}">`;
        if (ºsc == `contrib`) {
            this.ºcomponent.ºdata[ºsc].forEach(function(ºr) {
                ºh += `<tr id="r${ºr[0]}"><td><a href="#" rid="${ºr[0]}">${ºr[1]}</a></td></tr>`;
            });
        }
        else if (ºsc == `country`) {
            this.ºcomponent.ºdata[ºsc].forEach(function(ºr) {
                ºh += `<tr id="r${ºr[0]}"><td class="•country_code">${ºr[0]}<td><td class="•country_name">${ºr[1]}<td></tr>`;
            });
        }
        else if (ºsc == `type`) {
            this.ºcomponent.ºdata[ºsc].forEach(function(ºr) {
                ºh += `<tr id="r${ºr[0]}"><td class="•country_code">${ºr[0]}<td><td class="•country_name">${ºr[1]}<td></tr>`;
            });
        }
        ºh += `</table>`;
        this.ºcomponent.ºcontainer[ºsc].html(ºh);
    },
    ºshow: function(ºsc) {
        return this.ºcomponent.ºstate.ºgetState(`list`) == ºsc;
    },
    ºweld: function(ºsc) {
        this.º_html(ºsc);
    },
    ºwire: function(ºsc) {
    },
    ºwork: function(ºsc) {},
};

/* START PROCESSING
 * The dynamic construction of the page starts here
 */


$(function() {new ºPage().ºwork()});
/* MESSAGES
 * ºMsg is a function that issues messages to a specified element.
 * It has also controls for clearing and hiding the messages.
 */

function ºMsg(ºdestination, ºon_clear) {
    this.º_destination = $(`#${ºdestination}`);
    this.º_trash_control = $(`#trash_${ºdestination}`);
    this.º_trash_control_para = this.º_trash_control.closest(`p`);
    this.º_trash_control.click(function(ºe) {ºe.preventDefault();
        this.ºclear();
    }.bind(this));
    this.º_hide();
    this.º_on_clear = ºon_clear;
};

ºMsg.prototype = {
    º_hide: function() {
        this.º_destination.hide();
        this.º_trash_control_para.hide();
    },
    º_show: function() {
        this.º_destination.show();
        if (this.º_destination.html() != ``) {
            this.º_trash_control_para.show();
        }
    },
    ºclear: function() {
        this.º_destination.html(``);
        if (this.º_on_clear != undefined) {
            this.º_on_clear();
        }
        this.º_hide();
    },
    ºmsg: function(ºtext, ºkind) {
        if (ºkind == undefined) {
            ºkind = `info`;
        }
        var ºmessage_text = this.º_destination.html();
        this.º_destination.html(`${ºmessage_text}<p class="${ºkind}">${ºtext}</p>`);
        this.º_show();
    },
};

/* TOP LEVEL: PAGE
 * This is the page function. 
 * It creates a ViewState function, which contains the current state.
 * The state is created on the basis of request variables, and from then it
 * reflects the user actions.
 * The page specifies all components and initializes them.
 * A component is specfied by the following fields
 * - destination: left => left sidebar; right => right sidebar; middle => middle column
 * - ºname: a string that can be used to refer to the component later on, via method ºgetComponent
 * - subcomponents: a list of names for which a subcomponent will be made. The html will be generated per subcomponent.
 * - fetch: boolean which says whether this component needs data from the server
 * - ºwork first: boolean which says that child components can only be wired after ºwork of the ºparent component.
 * - ºspecific: an object that holds the ºspecific functionality of this component.
 * The control component has ºwork first = true, because only after choosing a list, the list control can fetch the ºspecific list and ºwire itself.
 * All other components have ºwork first = false, because it is desirable that child components start wiring as soon as possible.
 * For example: the facet component is ºparent of the individual facets.
 * When facet starts working, the individual controls should already be wired.
 * Because ºwork first = false, wiring of the individual facets will be triggered after wiring of the generic facet component.
 * N.B. Individual facets can only be wired after the list component (their grandfather) has been wired.
 * This will go OK, because after wiring the list, the facet will be wired and then the individual facets.
 * The º_routing dictionary specifies when the ºwork methods of components should be triggered.
 * Its keys are the labels of components, and for every component a list of other component keys is given.
 * These are the components that will be applied (in that order) after the key component. 
 * 
 *  ºwork from page: if true, this component's ºwork method will be called directly by the page's ºwork method;
 *   if false, the page will skip this component when working. It is assumed that this component will be applied by another component.
 *   This practice must be followed, if the application of state to a component should come after a fetch of another component.
 *   If the page would ºwork the viewstate directly to this component, it would happen before the other's components data had been loaded.
 *   Example: a filter component F, that filters a big list fetched by another component L. L's ºwork should call F's ºwork.
 * After every user action, the state is changed, and a call to the ºPage's ºwork() method is issued.
 * The page will issue the ºwork call forth to all components.
 */

function ºPage() { // the one and only page object
    this.ºname = `page`;
    this.ºmsg = new ºMsg(`msg_${this.ºname}`);
    this.ºstate = new ºViewState(this);
    this.ºstages = {ºweld: true, ºwire: true, ºwork: false}; // true means: once only, false means: my be repeated
    this.ºstages_prev = {ºwire: `ºweld`, ºwork: `ºwire`};
    var ºmain_lists = this.ºstate.ºgetValues(`list`);
    var ºcontrib_list = {contrib: 1};
    this.º_component_specs = {
        ºcontrol: {ºdest: `left`, ºsubcomponents: ºmain_lists, ºfetch_url: null, ºspecific: ºControl}, 
        ºlist: {ºdest: `middle`, ºsubcomponents: ºmain_lists, ºfetch_url: `list`, ºspecific: ºList}, 
        ºfacet: {ºdest: `ºcontrol`, ºsubcomponents: ºmain_lists, ºfetch_url: null, ºspecific: ºFacet}, 
        ºfilter: {ºdest: `ºfacet`, ºsubcomponents: ºmain_lists, ºfetch_url: null, ºspecific: ºFilter}, 
        ºeumap: {ºdest: `ºfacet`, ºsubcomponents: ºcontrib_list, ºfetch_url: `country`, ºspecific: ºEUmap}, 
        ºctype: {ºdest: `ºfacet`, ºsubcomponents: ºcontrib_list, ºfetch_url: `type`, ºspecific: ºCType}, 
    },
    this.º_before = {
        ºweld: {
            ºfacet: {ºcontrol: 1, ºlist: 1},
            ºfilter: {ºfacet: 1},
            ºeumap: {ºfacet: 1, ºfilter: 1},
            ºctype: {ºfacet: 1, ºeumap: 1},
        },
        ºwire: {
            ºfacet: {ºfilter: 1, ºeumap: 1, ºctype: 1},
            ºfilter: {ºlist: 1},
            ºeumap: {ºlist: 1},
            ºctype: {ºlist: 1},
        },
        ºwork: {
            ºfacet: {ºfilter: 1, ºeumap: 1, ºctype: 1},
        },
    };
    this.ºcomponents = {};
    for (var ºname in this.º_component_specs) {
        var ºcomponent = new ºComponent(ºname, this.º_component_specs[ºname], this);
        ºcomponent.ºchildren = {};
        this.ºcomponents[ºname] = ºcomponent;
    }
    for (var ºname in this.º_component_specs) {
        var ºchild_component = this.ºcomponents[ºname];
        var ºdest_name = this.º_component_specs[ºname].ºdest;
        if (ºdest_name in this.ºcomponents) {
            var ºparent_component = this.ºcomponents[ºdest_name];
            ºparent_component.ºchildren[ºname] = ºchild_component;
        }
    }
    for (var ºname in this.ºcomponents) {
        var ºcomponent = this.ºcomponents[ºname];
        ºcomponent.ºbefore = {};
        for (var ºstage in this.º_before) {
            var ºconstraints = this.º_before[ºstage];
            ºcomponent.ºbefore[ºstage] = {};
            if (ºname in ºconstraints) {
                for (var ºbefore_name in ºconstraints[ºname]) {
                   ºcomponent.ºbefore[ºstage][ºbefore_name] = 1;
                } 
            }
        }
    }
    this.º_resolveTiming();
    this.º_setHeight(80);
    History.Adapter.bind(window, `statechange`, this.ºstate.ºwork());
};

ºPage.prototype = {
    º_setHeight(ºsubtract) { // the heights of the sidebars are set, depending on the height of the window
        var ºwh = `${window.innerHeight - ºsubtract}px`;
        for (var ºw in {'middle': 1, 'left': 1, 'right': 1}) {
            $(`#${ºw}`).css(`height`, ºwh);
        }
    },
    º_resolveTiming() {
        /* the time constraints must form a directed acyclic graph.
         * If that is the case, we need a linear order in which we can make the promises
         * This function will calculate that order (of course, several orders are possible)
         * Algorithm:
         *
         * A: make a graph of all tasks, a task is the combination of a component with a stage.
         *
         * B: compute sets of nodes that have a longest predecessor path of fixed length n
         *
         * 1. determine all tasks without predecessors, this is S0                                                (max length of predecessor chain = 0)
         * 2. determine all tasks with all predecessors in S0, this is S1                                             (max length of predecessor chain = 1)
         * 3. determine all tasks with: all predecessors in S0 or S1, at least one predecessor in S1, this is S2  (max length of predecessor chain = 2)
         * ...
         * n+1. determine all tasks with: all predecessors in S0, S1, ..., Sn, at least ione predecessor in Sn
         *
         * C: 
         * Prove theorem 1: Sn = {all nodes with longest chain of predecessors has length n}.
         * Prove theorem 2: all nodes outside union of all Sn: they are part of a cycle.
         *
         * D: 
         * The required order is: first the nodes of S0 (in any order), then those of S1, then those of S2, and so on.
         */
        var ºtiming_nodes = [];
        var ºtiming_edges = {}; // keys are nodes that must come before other nodes
        var ºtiming_edges_inv = {}; // keys are nodes that must come after other nodes
        // A: collect the nodes: pairs of component name and stage
        for (var ºname in this.º_component_specs) {
            for (var ºstage in this.ºstages) {
                ºtiming_nodes.push(`${ºname}-${ºstage}`);
            }
        }
        // collect the edges (we need to store every edge both ways)
        function ºaddEdge(ºprev_node, ºnext_node) {
            if (!(ºprev_node in ºtiming_edges)) {
                ºtiming_edges[ºprev_node] = {};
            }
            if (!(ºnext_node in ºtiming_edges_inv)) {
                ºtiming_edges_inv[ºnext_node] = {};
            }
            ºtiming_edges[ºprev_node][ºnext_node] = true;
            ºtiming_edges_inv[ºnext_node][ºprev_node] = true;
        }
        // 1. per component, the stages are ordered
        for (var ºnext_stage in this.ºstages_prev) {
            var ºprev_stage = this.ºstages_prev[ºnext_stage];
            for (var ºname in this.º_component_specs) {
                ºaddEdge(`${ºname}-${ºprev_stage}`, `${ºname}-${ºnext_stage}`);
            }
        }
        // 2. add the specific constraints from this.º_before
        for (var ºstage in this.º_before) {
            for (var ºnext_name in this.º_before[ºstage]) {
                for (var ºprev_name in this.º_before[ºstage][ºnext_name]) {
                    ºaddEdge(`${ºprev_name}-${ºstage}`, `${ºnext_name}-${ºstage}`);
                }
            }
        }
        // B: compute the Sn (in ºsubset)
        var ºn = 0;
        var ºsubset = [];
        var ºvisited = {}; // collect all nodes that end up in an Sn
        while (ºn <= ºtiming_nodes.length) {
            ºsubset.push({});
            if (ºn == 0) {                                                // first round
                ºtiming_nodes.forEach(function(ºnode) {                   // select all nodes without prev_nodes
                    if (!(ºnode in ºtiming_edges_inv)) {
                        ºsubset[ºn][ºnode] = 1;                          // and store them in subset[0]              
                    }
                });
            }
            else {
                for (var ºprev_node in ºvisited) {                          // start with prev_nodes in visited
                    if (ºprev_node in ºtiming_edges) {                      // and consider their next_nodes
                        for (var ºnext_node in ºtiming_edges[ºprev_node]) {
                            if (!(ºnext_node in ºvisited)) {                // but only if the next_node is not yet visited
                                var ºgood = true;
                                for (var ºother_prev_node in ºtiming_edges_inv[ºnext_node]) { // consider the other prev nodes of the next nodes
                                    if (!(ºother_prev_node in ºvisited)) { // and require that they have been visited already
                                        ºgood = false;
                                        break;
                                    }
                                } 
                                if (ºgood) {
                                    ºsubset[ºn][ºnext_node] = 1;           // if all is well, we add next_node to subset[ºn]
                                }
                            }
                        }
                    }
                }
            }
            if (!Object.keys(ºsubset[ºn]).length) {                                    // if there are no new nodes, the next rounds will also not yield new nodes,
                break;                                                    //  so we are done
            }
            for (var ºnode in ºsubset[ºn]) {                              // after each round we add the saved next_nodes to the visited nodes
                ºvisited[ºnode] = 1;
            }
            ºn++;
        }
        this.º_tasks = [];
        this.º_timing = {};
        if (Object.keys(ºvisited).length != ºtiming_nodes.length) {
            var ºcycle = [];
            ºtiming_nodes.forEach(function(ºnode) {
                if (!(ºnode in ºvisited)) {
                    ºcycle.push(ºnode);
                }
            });
            console.log(`Circular timing constraints detected`, ºcycle);
        }
        else {
            ºsubset.forEach(function(ºnodes, ºn) {
                for (var ºnode in ºnodes) {
                    this.º_tasks.push(ºnode);
                }
            }, this);
            this.º_timing = ºtiming_edges_inv;
            console.log(`Timing resolved`, this.º_tasks);
        }
    },
    ºgetComponent: function(ºname) {
        return this.ºcomponents[ºname];
    },
    ºgetContainer: function(ºname, ºsubcomponents) {
        var ºcontainer = {};
        if (ºname in this.ºcomponents) {
            ºcontainer = this.ºcomponents[ºname].ºcontainer;
        }
        else {
            for (var ºsc in ºsubcomponents) {
                ºcontainer[ºsc] = $(`#${ºname}`);
            }
        }
        return ºcontainer;
    },
    ºgetBefore: function(ºname, ºstage) {
        var ºprev_nodes = [];
        var ºnext_node = `${ºname}-${ºstage}`;
        for (var ºprev_node in (this.º_timing[ºnext_node] || {})) {
            ºprev_nodes.push(ºprev_node.split(`-`));
        }
        return ºprev_nodes;
    },
    ºwork: function() { 
        this.º_tasks.forEach(function(ºtask) {
            var ºtask_comps = ºtask.split(`-`);
            var ºname = ºtask_comps[0];
            var ºstage = ºtask_comps[1];
            var ºcomponent = this.ºgetComponent(ºname);
            for (var ºsc in ºcomponent.ºsubcomponents) {
                ºcomponent[ºstage](ºsc);
            }
        }, this);
    },
};

/* INDIVIDUAL COMPONENT: generic facet based on related values
 * CType and EUmap inherit from this.
 */

function ºRelative(ºcomponent, ºtype) {
    this.ºcomponent = ºcomponent;
    this.ºdistilled = {};
    this.º_list = {};
    this.º_related_state = {};
    this.º_all_values_control = {};
    this.º_statistics = {};
    this.º_related_values_list = {};
    this.º_related_values_index = {};
    this.º_related_values_on = {};
    this.º_related_values_off = {};
    this.º_no_values = {ºvalue: `-`, ºname: `-none`};
    this.º_type = ºtype;
};

ºRelative.prototype = {
    º_html: function(ºsc) {
        var ºcols = 2;
        var ºtype_sg = this.ºcomponent.ºstate.ºshowState(`ºlist`, this.º_type, `ºsg`);
        var ºtype_pl = this.ºcomponent.ºstate.ºshowState(`ºlist`, this.º_type, `ºpl`);
        var ºh = `<div><p class="•dctrl">By ${this.º_type}</p>`;
        ºh += `<p class="•all"><span rv="_all" class="•stats"></span> <a rv="_all" href="#" class="•control_med">all ${this.º_type}s</a></p>
<table class="•value_list" id="list-ctype_${ºsc}"><tr>`;
        this.º_related_values_list[ºsc].forEach(function(ºrelated_value, ºi, ºar) {
            if ((ºi % ºcols == 0) && (ºi > 0) && (ºi < ºar.length)) {
                ºh += `</tr><tr>`;
            }
            ºh += `<td><span rv="${ºrelated_value}" class="•stats"></span></td><td><a rv="${ºrelated_value}" href="#" class="•control_small">${this.º_related_values_index[ºsc][ºrelated_value]}</a></td>`;
        }, this);
        ºh += `</tr></table></div>`;
        this.ºcomponent.ºcontainer[ºsc].html(ºh);
    },
    º_dressup: function(ºsc) {
        this.º_list[ºsc] = $(`#list-ctype_${ºsc}`);
        var ºthat = this;
        this.º_list[ºsc].find(`.•control_small`).click(function(ºe) {ºe.preventDefault();
            var ºrelated_value = $(this).attr(`rv`);
            var ºselected = ºthat.º_from_str(ºsc, ºthat.ºcomponent.ºstate.ºgetState(`type_${ºsc}`));
            ºselected[ºrelated_value] = (ºrelated_value in ºselected)?!ºselected[ºrelated_value]:true;
            ºthat.ºcomponent.ºstate.ºsetState(`type_${ºsc}`, ºthat.º_to_str(ºselected));
        });
        this.º_all_values_control[ºsc] = this.ºcomponent.ºcontainer[ºsc].find(`[rv="_all"]`);
        this.º_all_values_control[ºsc].click(function(ºe) {ºe.preventDefault();
            var ºison = $(this).hasClass(`•ison`);
            if (ºison) {
                ºthat.ºcomponent.ºstate.ºsetState(`type_${ºsc}`, ºthat.º_to_str(ºthat.º_related_values_off[ºsc]));
            }
            else {
                ºthat.ºcomponent.ºstate.ºsetState(`type_${ºsc}`, ºthat.º_to_str(ºthat.º_related_values_on[ºsc]));
            }
        });
    },
    º_setFacet: function(ºsc, ºrelated_values) {
        var ºall_selected = true;
        for (var ºrelated_value in this.º_related_values_index[ºsc]) {
            var ºfacet_cell = this.º_list[ºsc].find(`[rv="${ºrelated_value}"]`);
            if (ºrelated_value in ºrelated_values && ºrelated_values[ºrelated_value]) {
                ºfacet_cell.addClass(`•ison`);
            }
            else {
                ºfacet_cell.removeClass(`•ison`, ºfacet_cell);
                ºall_selected = false;
            }
        }
        if (ºall_selected) {
            this.º_all_values_control[ºsc].addClass(`•ison`);
        }
        else {
            this.º_all_values_control[ºsc].removeClass(`•ison`);
        }
    },
    º_to_str: function(ºob) {
        var ºar = [];
        for (var ºx in ºob) {
            if (ºob[ºx]) {
                ºar.push(ºx);
            }
        }
        return ºar.join(',');
    },
    º_from_str: function(ºsc, ºst) {
        var ºob = {};
        if (ºst !== null && ºst != undefined && ºst != '') {
            var ºar = ºst.split(',');
            ºar.forEach(function(ºv) {
                ºob[ºv] = true;
            });
        }
        for (var ºrelated_value in this.º_related_values_index[ºsc]) {
            if (!(ºrelated_value in ºob)) {
                ºob[ºrelated_value] = false;
            }
        }
        return ºob;
    },
    ºstats: function(ºsc) {
        this.º_statistics[ºsc] = {};
        for (var ºrelated_value in this.º_related_values_index[ºsc]) {
            this.º_statistics[ºsc][ºrelated_value] = 0;
        } 
        var ºrelated_data = this.ºcomponent.ºdata[ºsc];
        for (var ºx in this.ºdistilled[ºsc]) {
            var ºi = this.ºdistilled[ºsc][ºx];
            var ºhas_related_value = false;
            for (var ºrelated_value in ºrelated_data[ºi]) {
                this.º_statistics[ºsc][ºrelated_value] += 1;
                ºhas_related_value = true;
            }
            if (!ºhas_related_value) {
                this.º_statistics[ºsc][this.º_no_values.ºvalue] += 1;
            }
        }
        for (var ºrelated_value in this.º_statistics[ºsc]) {
            this.ºcomponent.ºcontainer[ºsc].find(`span[rv="${ºrelated_value}"].•stats`).html(this.º_statistics[ºsc][ºrelated_value]);
        }
        this.ºcomponent.ºcontainer[ºsc].find(`span[rv="_all"].•stats`).html(this.ºdistilled[ºsc].length);
    },
    ºv: function(ºsc, ºi) {
        var ºrelated_data =  this.ºcomponent.ºdata[ºsc];
        var ºrelated_state = this.º_from_str(ºsc, this.º_related_state[ºsc]);
        if ((ºi in ºrelated_data) && (Object.keys(ºrelated_data[ºi]).length != 0)) {
            for (var ºrelated_value in ºrelated_data[ºi]) {
                if ((ºrelated_value in ºrelated_state) && ºrelated_state[ºrelated_value]) {
                    return true;
                }
            }
        }
        else {
            if ((this.º_no_values.ºvalue in ºrelated_state) && (ºrelated_state[this.º_no_values.ºvalue])) {
                return true;
            }
        }
        return false;
    },
    ºshow: function(ºsc) {
        return (this.ºcomponent.ºstate.ºgetState(`list`) == ºsc);
    },
    ºweld: function(ºsc) {
        this.º_related_values_list[ºsc] = [];
        this.º_related_values_index[ºsc] = {};
        this.º_related_values_off[ºsc] = {};
        this.º_related_values_on[ºsc] = {};
        var ºrelated_values = this.ºcomponent.ºrelated_values[ºsc];
        for (var ºi in ºrelated_values) {
            var ºrelated_value = ºrelated_values[ºi];
            this.º_related_values_off[ºsc][ºi] = false;
            this.º_related_values_on[ºsc][ºi] = true;
            this.º_related_values_list[ºsc].push(ºi);
            this.º_related_values_index[ºsc][ºi] = ºrelated_value;
        }
        this.º_related_values_list[ºsc].push(this.º_no_values.ºvalue);
        this.º_related_values_index[ºsc][this.º_no_values.ºvalue] = this.º_no_values.ºname;
        this.º_related_values_off[ºsc][this.º_no_values.ºvalue] = false;
        this.º_related_values_on[ºsc][this.º_no_values.ºvalue] = true;
        this.º_related_values_list[ºsc].sort();
        this.º_html(ºsc);
    },
    ºwire: function(ºsc) {
        this.º_dressup(ºsc);
    },
    ºwork: function(ºsc) {
        this.º_related_state[ºsc] = this.ºcomponent.ºstate.ºgetState(`type_${ºsc}`);
        this.º_setFacet(ºsc, this.º_from_str(ºsc, this.º_related_state[ºsc]));
    },
};
/* VIEW STATE
 * Contains the current state, based on request variables and local storage.
 * Request variables have precedence over local storage.
 * Request variables are checked and validated and translated, translated ºvalues go to local storage.
 * There is a list of recognized request variables, with their ºtypes and allowable ºvalues.
 */

function ºViewState(ºpage) {
    this.º_data = {};
    this.ºpage = ºpage;
    this.ºmsg = ºpage.ºmsg;
    this.º_getInitstate();
    this.º_addHistory();
};

ºViewState.prototype = {
    º_specs: {
        list: {ºtype: `string`, ºvalues: {contrib: 1, country: 1, type: 1}, ºdefault_value: `contrib`},
        flt_contrib: {ºtype: `string`, ºvalues: null, ºdefault_value: ``},
        flt_country: {ºtype: `string`, ºvalues: null, ºdefault_value: ``},
        flt_type: {ºtype: `string`, ºvalues: null, ºdefault_value: ``},
        map_contrib: {ºtype: `string`, ºvalues: null, ºdefault_value: ``},
        type_contrib: {ºtype: `string`, ºvalues: null, ºdefault_value: ``},
        id: {ºtype: `integer`, ºlimits: {ºmin: -1, ºmax: 1000000}, ºdefault_value: 0},
        sort: {ºtype: `boolean`, ºvalues: {v: true, x: false}, ºdefault_value: true}, 
    },
    º_showas: {
        list: {
            contrib: {ºsg: `contribution`, ºpl: `contributions`},
            country: {ºsg: `country`, ºpl: `countries`},
            type: {ºsg: `type`, ºpl: `types`},
        },
    },
    º_validate: function(ºname, ºval) {
        var ºnewval, ºmessage;
        if (ºname in this.º_specs) {
            var ºspec = this.º_specs[ºname];
            if (ºspec.ºtype == `string`) {
                if (ºspec.ºvalues) {
                    if (ºval in ºspec.ºvalues) {
                        ºnewval = ºval;
                    }
                    else {
                        ºnewval = ºspec.ºdefault_value;
                        this.ºmsg.ºmsg(`illegal string value for ${ºname}: "${ºval}" is replaced by "${ºspec.ºdefault_value}"`, `warning`);
                    }
                }
                else {
                    ºnewval = ºval;
                }
            }
            else if (ºspec.ºtype == `integer`) {
                if (/^(\-|\+)?[0-9]+$/.test(ºval)) {
                    ºnewval = Number(ºval);
                }
                else {
                    ºnewval = ºspec.ºdefault_value;
                    this.ºmsg.ºmsg(`not a number value for ${ºname}: "${ºval}" is replaced by "${ºspec.ºdefault_value}"`, `warning`);
                }
                if (ºnewval < ºspec.ºlimits.ºmin) {
                    this.ºmsg.ºmsg(`number to small for ${ºname}: "${ºnewval}" is replaced by "${ºspec.ºlimits.ºmin}"`, `warning`);
                }
                if (ºnewval > ºspec.ºlimits.ºmax) {
                    this.ºmsg.ºmsg(`number to big for ${ºname}: "${ºnewval}" is replaced by "${ºspec.ºlimits.ºmax}"`, `warning`);
                }
            }
            else if (ºspec.ºtype == `boolean`) {
                if (ºval in ºspec.ºvalues) {
                    ºnewval = ºspec.ºvalues[ºval];
                }
                else {
                    ºnewval = ºspec.ºdefault_value;
                    this.ºmsg.ºmsg(`illegal boolean value for ${ºname}: "${ºval}" is replaced by "${ºspec.ºdefault_value}"`, `warning`);
                }
            }
        }
        else {
            ºnewval = null;
            this.ºmsg.ºmsg(`unknown parameter: ${ºname}=${ºval}`, `warning`);
        }
        return ºnewval;
    },
    º_getVars: function() {
        ºvars = [];
        for (var ºname in this.º_data) {
            var ºval = this.º_data[ºname];
            var ºspec = this.º_specs[ºname];
            if (ºspec.ºtype == `string` || ºspec.ºtype == `integer`) {ºvars.push(`${ºname}=${ºval}`)}
            else if (ºspec.ºtype == `boolean`) {
                for (var ºvalid_val in ºspec.ºvalues) {
                    if (ºspec.ºvalues[ºvalid_val] == ºval) {ºvars.push(`${ºname}=${ºvalid_val}`)}
                }
            }
        }
        return ºvars.join(`&`)
    },
    º_getInitstate: function() {
        for (var ºname in ºrequest_vars) {
            if (!(ºname in this.º_specs)) {
                this.ºmsg.ºmsg(`unknown parameter: ${ºname}=${ºval}`, `warning`);
            }
        }
        for (var ºname in this.º_specs) {
            var ºval = null;
            if (ºname in ºrequest_vars) {
                var ºraw_val = ºrequest_vars[ºname];
                ºval = this.º_validate(ºname, ºraw_val);
                ºlocalstorage_vars.set(ºname, ºval);
            }
            else if (ºlocalstorage_vars.isSet(ºname)) {
                ºval = ºlocalstorage_vars.get(ºname);
            }
            else {
                ºval = this.º_specs[ºname].ºdefault_value;
                ºlocalstorage_vars.set(ºname, ºval);
            }
            this.º_data[ºname] = ºval;
        }
    },
    º_addHistory: function(ºtitle, ºview_url) {
        var ºtit = `DARIAH contribution tool`;
        var ºthis_url = `${app_url}?${this.º_getVars()}`;
        History.pushState(this.º_data, ºtit, ºthis_url);
    },
    ºsetState: function(ºname, ºval) {
        this.º_data[ºname] = ºval;
        ºlocalstorage_vars.set(ºname, ºval);
        this.º_addHistory();
    },
    ºgetState: function(ºname) {
        return this.º_data[ºname];
    },
    ºgetValues: function(ºname) {
        return this.º_specs[ºname].ºvalues;
    },
    ºshowState: function(ºname, ºval, ºmode) {
        var ºresult = ºval;
        var ºmd = (ºmode == undefined)?`ºsg`:ºmode;
        if (this.º_showas[ºname] != undefined && this.º_showas[ºname][ºval] != undefined) {
            ºresult = this.º_showas[ºname][ºval][ºmode];
        }
        return ºresult;
    },
    ºwork: function() {
        return function () {
            var ºstate = History.getState();
            if (ºstate && ºstate.data) {
                this.º_data = ºstate.data;
                this.ºpage.ºwork();
            }
        }.bind(this)
    },
};

