/* GENERIC
 * Some function for very generic purposes
 */

var escapeHTML = (function () {
    `use strict`;
    var chr = {
        '&': `&amp;`, '<': `&lt;`,  '>': `&gt;`
    };
    return function (text) {
        return text.replace(/[&<>]/g, function (a) { return chr[a]; });
    };
}());

var _Request = {
    parameter: function(name) {
        return this.parameters()[name];
    },
    parameters: function(uri) {
        var i, parameter, params, query, result;
        result = {};
        if (!uri) {
            uri = window.location.search;
        }
        if (uri.indexOf("?") === -1) {
            return {};
        }
        query = uri.slice(1);
        params = query.split("&");
        params.forEach(function(p, i) {
            parameter = p.split("=");
            result[parameter[0]] = parameter[1];
        });
        return result;
    }
};

var request_vars = _Request.parameters();
var _localstorage = $.initNamespaceStorage(`req`);
var localstorage_vars = _localstorage.localStorage;

function deselectText() {
    if (document.selection) {
        document.selection.empty();
    }
    else if (window.getSelection) {
        window.getSelection().removeAllRanges();
    }
};

function selectText(containerid) {
    deselectText();
    if (document.selection) {
        var range = document.body.createTextRange();
        range.moveToElementText(document.getElementById(containerid));
        range.select();
    }
    else if (window.getSelection) {
        var range = document.createRange();
        range.selectNode(document.getElementById(containerid));
        window.getSelection().addRange(range);
    }
};

function toggleDetail(widget, detail, extra) {
    var thedetail = (detail == undefined)?widget.closest('div').find('.detail'):detail;
    thedetail.toggle();
    if (extra != undefined) {
        extra(widget);
    }
    var thiscl, othercl;
    if (widget.hasClass('fa-chevron-right')) {
        thiscl = 'fa-chevron-right';
        othercl = 'fa-chevron-down';
    }
    else {
        thiscl = 'fa-chevron-down';
        othercl = 'fa-chevron-right';
    }
    widget.removeClass(thiscl);
    widget.addClass(othercl);
};

function compact(cutoff, size, text) {
    return (text.length > cutoff)?text.replace(/[^ -]+/g, function(x){return x.substr(0,size)}):text;
};

function from_str(st) {
    var ob = {};
    if (st !== null && st != undefined && st != '') {
        var ar = st.split(',');
        ar.forEach(function(v) {
            ob[v] = true;
        });
    }
    return ob;
};
function a_to_str(ar) {
    return ar.join(',');
};
function to_str(ob) {
    var ar = [];
    for (var x in ob) {
        if (ob[x]) {
            ar.push(x);
        }
    }
    return ar.join(',');
};

module.exports.escapeHTML = escapeHTML;
module.exports.request_vars = request_vars;
module.exports.localstorage_vars = localstorage_vars;
module.exports.selectText = selectText;
module.exports.deselectText = deselectText;
module.exports.toggleDetail = toggleDetail;
module.exports.compact = compact;
module.exports.from_str = from_str;
module.exports.to_str = to_str;
module.exports.a_to_str = a_to_str;

/* MESSAGES
 * Msg is a function that issues messages to a specified element.
 * It has also controls for clearing and hiding the messages.
 */

function Msg(destination, on_clear) {
    this._destination = $(`#${destination}`);
    this._trash_control = $(`#trash_${destination}`);
    this._trash_control_para = this._trash_control.closest(`p`);
    this._trash_control.click(function(e) {e.preventDefault();
        this.clear();
    }.bind(this));
    this._hide();
    this._on_clear = on_clear;
};

Msg.prototype = {
    _hide: function() {
        this._destination.hide();
        this._trash_control_para.hide();
    },
    _show: function() {
        this._destination.show();
        if (this._destination.html() != ``) {
            this._trash_control_para.show();
        }
    },
    clear: function() {
        this._destination.html(``);
        if (this._on_clear != undefined) {
            this._on_clear();
        }
        this._hide();
    },
    msg: function(text, kind) {
        if (kind == undefined) {
            kind = `info`;
        }
        var message_text = this._destination.html();
        this._destination.html(`${message_text}<p class="${kind}">${text}</p>`);
        this._show();
    },
};

module.exports = Msg;

/* VIEW STATE
 * Contains the current state, based on request variables and local storage.
 * Request variables have precedence over local storage.
 * Request variables are checked and validated and translated, translated values go to local storage.
 * There is a list of recognized request variables, with their types and allowable values.
 */

var g = require('./generic.js');

function ViewState(page) {
    this._data = {};
    this.page = page;
    this.msg = page.msg;
    this._getInitstate();
    this._addHistory();
};

ViewState.prototype = {
    _specs: {
        list: {url: true, type: `string`, values: {contrib: 1, country: 1, type: 1, tadiraha: 1, tadiraho: 1, tadiraht: 1}, default_value: `contrib`},
        flt_contrib: {url: false, type: `string`, values: null, default_value: ``},
        flt_country: {url: false, type: `string`, values: null, default_value: ``},
        flt_type: {url: false, type: `string`, values: null, default_value: ``},
        flt_tadiraha: {url: false, type: `string`, values: null, default_value: ``},
        flt_tadiraho: {url: false, type: `string`, values: null, default_value: ``},
        flt_tadiraht: {url: false, type: `string`, values: null, default_value: ``},
        rel_country_contrib: {url: false, type: `string`, values: null, default_value: ``},
        rel_type_contrib: {url: false, type: `string`, values: null, default_value: ``},
        rel_tadiraha_contrib: {url: false, type: `string`, values: null, default_value: ``},
        rel_tadiraho_contrib: {url: false, type: `string`, values: null, default_value: ``},
        rel_tadiraht_contrib: {url: false, type: `string`, values: null, default_value: ``},
        item_contrib: {url: true, type: `string`, values: null, default_value: ``},
        item_country: {url: true, type: `string`, values: null, default_value: ``},
        sort: {url: false, type: `boolean`, values: {v: true, x: false}, default_value: true}, 
    },
    _showas: {
        list: {
            contrib: {sg: `contribution`, pl: `contributions`},
            country: {sg: `country`, pl: `countries`},
            type: {sg: `type`, pl: `types`},
            tadiraha: {sg: `tadirah activity`, pl: `tadirah activities`},
            tadiraho: {sg: `tadirah object`, pl: `tadirah objects`},
            tadiraht: {sg: `tadirah technique`, pl: `tadirah techniques`},
        },
    },
    _validate: function(name, val) {
        var newval, message;
        if (name in this._specs) {
            var spec = this._specs[name];
            if (spec.type == `string`) {
                if (spec.values) {
                    if (val in spec.values) {
                        newval = val;
                    }
                    else {
                        newval = spec.default_value;
                        this.msg.msg(`illegal string value for ${name}: "${val}" is replaced by "${spec.default_value}"`, `warning`);
                    }
                }
                else {
                    newval = val;
                }
            }
            else if (spec.type == `integer`) {
                if (/^(\-|\+)?[0-9]+$/.test(val)) {
                    newval = Number(val);
                }
                else {
                    newval = spec.default_value;
                    this.msg.msg(`not a number value for ${name}: "${val}" is replaced by "${spec.default_value}"`, `warning`);
                }
                if (newval < spec.limits.min) {
                    this.msg.msg(`number to small for ${name}: "${newval}" is replaced by "${spec.limits.min}"`, `warning`);
                }
                if (newval > spec.limits.max) {
                    this.msg.msg(`number to big for ${name}: "${newval}" is replaced by "${spec.limits.max}"`, `warning`);
                }
            }
            else if (spec.type == `boolean`) {
                if (val in spec.values) {
                    newval = spec.values[val];
                }
                else {
                    newval = spec.default_value;
                    this.msg.msg(`illegal boolean value for ${name}: "${val}" is replaced by "${spec.default_value}"`, `warning`);
                }
            }
        }
        else {
            newval = null;
            this.msg.msg(`unknown parameter: ${name}=${val}`, `warning`);
        }
        return newval;
    },
    getVars: function(comprehensive) {
        var vars = [];
        for (var name in this._data) {
            var val = this._data[name];
            var spec = this._specs[name];
            if (comprehensive || spec.url) {
                if (spec.type == `string` || spec.type == `integer`) {vars.push(`${name}=${val}`)}
                else if (spec.type == `boolean`) {
                    for (var valid_val in spec.values) {
                        if (spec.values[valid_val] == val) {vars.push(`${name}=${valid_val}`)}
                    }
                }
            }
        }
        return vars.join(`&`)
    },
    _getInitstate: function() {
        for (var name in g.request_vars) {
            if (!(name in this._specs)) {
                this.msg.msg(`unknown parameter: ${name}=${val}`, `warning`);
            }
        }
        for (var name in this._specs) {
            var val = null;
            if (name in g.request_vars) {
                var raw_val = g.request_vars[name];
                val = this._validate(name, raw_val);
                g.localstorage_vars.set(name, val);
            }
            else if (g.localstorage_vars.isSet(name)) {
                val = g.localstorage_vars.get(name);
            }
            else {
                val = this._specs[name].default_value;
                g.localstorage_vars.set(name, val);
            }
            this._data[name] = val;
        }
    },
    _addHistory: function(title, view_url) {
        var tit = `DARIAH contribution tool`;
        var this_url = `${app_url}?${this.getVars(false)}`;
        History.pushState(this._data, tit, this_url);
    },
    setState: function(name, val) {
        this._data[name] = val;
        g.localstorage_vars.set(name, val);
        this._addHistory();
    },
    getState: function(name) {
        return this._data[name];
    },
    getValues: function(name) {
        return this._specs[name].values;
    },
    showState: function(name, val, mode) {
        var result = val;
        var md = (mode == undefined)?`sg`:mode;
        if (this._showas[name] != undefined && this._showas[name][val] != undefined) {
            result = this._showas[name][val][mode];
        }
        return result;
    },
    work: function() {
        return function () {
            var state = History.getState();
            if (state && state.data) {
                this._data = state.data;
                this.page.work();
            }
        }.bind(this)
    },
};

module.exports = ViewState;

/* INDIVIDUAL COMPONENT: generic facet based on related values
 * CType, Tadiraho and EUmap inherit from this.
 */

var g = require('./generic.js');

function Relative(component, rtype, cols, cutoff, shortsize) {
    this.component = component;
    this.distilled = {};
    this._list = {};
    this._list2 = {};
    this._related_state = {};
    this._all_values_control = {};
    this._statistics = {};
    this._related_values_list = {};
    this._related_values_index = {};
    this._related_values_on = {};
    this._related_values_off = {};
    this._no_values = {value: `-`, name: `-none`};
    this._type = rtype;
    this._cols = cols || 2;
    this._cutoff = cutoff || 14;
    this._shortsize = shortsize || 6;
};

Relative.prototype = {
    _html: function(vr) {
        var type_sg = this.component.state.showState(`list`, this._type, `sg`);
        var type_pl = this.component.state.showState(`list`, this._type, `pl`);
        var h = ``;
        h += this._preHtml(vr);
        h += `
<div>
    <p class="dctrl"><span fct="${this.component.name}-${vr}"></span> By ${type_sg}</p>
    <p class="all"><span rv="_all" class="stats"></span> <a rv="_all" href="#" class="facet_single_all">all ${type_pl}</a></p>
    <table class="value_list" id="list-${this._type}-vals_${vr}">
        <tr>
`;
        this._related_values_list[vr].forEach(function(related_value, i, ar) {
            if ((i % this._cols == 0) && (i > 0) && (i < ar.length)) {
                h += `</tr><tr>`;
            }
            var raw_value = this._related_values_index[vr][related_value];
            h += `
            <td><span rv="${related_value}" class="stats"></span></td>
            <td><a rv="${related_value}" href="#" class="facet_single">${g.escapeHTML(raw_value)}</a></td>
            `;
        }, this);
        h += `
        </tr>
    </table>
    <p class="value_list2" id="list2-${this._type}-vals_${vr}">
`;
        this._related_values_list[vr].forEach(function(related_value, i, ar) {
            var raw_value = this._related_values_index[vr][related_value];
            var compact_value = g.escapeHTML(g.compact(this._cutoff, this._shortsize, raw_value));
            h += `<a href="#" rv="${related_value}" class="passive_small" title="${g.escapeHTML(raw_value)}">${compact_value}</a> `;
        }, this);
        h += `
    </p>
</div>`;
        this.component.container[vr].html(h);
    },
    _dressup: function(vr) {
        var cc = this.component.container[vr];
        this._list[vr] = cc.find(`#list-${this._type}-vals_${vr}`);
        this._list2[vr] = cc.find(`#list2-${this._type}-vals_${vr}`);
        var that = this;
        this._list[vr].find(`.facet_single`).click(function(e) {e.preventDefault();
            var related_value = $(this).attr(`rv`);
            var selected = that._from_str(vr, that.component.state.getState(`rel_${that._type}_${vr}`));
            selected[related_value] = (related_value in selected)?!selected[related_value]:true;
            that.component.state.setState(`rel_${that._type}_${vr}`, g.to_str(selected));
            cc.find(`.last_handled`).removeClass(`last_handled`);
            $(this).addClass(`last_handled`);
        });
        this._list2[vr].find(`.passive_small`).click(function(e) {e.preventDefault();
            var related_value = $(this).attr(`rv`);
            var selected = that._from_str(vr, that.component.state.getState(`rel_${that._type}_${vr}`));
            selected[related_value] = (related_value in selected)?!selected[related_value]:true;
            that.component.state.setState(`rel_${that._type}_${vr}`, g.to_str(selected));
            $(this).closest(`div`).find(`.morec`).click();
            var last_handled = that._list[vr].find(`a[rv="${related_value}"]`);
            cc.find(`.last_handled`).removeClass(`last_handled`);
            last_handled.addClass(`last_handled`);
            $(`#left`)[0].scrollTop = 50;
            last_handled[0].scrollIntoView({
                behavior: `smooth`,
                alignToTop: `true`,
            });
        });
        this._all_values_control[vr] = this.component.container[vr].find(`[rv="_all"]`);
        this._all_values_control[vr].click(function(e) {e.preventDefault();
            var ison = $(this).hasClass(`ison`);
            if (ison) {
                that.component.state.setState(`rel_${that._type}_${vr}`, g.to_str(that._related_values_off[vr]));
            }
            else {
                that.component.state.setState(`rel_${that._type}_${vr}`, g.to_str(that._related_values_on[vr]));
            }
        });
    },
    _setFacet: function(vr, related_values) {
        var all_selected = true;
        for (var related_value in this._related_values_index[vr]) {
            var facet_cell = this._list[vr].find(`[rv="${related_value}"]`);
            var facet_cell2 = this._list2[vr].find(`[rv="${related_value}"]`);
            if (related_value in related_values && related_values[related_value]) {
                facet_cell.addClass(`ison`);
                facet_cell2.addClass(`ison`);
            }
            else {
                facet_cell.removeClass(`ison`);
                facet_cell2.removeClass(`ison`);
                all_selected = false;
            }
        }
        if (all_selected) {
            this._all_values_control[vr].addClass(`ison`);
        }
        else {
            this._all_values_control[vr].removeClass(`ison`);
        }
    },
    _from_str: function(vr, st) {
        var ob = {};
        if (st !== null && st != undefined && st != '') {
            var ar = st.split(',');
            ar.forEach(function(v) {
                ob[v] = true;
            });
        }
        for (var related_value in this._related_values_index[vr]) {
            if (!(related_value in ob)) {
                ob[related_value] = false;
            }
        }
        return ob;
    },
    stats: function(vr) {
        this._statistics[vr] = {};
        for (var related_value in this._related_values_index[vr]) {
            this._statistics[vr][related_value] = 0;
        } 
        var related_data = this.component.data[vr];
        for (var x in this.distilled[vr]) {
            var i = this.distilled[vr][x];
            var has_related_value = false;
            for (var related_value in related_data[i]) {
                this._statistics[vr][related_value] += 1;
                has_related_value = true;
            }
            if (!has_related_value) {
                this._statistics[vr][this._no_values.value] += 1;
            }
        }
        for (var related_value in this._statistics[vr]) {
            this.component.container[vr].find(`span[rv="${related_value}"].stats`).html(this._statistics[vr][related_value]);
        }
        this.component.container[vr].find(`span[rv="_all"].stats`).html(this.distilled[vr].length);
        this._myStats(vr);
    },
    v: function(vr, i) {
        var related_data =  this.component.data[vr];
        var related_state = this._from_str(vr, this._related_state[vr]);
        if ((i in related_data) && (Object.keys(related_data[i]).length != 0)) {
            for (var related_value in related_data[i]) {
                if ((related_value in related_state) && related_state[related_value]) {
                    return true;
                }
            }
        }
        else {
            if ((this._no_values.value in related_state) && (related_state[this._no_values.value])) {
                return true;
            }
        }
        return false;
    },
    show: function(vr) {
        return (this.component.state.getState(`list`) == vr);
    },
    weld: function(vr) {
        this._related_values_list[vr] = [];
        this._related_values_index[vr] = {};
        this._related_values_off[vr] = {};
        this._related_values_on[vr] = {};
        this._plainWeld(vr);
        this._myWeld(vr);
        this._related_values_list[vr].push(this._no_values.value);
        this._related_values_index[vr][this._no_values.value] = this._no_values.name;
        this._related_values_off[vr][this._no_values.value] = false;
        this._related_values_on[vr][this._no_values.value] = true;
        this._html(vr);
    },
    wire: function(vr) {
        this._myDressup(vr);
        this._dressup(vr);
    },
    work: function(vr) {
        this._related_state[vr] = this.component.state.getState(`rel_${this._type}_${vr}`);
        var related_values =  this._from_str(vr, this._related_state[vr]);
        this._mySetFacet(vr, related_values);
        this._setFacet(vr, related_values);
    },
    _plainWeld: function(vr) {
        var related_values = this.component.related_values[vr];
        for (var i in related_values) {
            var related_value = related_values[i];
            this._related_values_off[vr][i] = false;
            this._related_values_on[vr][i] = true;
            this._related_values_list[vr].push(i);
            this._related_values_index[vr][i] = related_value;
        }
        this._related_values_list[vr].sort(function(a,b) {
            return (related_values[a] < related_values[b])?-1:(related_values[a] > related_values[b])?1:0; 
        });
    },
    _myWeld: function(vr) {},
    _preHtml: function(vr) {return ``},
    _myDressup: function(vr) {},
    _mySetFacet: function(vr) {},
    _myStats: function(vr) {},
};

module.exports = Relative;

/* INDIVIDUAL COMPONENT: ctype
 * This manages the facet "contribution type"
 */

var Relative = require('./relative.js');

function CType(component) {
    Relative.call(this, component, `type`);
};

CType.prototype = Object.create(Relative.prototype);
CType.prototype.constructor = CType;

module.exports = CType;

/* INDIVIDUAL COMPONENT: ctype
 * This manages the facet "contribution type"
 */

var Relative = require('./relative.js');

function TadirahO(component) {
    Relative.call(this, component, `tadiraho`);
};

TadirahO.prototype = Object.create(Relative.prototype);
TadirahO.prototype.constructor = TadirahO;

module.exports = TadirahO;

/* INDIVIDUAL COMPONENT: ctype
 * This manages the facet "contribution type"
 */

var Relative = require('./relative.js');

function TadirahA(component) {
    Relative.call(this, component, `tadiraha`);
};

TadirahA.prototype = Object.create(Relative.prototype);
TadirahA.prototype.constructor = TadirahA;

module.exports = TadirahA;

/* INDIVIDUAL COMPONENT: ctype
 * This manages the facet "contribution type"
 */

var Relative = require('./relative.js');

function TadirahT(component) {
    Relative.call(this, component, `tadiraht`, 1, 30);
};

TadirahT.prototype = Object.create(Relative.prototype);
TadirahT.prototype.constructor = TadirahT;

module.exports = TadirahT;

/* INDIVIDUAL COMPONENT: EUmap
 * This manages a clickable map of the EU countries
 * See http://jvectormap.com/documentation/javascript-api/jvm-map/
 */

var g = require('./generic.js');
var Relative = require('./relative.js');

function EUmap(component) {
    Relative.call(this, component, `country`);
    this._map_object = {};
    this._map_container = {};
    this._marker = {};
    this._setvalues = {};
    this._not_mapped = {
        '-': true,
        CY: true,
        KS: true,
        TR: true,
        MC: true,
        GE: true,
    };
};

EUmap.prototype = Object.create(Relative.prototype);
EUmap.prototype.constructor = EUmap;
EUmap.prototype._preHtml = function(vr) {
    return `<div id="map-europe_${vr}" class="position"><p class="zoom"><a class="fa fa-arrows" href="#" title="zoom to fit all countries"/></p></div>`;
};
EUmap.prototype._myDressup = function(vr) {
    var that = this;
    var cc = this.component.container[vr];
    this._map_container[vr] = cc.find(`#map-europe_${vr}`);
    var height = this._map_container[vr].width()*0.6;
    this._map_container[vr].width(`100%`);
    this._map_container[vr].height(height);
    this._map_container[vr].vectorMap({
        'map': `europe_mill`,
        backgroundColor: `#ccccff`,
        regionsSelectable: true,
        markersSelectable: true,
        regionsSelectableOne: false,
        markersSelectableOne: false,
        markerStyle: {
            initial: {
                fill: `#008800`,
                'fill-opacity': 0.2,
                stroke: `none`,
                'stroke-width': 0,
                'stroke-opacity': 0.2,
                'r': 1,
            },
            hover: {
                cursor: `pointer`,
                stroke: `#ffff44`,
                'stroke-width': 1,
                'stroke-opacity': 1,
            },
            selected: {
                fill: `#008800`,
                'fill-opacity': 1,
            },
            selectedHover: {
            },
        },
        regionStyle: {
            initial: {
                fill: `#bbbbbb`,
                'fill-opacity': 1,
                stroke: `none`,
                'stroke-width': 0,
                'stroke-opacity': 1,
            },
            hover: {
                cursor: `pointer`,
                stroke: `#ffff44`,
                'stroke-width': 3,
                'stroke-opacity': 1,
            },
            selected: {
                fill: `#dd8844`,
                'fill-opacity': 1,
            },
            selectedHover: {
            },
        },
        markers: this._marker[vr],
        series: {
            markers: [{
                values: {},
                    scale: [0,20],
                    normalizeFunction: `linear`,
                    attribute: `r`,
                    min: 0,
                    max: 100,
            }],
            regions: [{
                    scale: {
                        'outdariah': `#ffffff`,
                        'indariah': `#ffddbb`,
                    },
                    attribute: `fill`,
                    values: this._setvalues[vr],
            }],
        },
        onRegionTipShow: function(e, el, related_value) {
            el.html(`${related_value}: ${(related_value in this._statistics[vr])?this._statistics[vr][related_value]:'not in DARIAH'}`);
        }.bind(this),
        onMarkerTipShow: function(e, el, related_value) {
            el.html(`${related_value}: ${(related_value in this._statistics[vr])?this._statistics[vr][related_value]:'not in DARIAH'}`);
        }.bind(this),
        onRegionClick: function(e, related_value) {
            if (!(related_value in this._related_values_index[vr])) {
                e.preventDefault();
            }
        }.bind(this),
        onMarkerClick: function(e, related_value) {
            if (!(related_value in this._related_values_index[vr])) {
                e.preventDefault();
            }
        }.bind(this),
        onRegionSelected: function(e, related_value, i, selected) {
            if (this.change_state) {
                this.component.state.setState(`rel_${this._type}_${vr}`, g.a_to_str(selected)+this._unmapped_selected(vr));
            }
        }.bind(this),
        onMarkerSelected: function(e, related_value, i, selected) {
            if (this.change_state) {
                this.component.state.setState(`rel_${this._type}_${vr}`, g.a_to_str(selected)+this._unmapped_selected(vr));
            }
        }.bind(this),
    });
    var zoom_p = cc.find(`p.zoom`);
    zoom_p.css(`top`, `${height-20}px`);
    zoom_p.css(`left`, `10px`);
    var zoom_control = cc.find(`p.zoom a`);
    zoom_control.click(function(e) {e.preventDefault();
        that._map_object[vr].setFocus({regions: [`GB`, `GR`]});
    });
    this._map_object[vr] = this._map_container[vr].vectorMap('get', 'mapObject');
    this._map_object[vr].setFocus({regions: [`GB`, `GR`]});
};
EUmap.prototype._unmapped_selected = function(vr) {
    var result = [];
    var this_state = this._from_str(vr, this.component.state.getState(`rel_${this._type}_${vr}`));
    var empty = true;
    for (var related_value in this._not_mapped) {
        if (related_value in this_state && this_state[related_value]) {
            result.push(related_value);
            empty = false;
        }
    }
    return empty?``:(`,`+result.join(','));
};
EUmap.prototype._mySetFacet = function(vr, related_values) {
    this.change_state = false;
    /* some countries are not on the map, we do show those countries in the list but not on the map.
     * Same for -, the key that denotes ALL countries
     */
    var map_regions = {};
    for (var related_value in related_values) {
        if (!(related_value in this._not_mapped) && related_value != this._no_values.value) {
            map_regions[related_value] = related_values[related_value];
        }
    }
    this._map_object[vr].setSelectedRegions(map_regions);
    this._map_object[vr].setSelectedMarkers(map_regions);
    this.change_state = true;
};
EUmap.prototype._myStats = function(vr) {
    var total = this.distilled[vr].length;
    if (total == 0) {total = 1}
    var weighted_statistics = {};
    for (var related_value in this._statistics[vr]) {
        if (related_value != this._no_values.value) {
            var pr = 100 * this._statistics[vr][related_value] / total;
            weighted_statistics[related_value] = (total < 10)?pr:(10*Math.sqrt(pr));
        }
    }
    this._map_object[vr].series.markers[0].setValues(weighted_statistics);
};
EUmap.prototype._plainWeld = function(vr) {};
EUmap.prototype._myWeld = function(vr) {
    this._marker[vr] = {};
    this._setvalues[vr] = {};
    var related_values = this.component.related_values[vr];
    for (var i in related_values) {
        var related_value = related_values[i];
        if (related_value[1]) {
            this._related_values_off[vr][i] = false;
            this._related_values_on[vr][i] = true;
            this._related_values_list[vr].push(i);
            this._related_values_index[vr][i] = related_value[0];
            if (related_value.length > 3) {
                this._marker[vr][i] = {latLng: [related_value[2], related_value[3]], name: related_value[0]};
            }
            this._setvalues[vr][i] = 'indariah';
        }
        else {
            this._setvalues[vr][i] = 'outdariah';
        }
    }
    this._related_values_list[vr].sort(function(a,b) {
        return (related_values[a] < related_values[b])?-1:(related_values[a][0] > related_values[b][0])?1:0; 
    });
};

module.exports = EUmap;

/* INDIVIDUAL COMPONENT: Filters
 * This is a list of filter controls corresponding to lists of records to be displayed in the middle column
 * Setting a filter control filters the associated list.
 */

function Filter(component) {
    this.component = component;
    this._tags = {};
    this._filter_control = {};
    this._filter_control2 = {};
    this._box = {};
    this._completions_dst = {};
    this._stats_dst = {};
    this._clear_filter_control = {};
    this._wire_mode = {};
    this._distilled = {};
    this.distilled = {};
};

Filter.prototype = {
    _html: function(vr) {
        var h = `
<div>
    <p class="dctrl"><span fct="${this.component.name}-${vr}"></span> By full text search
        <a href="#" title="modify full text filter" id="flt2_${vr}" class="flt_not_expanded facet_single ison flt_pat"></a>
        <a href="#" class="control_med fa fa-close filtc" id="clearf_${vr}"></a>
    </p>
    <div id="fltw_${vr}">
        <p id="fbox_${vr}" class="flt control_med fbox ui-widget">
            <input id="flt_${vr}" class="flt flt_pat"/>
            <span fbox class="stats" id="stats_${vr}"></span>
        </p>
        <div id="autoc_${vr}" style="display: none;">here ${vr}</div>
    </div>
</div>`;
        this.component.container[vr].html(h);
    },
    _setFilter: function(vr) {
        var textf = this.component.state.getState(`flt_${vr}`);
        this._filter_control2[vr].html(textf);
        this._filter_control[vr].val(textf);
        this._filter_control[vr].autocomplete(`search`, textf);
    },
    _response: function(vr) {
        return function(event, ui) {
            this._distilled[vr] = {};
            ui.content.forEach(function(u, i) {
                this._distilled[vr][u.value] = 1;
            }, this);
            if (!(this._wire_mode[vr])) {
                var textf = this._filter_control[vr].val();
                this.component.state.setState(`flt_${vr}`, textf);
            }
        }.bind(this);
    },
    _setClear: function(vr) {
        this._clear_filter_control[vr].click(function(e) {e.preventDefault();
            this._filter_control[vr].val(``);
            this._filter_control[vr].autocomplete(`search`, ``);
        }.bind(this));
    },
    stats: function(vr) {
        var stat_prefix;
        if (this._filter_control[vr].val() == ``) {
            stat_prefix = ``;
            this._stats_dst[vr].removeClass(`ison`);
        }
        else {
            stat_prefix = `${this.facet.distilled[vr].length} of `;
            this._stats_dst[vr].addClass(`ison`);
        }
        this._stats_dst[vr].html(`${stat_prefix}${this.distilled[vr].length}`);
    },
    v: function(vr, i) {
        return (i in this._distilled[vr]);
    },
    show: function(vr) {
        return (this.component.state.getState(`list`) == vr);
    },
    weld: function(vr) {
        this._html(vr);
    },
    wire: function(vr) {
        if (!this.facet) {
            this.facet = this.component.page.getComponent(`facet`).implementation;
        }
        var data = this.component.page.getComponent(`list`).data[vr];
        this._tags[vr] = [];
        data.forEach(function(d, i) {
            this._tags[vr].push({label: d[1], value: `${d[0]}`});
        }, this);
        this._distilled[vr] = {};
        this.distilled[vr] = [];
        var cc = this.component.container[vr];
        var cf = cc.find(`#fltw_${vr}`);
        var flt = $(`#flt_${vr}`);
        this._filter_control[vr] = flt;
        var flt2 = $(`#flt2_${vr}`);
        this._filter_control2[vr] = flt2;
        this._box[vr] = cf.find(`#fbox_${vr}`);
        this._completions_dst[vr] = cf.find(`#autoc_${vr}`);
        this._stats_dst[vr] = cf.find(`#stats_${vr}`);
        this._clear_filter_control[vr] = cc.find(`#clearf_${vr}`);
        this._filter_control[vr].autocomplete({
            appendTo: this._completions_dst[vr],
            source: this._tags[vr],
            response: this._response(vr),
            minLength: 0,
        });
        flt2.click(function(e) {e.preventDefault();
            $(this).closest(`div`).find(`.morec`).click();
            flt[0].focus();
        });
        this._wire_mode[vr] = true;
        this._setClear(vr);
        this._setFilter(vr);
        this._wire_mode[vr] = false;
    },
    work: function(vr) {
        var textf = this.component.state.getState(`flt_${vr}`);
        if (textf == ``) {
            this._box[vr].removeClass(`ison`);
            this._clear_filter_control[vr].hide();
        }
        else {
            this._box[vr].addClass(`ison`);
            this._clear_filter_control[vr].show();
        }
        this._filter_control2[vr].html(textf);
    },
};

module.exports = Filter;

/* INDIVIDUAL COMPONENT: Facets
 * This sets up a list of facets for the lists of records to be displayed in the middle column
 * It will host individual facets
 */

var g = require('./generic.js');

function Facet(component) {
    this.component = component;
    this._stats = {};
    this.data = {};
    this.table = {};
    this.distilled = {};
    this.enabled_facets = {};
};

Facet.prototype = {
    _html: function(vr) {
        var h = ``;
        h += `<p><span fct="all"></span>Filtering <span id="fstats_${vr}"></span></p>`;
        this.component.container[vr].html(h);
    },
    show: function(vr) {
        return this.component.state.getState(`list`) == vr;
    },
    weld: function(vr) {
        var children = this.component.children;
        this.enabled_facets[vr] = {};
        for (var facet_name in children) {
            var facet_component = children[facet_name];
            if (facet_component.hasVariant(vr)) {
                this.enabled_facets[vr][facet_name] = children[facet_name];
            }
        }
        this._html(vr);
    },
    _display: function(expand_control, mode) {
        var that = this;
        var dt = expand_control.closest(`p`);
        var hidec = dt.find(`.hidec`);
        var morec = dt.find(`.morec`);
        var showc = dt.find(`.showc`);
        var expanded_material = expand_control.closest(`div`).find(`table,.flt`);
        var condensed_material = expand_control.closest(`div`).find(`.value_list2,.flt_compact`);
        var not_expanded_material = expand_control.closest(`div`).find(`.flt_not_expanded`);
        var key = `fctx_${expand_control.closest('span').attr('fct')}`;
        var mode_undef = mode == undefined;
        if (mode_undef) {
            if (g.localstorage_vars.isSet(key)) {
                mode = g.localstorage_vars.get(key);
            }
            else {
                mode = 1;
            }
        }
        var all_facets = key == `fctx_all`;
        if (all_facets && !mode_undef) {
            expand_control.closest(`div`).find(`div.component span[fct]`).each(function() {
                that._display($(this), mode);
            });
        }
        g.localstorage_vars.set(key, mode);
        if (mode == 0) {
            hidec.show();
            morec.hide();
            showc.hide();
            if (!all_facets) {
                not_expanded_material.show();
                expanded_material.hide();
                condensed_material.hide();
            }
        }
        else if (mode == 1) {
            hidec.hide();
            morec.show();
            showc.hide();
            if (!all_facets) {
                not_expanded_material.show();
                expanded_material.hide();
                condensed_material.show();
            }
        }
        else {
            hidec.hide();
            morec.hide();
            showc.show();
            if (!all_facets) {
                not_expanded_material.hide();
                expanded_material.show();
                condensed_material.hide();
            }
        }
    },
    wire: function(vr) {
        var that = this;
        var cc = this.component.container[vr];
        var lc = this.component.page.getComponent(`list`).container[vr];
        this._stats[vr] = cc.find(`#fstats_${vr}`);
        this.table[vr] =  lc.find(`#table_${vr}`);
        var info = ` details; click to change level of details`;
        var detailcontrols = `<a class="showc fa fa-fw fa-list-ul" href="#" title="full${info}"></a><a class="morec fa fa-fw fa-align-left" href="#" title="condensed${info}"></a><a class="hidec fa fa-fw fa-minus" href="#" title="hidden${info}"></a>`;
        cc.addClass(`facet`);
        cc.find(`span[fct]`).each(function() {
            $(this).html(`${detailcontrols}&nbsp`);
            that._display($(this));
        });
        cc.find(`.hidec`).click(function(e) {e.preventDefault();
            that._display($(this), 1);
        });
        cc.find(`.morec`).click(function(e) {e.preventDefault();
            that._display($(this), 2);
        });
        cc.find(`.showc`).click(function(e) {e.preventDefault();
            that._display($(this), 0);
        });
    },
    work: function(vr) {
        this.table[vr].find(`tr[id]`).hide();
        var mother_list = this.component.page.getComponent(`list`);
        var data = mother_list.data[vr];
        var facets = this.enabled_facets[vr];
        this.distilled[vr] = [];
        for (var facet_name in facets) {
            var facet= facets[facet_name].implementation;
            facet.distilled[vr] = [];
        }
        data.forEach(function(d, i) {
            var v = true; // will hold whether this row passes all facets
/* We collect in the distilled member of this facet object the collective results of all individual facets,
 * Moreover, for each facet, we collect in its distilled member the results when all facets are applied except the facet in question
 * so: 
 * 1. rows with a failure for 2 or more facets are discarded
 * 2. rows with a failure for exactly one facet are added to the data for that facet
 * 3. rows which pass all facets are added to all facets, and also to the final filtered set
 */
            var the_false = null; // which facet has yielded false (if there are more than one we'll discard the row
            var discard = false; // becomes true when we have encounterd 2 facets that yield false
            for (var facet_name in facets) {
                if (!discard) {
                    var facet = facets[facet_name].implementation;
                    var this_v = facet.v(vr, d[0]); // this_v: whether the row passes this facet
                    if (!this_v) {
                        v = false;
                        if (the_false == null) { // this is the first failure, we store the facet number in the_false
                            the_false = facet;
                        } // else we discard the row altogether
                        else {
                            discard = true;
                        }
                    }
                }
            }
            if (!discard) {
                if (v) {
                    this.distilled[vr].push(d[0]);
                    this.table[vr].find(`tr[id="r${d[0]}"]`).show();
                }
                if (the_false != null) {
                    the_false.distilled[vr].push(d[0]);
                }
                else {
                    for (var facet_name in facets) {
                        var facet = facets[facet_name].implementation;
                        facet.distilled[vr].push(d[0]);
                    }
                }
            }
        }, this);
        for (var facet_name in facets) {
            var facet = facets[facet_name].implementation;
            facet.stats(vr);
        }
        this._stats[vr].html(`${this.distilled[vr].length} of ${data.length}`);
    },
};

module.exports = Facet;

/* INDIVIDUAL COMPONENT: List
 * This manages the actual lists of records to be displayed in the middle column.
 * The subcomponents corresponds to the individual lists, such as country, countribution
 * All functionality (except show) is delegated to specific functions
 */

var g = require('./generic.js');
function List(component) {this.component = component};

List.prototype = {
    _html: function(vr) {
        var h = ``;
        h += `<table id="table_${vr}">`;
        this.component.data[vr].forEach(function(r) {
            var rowstart = `<tr rid="${r[0]}"><td><a class="showc fa fa-fw fa-list-ul" href="#" title="hide fields"></a><a class="hidec fa fa-fw fa-minus" href="#" title="show fields"></a></td>`;
            var rowend = `</tr>`;
            if (vr == `contrib`) {
                h += `${rowstart}<td><a href="#" class="fa fa-fw fa-minus"></a>${r[1]}</td>${rowend}`;
            }
            else if (vr == `country`) {
                in_dariah = (r[3] == 1)?`dariah`:``;
                h += `${rowstart}<td class="country_code">${r[1]}<td><td class="country_name">${r[2]}<td><td class="in_dariah">${in_dariah}</td><td class="latlng">${r[4]}</td><td class="latlng">${r[5]}</td>${rowend}`;
            }
            else if (vr == `type` || vr == `tadiraha` || vr == `tadiraho` || vr == `tadiraht`) {
                h += `${rowstart}<td class="value">${r[1]}<td>${rowend}`;
            }
        });
        h += `</table>`;
        this.component.container[vr].html(h);
    },
    _display: function(row, vr, open_ids) {
        var that = this;
        var hidec = row.find(`.hidec`);
        var showc = row.find(`.showc`);
        var rid = row.attr(`rid`);
        var detail = this.component.container[vr].find(`tr[iid="${rid}"]`);
        var mode = (rid in open_ids) && open_ids[rid];
        if (mode) {
            hidec.show();
            showc.hide();
            if (detail.length) {
                detail.show();
            }
        }
        else {
            hidec.hide();
            showc.hide();
            if (detail.length) {
                detail.hide();
            }
        }
    },
    _set_it: function(control, vr, state) {
        var open_ids = g.from_str(this.state.getState(key));
        var rid = control.closest(`tr`).attr(`rid`);
        open_ids[rid] = state;
        this.state.setState(key, g.to_str(open_ids));
    },
    show: function(vr) {
        return this.component.state.getState(`list`) == vr;
    },
    weld: function(vr) {
        this._html(vr);
    },
    wire: function(vr) {
        var that = this;
        var cc = this.component.container[vr];
        var key = `${this.component.name}_${vr}`;
        cc.find(`.hidec`).click(function(e) {e.preventDefault();
            that._set_it($(this), vr, true);
        });
        cc.find(`.showc`).click(function(e) {e.preventDefault();
            that._set_it($(this), vr, false);
        });
    },
    work: function(vr) {
        var that = this;
        var key = `${this.component.name}_${vr}`;
        var cc = this.component.container[vr];
        var open_ids = g.from_str(this.component.state.getState(`${this.component.name}_${vr}`));
        cc.find(`tr[rid]`).each(function() {
            that._display($(this), vr, open_ids);
        });
    },
};

module.exports = List;

/* INDIVIDUAL COMPONENT: Item
 * This manages the actual records to be displayed inside the list in the middle column.
 * The subcomponents corresponds to the individual lists, such as country, countribution
 * There is an extra argument that specifies the ids of the items that should be displayed.
 * All functionality (except show) is delegated to specific functions
 */

function Item(component) {this.component = component};

Item.prototype = {
    _html: function(vr, it) {
        var destination = this.component._dst[vr];
        var dest_row = destination.find(`tr[id="r${it[0]}"]`);
        console.log(`Finding ${vr} row r${it[0]}:`, dest_row);
        var h = `<tr iid="${it[0]}">`;

        if (vr == `contrib`) {
            var types = [];
            it[5].forEach(function(tp) {
                types.push(`<a href="#" tid="${tp[0]}">${tp[1]}</a>`);
            });
            h += `
<td>
<b>Contact person:</b> ${it[2]}<br/>
<b>Country:</b> ${it[3]} = ${it[4]}<br/>
<b>Types:</b> ${types.join(`, `)}</br>
</td>
`;
        }
        else if (vr == `country`) {
            this.component.data[vr].forEach(function(r) {
                in_dariah = (r[3] == 1)?`dariah`:``;
                h += `<tr id="r${r[0]}"><td class="country_code">${r[1]}<td><td class="country_name">${r[2]}<td><td class="in_dariah">${in_dariah}</td><td class="latlng">${r[4]}</td><td class="latlng">${r[5]}</td></tr>`;
            });
        }
        else if (vr == `type` || vr == `tadiraha` || vr == `tadiraho` || vr == `tadiraht`) {
            this.component.data[vr].forEach(function(r) {
                h += `<tr id="r${r[0]}"><td class="value">${r[1]}<td></tr>`;
            });
        }
        h += `</tr>`;
        console.log(h);
        dest_row.after(h);
    },
    show: function(vr) {
        return this.component.state.getState(`list`) == vr;
    },
    weld: function(vr) {
        this.component.data[vr].forEach(function(it) {
            this._html(vr, it);
        }, this);
    },
    wire: function(vr) {
    },
    work: function(vr) {},
};

module.exports = Item;

/* INDIVIDUAL COMPONENT: Control
 * This manages the controls that correspond to lists of records to be displayed in the middle column
 * Clicking on a control shows the corresponding list and hides all others.
 */

function Control(component) {
    this.component = component;
    this.widget = {};
    this.ctl = {};
};

Control.prototype = {
    _html: function(vr) {
        this.component.container[vr].html(`<a class="control_title" href="#">${this.component.state.showState('list', vr, 'sg')}</a> `);
    },
    _dressup: function(vr) {
        this.ctl[vr].click(function(e) {e.preventDefault();
            this.component.state.setState(`list`, vr);
        }.bind(this))
    },
    _isActive: function(vr) {
        return this.component.state.getState(`list`) == vr;
    },
    show: function(vr) {
        return true;
    },
    weld: function(vr) {
        this._html(vr);
        this.widget[vr] =  this.component.container[vr];
        this.widget[vr].addClass(`control_big`);
        this.ctl[vr] =  this.component.container[vr].find(`a`);
    },
    wire: function(vr) {
        this._dressup(vr);
    },
    work: function(vr) {
        if (this._isActive(vr)) {
            this.ctl[vr].addClass(`ison`);
            this.widget[vr].addClass(`ison`);
        }
        else {
            this.ctl[vr].removeClass(`ison`);
            this.widget[vr].removeClass(`ison`);
        }
    }
};

module.exports = Control;

var g = require('./generic.js');

function Share(component) { // the SHARE component
    this.component = component;
};

Share.prototype = {
    show: function(vr) {
        return true;
    },
    weld: function(vr) {
	    var h = `
<p id="•citeh">Cite</p>
<table align="center">
    <tr>
        <td class="•clip_pv clr">
            <a lnk="" href="#" id="•clip_pv_md" title="link to page content and appearance (markdown)" class="ctrl fa fa-level-down fa-lg fa-fw"></a>
            <a lnk="" href="#" id="•clip_pv_ht" title="link to page content and appearance (html)" class="ctrl fa fa-external-link-square fa-lg fa-fw"></a>
            <a lnk="" href="#" id="•clip_pv_htc" title="link to page content (html)" class="ctrl fa fa-external-link fa-lg fa-fw"></a>
            <a lnk="" href="#" id="•clip_pv_cn" title="copy page content" class="ctrl fa fa-file-text-o fa-lg fa-fw"></a>
        </td>
    </tr>
    <tr>
        <th class="•clip_pv" width="60px">page view</th>
    </tr>
    <tr class="•citexpl">
        <td class="•clip_pv"><span id="•xc_pv" class="ctrl fa fa-chevron-right fa-fw"></span><span id="•x_pv" class="•detail">share link to this page with or without view settings.</span></td>
    </tr>
</table>
<p id="•cdiagpub"></p>
<p id="•cdiagsts"></p>
`;	
        this.component.container[vr].html(h);
    },
    wire: function(vr) {
        var that = this;
        var cc = this.component.container[vr];
        var slink = $(`#self_link`);
        slink.hide();
        cc.addClass(`•socialdrawer`);
        cc.find(`.•detail`).hide();
        cc.find(`#•clip_pv_md,#•clip_pv_ht,#•clip_pv_htc,#•clip_pv_nl`).click(function(e) {e.preventDefault();
            window.prompt(`Press <Cmd-C> and then <Enter> to copy link on clipboard`, $(this).attr(`lnk`));
        });
        cc.find(`#•clip_pv_cn`).click(function(e) {e.preventDefault();
            var containerid = `middle`;
            var app_url_raw = app_url_cite+that.component.state.getVars(true);
            slink.show();
            slink.attr(`href`, app_url_raw);
            g.selectText(containerid);
        });
        cc.find(`#•xc_pv`).click(function(e){e.preventDefault(); g.toggleDetail($(this), $(`#•x_pv`))});
        cc.click(function(e){e.preventDefault();
            var app_url_raw = app_url_cite+that.component.state.getVars(true);
            var app_url_rawc = app_url_cite+that.component.state.getVars(false);
            $(`#•citeh`).hide();
            $(`#•cdiagpub`).html(``);
            $(`#•cdiagsts`).html(``);
            $(`.•clip_pv.clr,#•cdiagpub,#•cdiagsts`).removeClass(`error warning good special`);
            var pvtitle = g.escapeHTML($(`title`).text());
            $(`#•clip_pv_md`).attr(`lnk`, `[${pvtitle}](${app_url_raw})`);
            $(`#•clip_pv_ht`).attr(`lnk`, app_url_raw);
            $(`#•clip_pv_htc`).attr(`lnk`, app_url_rawc);
            $(`#•clip_pv_cn`).attr(`lnk`, app_url_raw);
            $(`#•clip_pv_cn`).attr(`tit`, pvtitle);
            $(this).animate({height:`100px`, width:`200px`, opacity: 0.95}, 300);
        });
        cc.mouseleave(function(){ 
            slink.hide();
            //g.deselectText();
            $(`#•citeh`).show();
            cc.animate({height:`20px`, width: `40px`, opacity: .7}, 300); 
            return false;
        });
    },
    work: function(vr) {},
};

module.exports = Share;

/* COMPONENTS 
 * The Page function specifies and builds a list of components
 * Every component on the page corresponds to a function (with a prototype)
 * This function is stored in a generic Component function in a field called specific.
 * Every component has a list of subcomponents. For example, the 'list' component has a subcomponent 'contrib'
 * for the list of contributions, and a subcomponent 'country' for the list of countries.
 * The generic functions of a component take care of:
 * - generating HTML container divs for the subcomponents under specified destination elements if they does not already exist
 * - showing and hiding the subcomponents, and in general, work the current state data to the subcomponents 
 * - fetching the subcomponent's data from the server, if needed
 * This *specific* functionality of the components are defined in separate files.
 * Of this specific functionality, the following will be called from the generic component function:
 * - show(vr): inspect the current state and determine whether the subcomponent should be shown or hidden
 * - wire(vr): after the data has been fetched, wrap the data into the desired HTML content of the subcomponent
 *   and add the wiring (click events, change events)
 * In turn, the specific functions can access their associated generic components by this.component
 */

/* GENERIC COMPONENT
 * Here is the generic functionality of each component
 */

var g = require('./generic.js');
var Msg = require('./message.js');

function Component(name, specs, page) {
    this.name = name;
    this.page = page;
    this.specs = specs;
    this.variants = specs.variants;
    this._stage = {};
    for (var vr in this.variants) {
        this._stage[vr] = {};
        for (var st in this.page.stages) {
            this._stage[vr][st] = true;
        }
    }
    this.msg = {};
    this.container = {};
    this.state = this.page.state;
    this.data = {};
    this.related_values = {};
    this.ids_fetched = {};
    this.implementation = new specs.specific(this);
};

Component.prototype = {
    /* need, deed, ensure are wrappers around the promise mechanism.
     * The stage is a stage in processing the component, such as fetch, wire, work.
     * There should be a method method which does the work and which is expected to return a promise.
     * If it does not, we detect it, and yield a promise that is resolved with the original return value.
     * ensure takes care that the function of an action is promised to be execute once, by registering it
     * as a promise for that stage.
     * If there is already a fulfilled or pending promise for that action at that stage, no new promise will be made.
     * Ensure returns a function with no arguments. If it is called, the promise will be made.
     * So the result of ensure can be put inside the .then() of an other promise.
     * Now is a function that calls a function and returns the result as promise.
     */
    need: function(vr, stage) { // check whether there is a promise and whether it has been fulfilled
        return !this._stage[vr][stage].state || (this._stage[vr][stage].state() == `rejected`);
    },
    _deed: function(vr, stage, method) { // register a promise to perform the method associated with stage by entering it in the book keeping of stages
            /* we want to pass a method call to a .then() later on.
             * If we pass it straight, like this.method, .then() will call this function and supplies its own promise object as the this.
             * That is not our purpose: we want to call the method with the current component object as the this.
             * Hence we use bind() in order to supply the right this.
             * Whoever calls this new function methodCall, will perform a true method call of method method on object that.
             * This is crucial, otherwise all the careful time logic gets mangled, because the promises are stored in the component object.
             */
        var methodCall = this[method].bind(this, vr);
        var timing = this.page.getBefore(this.name, stage);
        var promises = [];
        timing.forEach(function(task) {
            var prev_name = task[0];
            var prev_stage = task[1];
            var prev_component = this.page.getComponent(prev_name);
            if (prev_component.hasVariant(vr)) {
                promises.push(prev_component._stage[vr][prev_stage]);
            }
        }, this);
        this._stage[vr][stage] = $.when.apply($, promises).then(methodCall);
    },
    ensure: function(vr, stage, method) {
        /* function to promise that method fun will be executed once and once only or multiple times,
         * but only if the before actions have been completed
         */
        if (stage in this.page.stages) {
            /* if the component works per id, the once setting of the stage is ignored
             * because we have to look whether we should execute that stage for new identifiers
             */
            var once = this.page.stages[stage] && !this.specs.by_id;
            if (!once || this.need(vr, stage)) {
                this._deed(vr, stage, method);
            }
        }
    },
    /* here are the implementations of the functions that are to be wrapped as promises
     * They can focus on the work, may or may not yield a promise
     */    
    hasVariant: function(vr) {
        return (vr in this.variants);
    },
    _visibility: function(vr, on) {
        if (this.hasVariant(vr)) {
            if (vr in this.container) {
                if (on) {
                    this.container[vr].show();
                }
                else {
                    this.container[vr].hide();
                }
            }
        }
    },
    _fetch: function(vr, ids_to_fetch) { // get the material by AJAX if needed
        var fetch_url = url_tpl.replace(/_c_/, `data`).replace(/_f_/, `${this.specs.fetch_url}_${vr}`)+`.json`;
        this.msg[vr].msg(`fetching data ...`);
        var postFetch = this._postFetch.bind(this, vr);
        if (!(ids_to_fetch == undefined)) {
            fetch_url += `?ids=${ids_to_fetch.join(',')}`;
        }
        return $.ajax({
            type: `POST`,
            url: fetch_url,
            contentType: `application/json; charset=utf-8`,
            dataType: `json`,
        }).then(function(json) {
            postFetch(json, ids_to_fetch);
        });
    },
    _postFetch: function(vr, json, ids_to_fetch) { // receive material after AJAX call
        this.msg[vr].clear();
        json.msgs.forEach(function(m) {
            this.msg[vr].msg(m);
        }, this);
        if (json.good) {
            this.data[vr] = json.data;
            if (this.specs.by_id) {
                console.log(json.data);
            }
            if (`relvals` in json) {
                this.related_values[vr] = json.relvals;
            }
            if (this.specs.by_id) {
                ids_to_fetch.forEach(function(id) {
                    this.ids_fetched[id] = true;
                }, this);
            }
        }
        this.implementation.weld(vr);
    },
    _weld: function(vr) {
        this._dst = this.page.getContainer(this.specs.dest, this.variants);
        if (!(this.specs.by_id)) {
            this.container[vr] = $(`#${this.name}_${vr}`);
            if (this.container[vr].length == 0) {
                var destination = this._dst[vr];
                destination.append(`<div id="msg_${this.name}_${vr}"></div>`);
                destination.append(`<div id="${this.name}_${vr}" class="component"></div>`);
                this.container[vr] = $(`#${this.name}_${vr}`);
            }
            this.msg[vr] = new Msg(`msg_${this.name}_${vr}`);
        }
        else {
            if (!(vr in this.msg)) {
                var destination = this._dst[vr];
                destination.prepend(`<div id="msg_${this.name}_${vr}"></div>`);
                this.msg[vr] = new Msg(`msg_${this.name}_${vr}`);
            }
        }
        if (this.specs.fetch_url != null) {
            var ids_to_fetch = [];
            if (this.specs.by_id) {
                var ids_asked_for = g.from_str(this.state.getState(`${this.specs.fetch_url}_${vr}`));
                for (var id in ids_asked_for) {
                    if (!(id in this.ids_fetched)) {
                        ids_to_fetch.push(id);
                    }
                }
                console.log(`ids to fetch ${this.name} - ${vr}`, ids_to_fetch);
                if (ids_to_fetch.length != 0) {
                    return this._fetch(vr, ids_to_fetch);
                }
            }
            else {
                return this._fetch(vr);
            }
        }
        else {
            this.implementation.weld(vr);
        }
    },
    _wire: function(vr) {
        this.implementation.wire(vr); // perform wire actions that are specific to this component
    },
    _work: function(vr) {
        this._visibility(vr, true);
        this.implementation.work(vr); // perform work actions that are specific to this component
    },
    weld: function(vr) {
        if (this.hasVariant(vr) && this.implementation.show(vr)) {
            this.ensure(vr, `weld`, `_weld`);
        }
    },
    wire: function(vr) {
        if (this.hasVariant(vr) && this.implementation.show(vr)) {
            this.ensure(vr, `wire`, `_wire`);
        }
    },
    work: function(vr) { // work (changed) state to current material
        if (this.hasVariant(vr) && this.implementation.show(vr)) { // show/hide depending on the specific condition
            this.ensure(vr, `work`, `_work`);
        }
        else {
            this._visibility(vr, false);
        }
    },
};

module.exports = Component;

/* TOP LEVEL: PAGE
 * This is the page function. 
 * It creates a ViewState function, which contains the current state.
 * The state is created on the basis of request variables, and from then it
 * reflects the user actions.
 * The page specifies all components and initializes them.
 * A component is specfied by the following fields
 * - destination: left => left sidebar; right => right sidebar; middle => middle column
 * - name: a string that can be used to refer to the component later on, via method getComponent
 * - subcomponents: a list of names for which a subcomponent will be made. The html will be generated per subcomponent.
 * - fetch: boolean which says whether this component needs data from the server
 * - work first: boolean which says that child components can only be wired after work of the parent component.
 * - specific: an object that holds the specific functionality of this component.
 * The control component has work first = true, because only after choosing a list, the list control can fetch the specific list and wire itself.
 * All other components have work first = false, because it is desirable that child components start wiring as soon as possible.
 * For example: the facet component is parent of the individual facets.
 * When facet starts working, the individual controls should already be wired.
 * Because work first = false, wiring of the individual facets will be triggered after wiring of the generic facet component.
 * N.B. Individual facets can only be wired after the list component (their grandfather) has been wired.
 * This will go OK, because after wiring the list, the facet will be wired and then the individual facets.
 * The _routing dictionary specifies when the work methods of components should be triggered.
 * Its keys are the labels of components, and for every component a list of other component keys is given.
 * These are the components that will be applied (in that order) after the key component. 
 * 
 *  work from page: if true, this component's work method will be called directly by the page's work method;
 *   if false, the page will skip this component when working. It is assumed that this component will be applied by another component.
 *   This practice must be followed, if the application of state to a component should come after a fetch of another component.
 *   If the page would work the viewstate directly to this component, it would happen before the other's components data had been loaded.
 *   Example: a filter component F, that filters a big list fetched by another component L. L's work should call F's work.
 * After every user action, the state is changed, and a call to the Page's work() method is issued.
 * The page will issue the work call forth to all components.
 */

var g = require('./generic.js');
var ViewState = require('./viewstate.js');
var Msg = require('./message.js');
var Share = require('./share.js');
var CType = require('./ctype.js');
var TadirahO = require('./tadiraho.js');
var TadirahA = require('./tadiraha.js');
var TadirahT = require('./tadiraht.js');
var EUmap = require('./eumap.js');
var Filter = require('./filter.js');
var Facet = require('./facet.js');
var List = require('./list.js');
var Item = require('./item.js');
var Control = require('./control.js');
var Component = require('./components.js');

function Page() { // the one and only page object
    this.name = `page`;
    this.msg = new Msg(`msg_${this.name}`);
    this.state = new ViewState(this);
    this.stages = {weld: true, wire: true, work: false}; // true means: once only, false means: my be repeated
    this.stages_prev = {wire: `weld`, work: `wire`};
    var main_lists = this.state.getValues(`list`);
    var contrib_list = {contrib: 1};
    var empty_list = {'': 1};
    this._component_specs = {
        share: {dest: `body`, variants: empty_list, fetch_url: null, specific: Share}, 
        control: {dest: `left`, variants: main_lists, fetch_url: null, specific: Control}, 
        list: {dest: `middle`, variants: main_lists, fetch_url: `list`, specific: List}, 
        item: {dest: `list`, variants: main_lists, fetch_url: `item`, specific: Item}, 
        facet: {dest: `control`, variants: main_lists, fetch_url: null, specific: Facet}, 
        filter: {dest: `facet`, variants: main_lists, fetch_url: null, specific: Filter}, 
        eumap: {dest: `facet`, variants: contrib_list, fetch_url: `country`, specific: EUmap}, 
        ctype: {dest: `facet`, variants: contrib_list, fetch_url: `type`, specific: CType}, 
        tadiraha: {dest: `facet`, variants: contrib_list, fetch_url: `tadiraha`, specific: TadirahA}, 
        tadiraho: {dest: `facet`, variants: contrib_list, fetch_url: `tadiraho`, specific: TadirahO}, 
        tadiraht: {dest: `facet`, variants: contrib_list, fetch_url: `tadiraht`, specific: TadirahT}, 
    },
    /* some components are being dealt with on the basis of additional identifiers, such as item
     * Those components are specified below, and the specs of all components will get an extra attribute
     * by_id, which is true if the component needs an id.
     * The actual ids come from a request variable name_xxx, where name is the name of the component and xxx is the name of a list.
     */
    this._by_id = {
        item: true,
    },
    this._before = {
        weld: {
            item: {list: 1},
            facet: {control: 1, list: 1},
            filter: {facet: 1},
            eumap: {facet: 1, filter: 1},
            ctype: {facet: 1, eumap: 1},
            tadiraha: {facet: 1, ctype: 1},
            tadiraho: {facet: 1, tadiraha: 1},
            tadiraht: {facet: 1, tadiraho: 1},
            share: {facet: 1, list: 1},
        },
        wire: {
            item: {list: 1},
            facet: {filter: 1, eumap: 1, ctype: 1, tadiraha: 1, tadiraho: 1, tadiraht: 1},
            filter: {list: 1},
            eumap: {list: 1},
            ctype: {list: 1},
            tadiraha: {list: 1},
            tadiraho: {list: 1},
            tadiraht: {list: 1},
        },
        work: {
            facet: {filter: 1, eumap: 1, ctype: 1, tadiraha: 1, tadiraho: 1, tadiraht: 1},
        },
    };
    this._ignore = {
        //tadiraht: 1,
        //tadiraho: 1,
        //eumap: 1,
        //filter: 1,
    },
    this.components = {};
    for (var name in this._component_specs) {
        if (name in this._ignore) {continue}
        this._component_specs[name].by_id = (name in this._by_id) && this._by_id[name];
        var component = new Component(name, this._component_specs[name], this);
        component.children = {};
        this.components[name] = component;
    }
    for (var name in this.components) {
        var child_component = this.components[name];
        var dest_name = this._component_specs[name].dest;
        if (dest_name in this.components) {
            var parent_component = this.components[dest_name];
            parent_component.children[name] = child_component;
        }
    }
    this._resolveTiming();
    this._setHeight(80);
    History.Adapter.bind(window, `statechange`, this.state.work());
};

Page.prototype = {
    _setHeight(subtract) { // the heights of the sidebars are set, depending on the height of the window
        var wh = `${window.innerHeight - subtract}px`;
        for (var w in {'middle': 1, 'left': 1, 'right': 1}) {
            $(`#${w}`).css(`height`, wh);
        }
    },
    _resolveTiming() {
        /* the time constraints must form a directed acyclic graph.
         * If that is the case, we need a linear order in which we can make the promises
         * This function will calculate that order (of course, several orders are possible)
         * Algorithm:
         *
         * A: make a graph of all tasks, a task is the combination of a component with a stage.
         *
         * B: compute sets of nodes that have a longest predecessor path of fixed length n
         *
         * 1. determine all tasks without predecessors, this is S0                                                (max length of predecessor chain = 0)
         * 2. determine all tasks with all predecessors in S0, this is S1                                             (max length of predecessor chain = 1)
         * 3. determine all tasks with: all predecessors in S0 or S1, at least one predecessor in S1, this is S2  (max length of predecessor chain = 2)
         * ...
         * n+1. determine all tasks with: all predecessors in S0, S1, ..., Sn, at least ione predecessor in Sn
         *
         * C: 
         * Prove theorem 1: Sn = {all nodes with longest chain of predecessors has length n}.
         * Prove theorem 2: all nodes outside union of all Sn: they are part of a cycle.
         *
         * D: 
         * The required order is: first the nodes of S0 (in any order), then those of S1, then those of S2, and so on.
         */
        var timing_nodes = [];
        var timing_edges = {}; // keys are nodes that must come before other nodes
        var timing_edges_inv = {}; // keys are nodes that must come after other nodes
        // A: collect the nodes: pairs of component name and stage
        for (var name in this.components) {
            for (var stage in this.stages) {
                timing_nodes.push(`${name}-${stage}`);
            }
        }
        // collect the edges (we need to store every edge both ways)
        function addEdge(prev_node, next_node) {
            if (!(prev_node in timing_edges)) {
                timing_edges[prev_node] = {};
            }
            if (!(next_node in timing_edges_inv)) {
                timing_edges_inv[next_node] = {};
            }
            timing_edges[prev_node][next_node] = true;
            timing_edges_inv[next_node][prev_node] = true;
        }
        // 1. per component, the stages are ordered
        for (var next_stage in this.stages_prev) {
            var prev_stage = this.stages_prev[next_stage];
            for (var name in this.components) {
                addEdge(`${name}-${prev_stage}`, `${name}-${next_stage}`);
            }
        }
        // 2. add the specific constraints from this._before
        for (var stage in this._before) {
            for (var next_name in this._before[stage]) {
                if (next_name in this._ignore) {continue}
                for (var prev_name in this._before[stage][next_name]) {
                    if (prev_name in this._ignore) {continue}
                    addEdge(`${prev_name}-${stage}`, `${next_name}-${stage}`);
                }
            }
        }
        // B: compute the Sn (in subset)
        var n = 0;
        var subset = [];
        var visited = {}; // collect all nodes that end up in an Sn
        while (n <= timing_nodes.length) {
            subset.push({});
            if (n == 0) {                                                // first round
                timing_nodes.forEach(function(node) {                   // select all nodes without prev_nodes
                    if (!(node in timing_edges_inv)) {
                        subset[n][node] = 1;                          // and store them in subset[0]              
                    }
                });
            }
            else {
                for (var prev_node in visited) {                          // start with prev_nodes in visited
                    if (prev_node in timing_edges) {                      // and consider their next_nodes
                        for (var next_node in timing_edges[prev_node]) {
                            if (!(next_node in visited)) {                // but only if the next_node is not yet visited
                                var good = true;
                                for (var other_prev_node in timing_edges_inv[next_node]) { // consider the other prev nodes of the next nodes
                                    if (!(other_prev_node in visited)) { // and require that they have been visited already
                                        good = false;
                                        break;
                                    }
                                } 
                                if (good) {
                                    subset[n][next_node] = 1;           // if all is well, we add next_node to subset[n]
                                }
                            }
                        }
                    }
                }
            }
            if (!Object.keys(subset[n]).length) {                       // if there are no new nodes, the next rounds will also not yield new nodes,
                break;                                                    //  so we are done
            }
            for (var node in subset[n]) {                              // after each round we add the saved next_nodes to the visited nodes
                visited[node] = 1;
            }
            n++;
        }
        this._tasks = [];
        this._timing = {};
        if (Object.keys(visited).length != timing_nodes.length) {
            var cycle = [];
            timing_nodes.forEach(function(node) {
                if (!(node in visited)) {
                    cycle.push(node);
                }
            });
            console.log(`Circular timing constraints detected`, cycle);
        }
        else {
            subset.forEach(function(nodes, n) {
                for (var node in nodes) {
                    this._tasks.push(node);
                }
            }, this);
            this._timing = timing_edges_inv;
            console.log(`Timing resolved`, this._tasks);
        }
    },
    getComponent: function(name) {
        return this.components[name];
    },
    getContainer: function(name, variants) {
        var container = {};
        if (name in this.components) {
            container = this.components[name].container;
        }
        else {
            var addto = (name == `body`)?$(`body`):$(`#${name}`);
            for (var vr in variants) {
                container[vr] = addto;
            }
        }
        return container;
    },
    getBefore: function(name, stage) {
        var prev_nodes = [];
        var next_node = `${name}-${stage}`;
        for (var prev_node in (this._timing[next_node] || {})) {
            prev_nodes.push(prev_node.split(`-`));
        }
        return prev_nodes;
    },
    work: function() { 
        this._tasks.forEach(function(task) {
            var task_comps = task.split(`-`);
            var name = task_comps[0];
            var stage = task_comps[1];
            var component = this.getComponent(name);
            for (var vr in component.variants) {
                component[stage](vr);
            }
        }, this);
    },
};

module.exports = Page;

/* START PROCESSING
 * The dynamic construction of the page starts here
 */

var Page = require('./page.js');

$(function() {new Page().work()});
