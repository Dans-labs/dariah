{"version":3,"file":"app.js","sources":["webpack:///src/js/app/dux/alter.js","webpack:///src/js/app/dux/docs.js","webpack:///src/js/app/dux/filters.js","webpack:///src/js/app/dux/grid.js","webpack:///src/js/app/dux/me.js","webpack:///src/js/app/dux/notify.js","webpack:///src/js/app/dux/roots.js","webpack:///src/js/app/dux/select.js","webpack:///src/js/app/dux/tables.js","webpack:///src/js/app/dux/win.js","webpack:///src/js/app/main.jsx","webpack:///src/js/app/object/CheckboxI.jsx","webpack:///src/js/app/object/DocMd.jsx","webpack:///src/js/app/object/EUMap.jsx","webpack:///src/js/app/object/ItemContainer.jsx","webpack:///src/js/app/object/ListContainer.jsx","webpack:///src/js/app/object/ListFilter.jsx","webpack:///src/js/app/object/ListPlain.jsx","webpack:///src/js/app/object/Login.jsx","webpack:///src/js/app/object/Notification.jsx","webpack:///src/js/app/object/Window.jsx","webpack:///src/js/app/pure/Doc.jsx","webpack:///src/js/app/pure/DocHtml.jsx","webpack:///src/js/app/pure/DocPdf.jsx","webpack:///src/js/app/pure/Input.jsx","webpack:///src/js/app/pure/InputMulti.jsx","webpack:///src/js/app/pure/MarkdownArea.jsx","webpack:///src/js/app/pure/NavLink.jsx","webpack:///src/js/app/pure/NotFound.jsx","webpack:///src/js/app/pure/Root.jsx","webpack:///src/js/app/pure/Stat.jsx","webpack:///src/js/app/pure/Static.jsx","webpack:///src/js/app/state/App.jsx","webpack:///src/js/app/state/Backoffice.jsx","webpack:///src/js/app/state/ByValue.jsx","webpack:///src/js/app/state/Facet.jsx","webpack:///src/js/app/state/FieldEdit.jsx","webpack:///src/js/app/state/FieldRead.jsx","webpack:///src/js/app/state/Filter.jsx","webpack:///src/js/app/state/Fulltext.jsx","webpack:///src/js/app/state/ItemDetailHeads.jsx","webpack:///src/js/app/state/ItemDetails.jsx","webpack:///src/js/app/state/ItemForm.jsx","webpack:///src/js/app/state/ItemRow.jsx","webpack:///src/js/app/state/ListGrid.jsx","webpack:///src/js/app/state/Pane.jsx","webpack:///src/js/app/state/RelSelect.jsx","webpack:///src/js/app/state/SubApp.jsx"],"sourcesContent":["import merge from 'lodash/merge'\nimport { makeReducer, memoize, handle } from 'utils'\n\n/* ACTIONS */\n\nexport const nextAlt = (tag, nAlts, initial) => ({ type: 'nextAlt', tag, nAlts, initial })\nexport const setAlt = (tag, alt) => ({ type: 'setAlt', tag, alt })\n\n/* REDUCER */\n\nconst flows = {\n  nextAlt(state, { tag, initial, nAlts }) {\n    const { [tag]: oldAlt = (initial || 0) } = state\n    const newAlt = (oldAlt + 1) % nAlts\n    return merge({}, state, { [tag]: newAlt })\n  },\n  setAlt(state, { tag, alt }) {\n    return merge({}, state, { [tag]: alt })\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getAlt = ({ alter }, { tag, initial }) => {\n  const { [tag]: alt = initial || 0 } = alter\n  return { alt }\n}\n\nexport const getAlts = ({alter }) => ({ alter })\n\n/* HELPERS */\n\nexport const makeAlt = ({ alter, dispatch }, { tag, initial, nAlts }) => {\n  const { [tag]: alt = initial } = alter\n  return ({\n    alt,\n    nextAlt: handle(dispatch, nextAlt, tag, nAlts, initial),\n    initAlt: handle(dispatch, setAlt, tag, initial),\n    setAlt: memoize(alt => handle(dispatch, setAlt, tag, alt)),\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/alter.js","import merge from 'lodash/merge'\n\nimport { accessData } from 'server'\nimport { propsChanged, makeReducer } from 'utils'\n\n/* ACTIONS */\n/*\n * Most actions call accessData, which will dispatch the ultimate fetch action.\n */\n\nexport const fetchDoc = props => {\n  const { docDir, docName, docExt } = props\n  const path = `${docDir}/${docName}.${docExt}`\n  return accessData({ type: 'fetchDoc', contentType: 'json', path, desc: `document ${docName}` })\n}\n\n/* REDUCER */\n\nconst flows = {\n  fetchDoc(state, { path, data }) {\n    if (data == null) {return state}\n    return merge({}, state, { [path]: data })\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getDoc = ({ docs }, { docDir, docName, docExt }) => ({\n  text: docs[`${docDir}/${docName}.${docExt}`],\n})\n\n/* HELPERS */\n\nexport const needDoc = props => (props.text == null)\n\nexport const changedDoc = (newProps, oldProps) => (\n  propsChanged(newProps, needDoc, oldProps, ['docDir', 'docName', 'docExt'])\n)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/docs.js","import merge from 'lodash/merge'\nimport { createSelectorCreator, defaultMemoize } from 'reselect'\nimport createCachedSelector from 're-reselect'\n\nimport { makeReducer, levelOneEq, emptyO } from 'utils'\nimport { repRelated } from 'tables'\n\n/* ACTIONS */\n\nexport const changeFulltext = (table, filterId, searchString) => ({ type: 'fulltext', table, filterId, data: searchString })\nexport const changeFacet = (table, filterId, valueId, onOff) => ({ type: 'facet', table, filterId, data: [valueId, onOff] })\nexport const changeFacetAll = (table, filterId, onOff) => ({ type: 'facetAll', table, filterId, data: onOff })\n\nexport const setupFiltering = (tables, table) => dispatch => {\n  const filterSettings = getFiltersInitialized({ tables }, { table })\n  dispatch({ type: 'setupFiltering', table, filterSettings })\n}\n\n/* REDUCER */\n\nconst flows = {\n  setupFiltering(state, { table, filterSettings }) {\n    return merge({}, state, { [table]: { filterSettings, initialized: true } })\n  },\n  fulltext(state, { table, filterId, data }) {\n    return merge({}, state, { [table]: { filterSettings: { [filterId]: data } } })\n  },\n  facetAll(state, { table, filterId, data }) {\n    const { [table]: { filterSettings: { [filterId]: facets } } } = state\n    const sameSettings = {}\n    Object.keys(facets).forEach(valueId => {sameSettings[valueId] = data})\n    return merge({}, state, { [table]: { filterSettings: { [filterId]: sameSettings } } })\n  },\n  facet(state, { table, filterId, data }) {\n    const [valueId, filterSetting] = data\n    return merge({}, state, { [table]: { filterSettings: { [filterId]: { [valueId]: filterSetting } } } })\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\n/* selector creator */\n\nconst createLevelOneSelector = createSelectorCreator(\n  defaultMemoize,\n  levelOneEq,\n)\n\n/* basic selectors */\n\nconst getFilterData = ({ tables }, { table }) => {\n  const { [table]: { valueLists, fields, filterList, fieldSpecs } } = tables\n  const selection = { valueLists, fields, filterList, fieldSpecs }\n  for (const field of Object.keys(valueLists)) {\n    const { [field]: { valType: { values: relTable } } } = fieldSpecs\n    const { [relTable]: relTableData } = tables\n    selection[relTable] = relTableData\n  }\n  return selection\n}\n\n/* selector computers */\n\nconst compileFiltering = ({ valueLists, fields, filterList, fieldSpecs, ...relTables }) => {\n  const presentFilterList = filterList.filter(x => fields[x.field])\n  const filterFields = presentFilterList.filter(x => x.type !== 'Fulltext').map(x => x.field)\n  const fieldValues = {}\n  for (const field of filterFields) {\n    const { [field]: { valType } } = fieldSpecs\n    const { [field]: vals } = valueLists\n    const fFieldValues = {'': '-none-'}\n    if (typeof valType == 'string') {\n      vals.forEach((v, i) => {fFieldValues[i] = v})\n    }\n    else {\n      const { values: relTable } = valType\n      vals.forEach(v => {\n        fFieldValues[v] = repRelated(relTables, relTable, v)\n      })\n    }\n    fieldValues[field] = fFieldValues\n  }\n  return fieldValues\n}\n\nconst initFiltering = ({ fields, filterList }, fieldValues) => {\n  const presentFilterList = filterList.filter(x => fields[x.field])\n  const filterSettings = {}\n  presentFilterList.forEach((filterSpec, filterId) => {\n    if (filterSpec.type == 'Fulltext') {\n      filterSettings[filterId] = ''\n    }\n    else {\n      const facets = {}\n      Object.keys(fieldValues[filterSpec.field]).forEach(valueId => {facets[valueId] = true})\n      filterSettings[filterId] = facets\n    }\n  })\n  return filterSettings\n}\n\nconst computeFiltering = (tables, table, fieldValues, filterSettings) => {\n  const { [table]: { entities, allIds, fields, fieldSpecs, filterList } } = tables\n  const presentFilterList = filterList.filter(x => fields[x.field])\n  const filterChecks = {}\n  const otherFilteredIds = {}\n\n  const makeFilterCheck = (filterSpec, filterId) => {\n    const { field } = filterSpec\n    const { [filterId]: filterSetting } = filterSettings\n    const { [field]: fieldSpec } = fieldSpecs\n    return (\n      filterSpec.type === 'Fulltext' ?\n          fulltextCheck :\n          facetCheck\n      )(tables, field, fieldSpec, filterSetting)\n  }\n\n  presentFilterList.forEach((filterSpec, filterId) => {\n    filterChecks[filterId] = makeFilterCheck(filterSpec, filterId)\n    otherFilteredIds[filterId] = []\n  })\n  const filteredIds = []\n\n  for (const eId of allIds) {\n    const { [eId]: entity } = entities\n    let theOneFail = null\n    let v = true\n    let discard = false\n    Object.entries(filterChecks).forEach(([filterId, filterCheck]) => {\n      if (!discard) {\n        const pass = filterCheck(entity)\n        if (!pass) {\n          v = false\n          if (theOneFail === null) {theOneFail = filterId}\n          else {discard = true}\n        }\n      }\n    })\n    if (!discard) {\n      const { values: { _id } } = entity\n      if (v) {\n        filteredIds.push(_id)\n        presentFilterList.forEach((filterSpec, filterId) => {\n          otherFilteredIds[filterId].push(_id)\n        })\n      }\n      else {otherFilteredIds[theOneFail].push(_id)}\n    }\n  }\n  const amounts = {}\n  presentFilterList.forEach(({ field, type }, filterId) => {\n    const { [field]: fieldSpec } = fieldSpecs\n    amounts[filterId] = type === 'Fulltext' ? null : countFacets(\n      tables, field, fieldSpec, fieldValues[field], otherFilteredIds[filterId], entities\n    )\n  })\n  const filteredAmountOthers = {}\n  Object.entries(otherFilteredIds).forEach(([filterId, x]) => {\n    filteredAmountOthers[filterId] = x.length\n  })\n  return {\n    filteredIds,\n    filteredAmountOthers,\n    amounts,\n  }\n}\n\n/* selectors for export */\n\nconst getFiltersCompiled = createLevelOneSelector(\n  getFilterData,\n  compileFiltering,\n)\n\nexport const getFieldValues = ({ tables }, { table, filterField }) => ({\n  fieldValues: getFiltersCompiled({ tables }, { table })[filterField],\n})\n\nconst getFiltersInitialized = createLevelOneSelector(\n  getFilterData,\n  getFiltersCompiled,\n  initFiltering,\n)\n\nexport const getFilterSetting = ({ filters }, { table, filterId }) => ({\n  filterSetting: filters[table].filterSettings[filterId],\n})\n\nconst getFiltersAppliedBase = ({ tables, filters, table }) => {\n  const { [table]: filterStatus = { filterSettings: emptyO, initialized: false } } = filters\n  const { filterSettings, initialized } = filterStatus\n  const fieldValues = getFiltersCompiled({ tables }, { table })\n  const result = initialized ?\n    ({\n      tables,\n      initialized,\n      fieldValues,\n      filterSettings,\n      ...computeFiltering(tables, table, fieldValues, filterSettings),\n    }) :\n    ({\n      tables,\n      initialized,\n      fieldValues,\n    })\n  return result\n}\n\nconst getFilterArgs = ({ tables, filters }, { table }) => ({ tables, table, filters })\n\nexport const getFiltersApplied = createCachedSelector(\n  getFilterArgs,\n  getFiltersAppliedBase,\n)(({ tables, filters }, { table }) => table)\n\n/* HELPERS */\n\nconst getUnpack = (tables, fieldSpec, asString = false) => {\n  const { valType, multiple } = fieldSpec\n  let unpack\n  if (typeof valType == 'string') {\n    unpack = multiple ? (\n      asString ? (\n        v => v == null ? '' : v.join(' ')\n      ) : (\n        v => v == null ? [] : v\n      )\n    ) : (\n      asString ? (\n        v => v == null ? '' : v\n      ) : (\n        v => v == null ? [] : [v]\n      )\n    )\n  }\n  else {\n    const { values: relTable } = valType\n    unpack = multiple ? (\n      asString ? (\n        v => v == null ? '' : v.map(v => repRelated(tables, relTable, v).join(' '))\n      ) : (\n        v => v == null ? [] : v\n      )\n    ) : (\n      asString ? (\n        v => v == null ? '' : repRelated(tables, relTable, v)\n      ) : (\n        v => v == null ? [] : [v]\n      )\n    )\n  }\n  return unpack\n}\n\nconst fulltextCheck = (tables, field, fieldSpec, term) => {\n  const unpack = getUnpack(tables, fieldSpec, true)\n  const search = term.toLowerCase()\n  if (search == null || search == '') {\n    return () => true\n  }\n  return entity => {\n    const { values: { [field]: val } } = entity\n    const rep = unpack(val)\n    return rep != null && rep.toLowerCase().indexOf(search) !== -1\n  }\n}\n\nconst facetCheck = (tables, field, fieldSpec, facetSettings) => {\n  const unpack = getUnpack(tables, fieldSpec)\n  if (facetSettings.size === 0) {\n    return () => false\n  }\n  return entity => {\n    const { values: { [field]: val } } = entity\n    const rep = unpack(val)\n    if (rep.length == 0) {\n      return facetSettings['']\n    }\n    for (const r of rep) {\n      if (facetSettings[r]) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nconst countFacets = (tables, field, fieldSpec, fieldValues, filteredIds, entities) => {\n  const unpack = getUnpack(tables, fieldSpec)\n  const facetAmounts = {}\n  Object.keys(fieldValues).forEach(r => {facetAmounts[r] = 0})\n  for (const eId of filteredIds) {\n    const { [eId]: { values: { [field]: val } } } = entities\n    const rep = unpack(val)\n    if (rep.length == 0) {\n      facetAmounts[''] += 1\n    }\n    else {\n      for (const r of rep) {\n        facetAmounts[r] += 1\n      }\n    }\n  }\n  return facetAmounts\n}\n\nconst INTL = new Intl.Collator('en', { sensitivity: 'base' })\nconst sortEntries = (x, y) => INTL.compare(x[1], y[1])\n\nexport const placeFacets = (fieldValues, maxCols) => {\n  if (fieldValues == null) {return []}\n  const facets = Object.entries(fieldValues).sort(sortEntries)\n  if (facets.length == 0) {return []}\n  const rows = []\n  const { length: lf } = facets\n  const nrows = Math.floor(lf / maxCols) + (lf % maxCols ? 1 : 0)\n  const ncols = Math.floor(lf / nrows) + (lf % nrows ? 1 : 0)\n  for (let r = 0; r < nrows; r++) {\n    const row = []\n    for (let c = 0; c < ncols; c++) {\n      const f = nrows * c + r\n      row.push(f < lf ? facets[f] : null)\n    }\n    rows.push(row)\n  }\n  return rows\n}\n\nexport const testAllChecks = filterSettings => {\n  let allTrue = true\n  let allFalse = true\n  for (const valueEntry of Object.entries(filterSettings)) {\n    if (valueEntry[1]) {allFalse = false}\n    else {allTrue = false}\n  }\n  return { allTrue, allFalse }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/filters.js","import orderBy from 'lodash/orderby'\nimport mapValues from 'lodash/mapvalues'\nimport createCachedSelector from 're-reselect'\nimport { makeReducer, emptyA, emptyO } from 'utils'\n\nimport { getTables, repr } from 'tables'\n\n/* ACTIONS */\n\nexport const resetSort = tag => ({ type: 'resetSort', tag })\nexport const addColumn = (tag, column, direction) => ({ type: 'addColumn', tag, column, direction })\nexport const turnColumn = (tag, column) => ({ type: 'turnColumn', tag, column })\nexport const delColumn = (tag, column) => ({ type: 'delColumn', tag, column })\n\n/* REDUCER */\n\nconst flows = {\n  resetSort(state, { tag }) {\n    return { ...state, [tag]: emptyA }\n  },\n  addColumn(state, { tag, column, direction }) {\n    const { [tag]: sortSpec } = state\n    return { ...state, [tag]: (sortSpec || emptyA).filter(x => x[0] != column).concat([[column, direction]]) }\n  },\n  delColumn(state, { tag, column }) {\n    const { [tag]: sortSpec } = state\n    return { ...state, [tag]: (sortSpec || emptyA).filter(x => x[0] != column) }\n  },\n  turnColumn(state, { tag, column }) {\n    const { [tag]: sortSpec } = state\n    return { ...state, [tag]: (sortSpec || emptyA).map(x => [x[0], x[0] == column ? -x[1] : x[1]]) }\n  },\n}\n\nexport default makeReducer(flows, emptyO)\n\n/* SELECTORS */\n\n/* selector computers */\n\nconst reprX = (tables, table) => {\n  const { [table]: { fieldSpecs } } = tables\n  return (myValues, field) => {\n    if (field == '_id') {return myValues}\n    const { [field]: { valType, multiple } } = fieldSpecs\n    return multiple ?\n      (myValues || emptyA).map(value => repr(tables, table, valType, value)).join('|') :\n      repr(tables, table, valType, myValues)\n  }\n}\n\nconst sortData = ({ tables }, { table, listIds, sortSpec }) => {\n  const sortColumns = sortSpec.map(x => x[0])\n  const sortDirs = sortSpec.map(x => x[1] == 1 ? 'asc' : 'desc')\n  const { [table]: { entities } } = tables\n  const r = reprX(tables, table)\n  const fullData = listIds.map(_id => mapValues(entities[_id].values, r))\n  return { sortedData: orderBy(fullData, sortColumns, sortDirs).map(x => x._id) }\n}\n\n/* selectors for export */\n\nexport const getSort = ({ grid }, { table, tag, listIds }) => ({ table, tag, listIds, sortSpec: grid[tag] || emptyA })\n\nexport const getSortedData = createCachedSelector(\n  getTables,\n  getSort,\n  sortData,\n)((state, { tag }) => tag)\n\n/* HELPERS */\n\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/grid.js","import { accessData } from 'server'\nimport { makeReducer, emptyO } from 'utils'\n\n/* ACTIONS */\n/*\n * Most actions call accessData, which will dispatch the ultimate fetch action.\n */\nexport const fetchMe = () => (\n  accessData({ type: 'fetchMe', contentType: 'db', path: '/who/ami', desc: 'me' })\n)\n\n/* REDUCER */\n\nconst flows = {\n  fetchMe(state, { data }) {\n    if (data == null) {return emptyO}\n    return { ...data }\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getMe = ({ me }) => ({ me })\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/me.js","import mergeWith from 'lodash/mergewith'\nimport { makeReducer, emptyA } from 'utils'\n\n/* ACTIONS */\n\nexport const notify = msgs => ({ type: 'msgs', msgs })\nexport const clear = () => ({ type: 'clear' })\nexport const display = onOff => ({ type: 'display', onOff })\n\n/* REDUCER */\n\nconst subFlows = {\n  pending(state, { desc, busy, extraMsgs }) {\n    return mergeWith({}, state, {\n      items: [\n        ...extraMsgs,\n        { kind: 'special', text: `waiting for ${desc}`},\n      ],\n      busy: busy + 1,\n    }, addItems)\n  },\n  success(state, { desc, busy, extraMsgs }) {\n    return mergeWith({}, state, {\n      items: [\n        ...extraMsgs,\n        { kind: 'info', text: `${desc} ok` },\n      ],\n      busy: busy - 1,\n    }, addItems)\n  },\n  error(state, { desc, busy, extraMsgs }) {\n    return mergeWith({}, state, {\n      items: [\n        ...extraMsgs,\n        { kind: 'error', text: `${desc} failed` },\n      ],\n      busy: busy - 1,\n      show: true,\n    }, addItems)\n  },\n}\n\nconst flows = {\n  async(state, { msgs, status, desc }) {\n    const { busy } = state\n    const extraMsgs = msgs || emptyA\n    const { [status]: subFlow } = subFlows\n    return subFlow ? subFlow(state, { extraMsgs, desc, busy }) : state\n  },\n  msgs(state, { msgs }) {\n    return mergeWith({}, state, {\n      items: [\n        ...msgs,\n      ],\n      show: true,\n    }, addItems)\n  },\n  clear(state) {\n    return {\n      ...state,\n      items: emptyA,\n      show: false,\n    }\n  },\n  display(state, { onOff }) {\n    return {\n      ...state,\n      show: onOff,\n    }\n  },\n}\n\nexport default makeReducer(flows, { items: emptyA, busy: 0, show: false })\n\n/* SELECTORS */\n\nexport const getNotifications = ({ notify }) => {\n  const { items, busy, show } = notify\n  let lastNote = -1\n  let lastKind = ''\n  items.forEach((item, i) => {\n    const { kind } = item\n    if (kind == 'error') {\n      lastNote = i\n      lastKind = 'error'\n    }\n    else if (kind == 'warning') {\n      if (lastKind != 'error') {\n        lastNote = i\n        lastKind = 'warning'\n      }\n    }\n  })\n  return { notifications: items, busy, show, lastMsg: items.length - 1, lastNote, lastKind }\n}\n\n/* HELPERS */\n\nconst addItems = (objValue, srcValue, key) => {\n  if (key == 'items') {\n    return objValue == null ? srcValue : objValue.concat(srcValue)\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/notify.js","import { combineReducers, createStore, applyMiddleware } from 'redux'\nimport thunkMiddleware from 'redux-thunk'\nimport { reducer as form } from 'redux-form'\n\nimport win from 'win'\nimport notify from 'notify'\nimport docs from 'docs'\nimport tables from 'tables'\nimport me from 'me'\nimport filters from 'filters'\nimport alter from 'alter'\nimport select from 'select'\nimport grid from 'grid'\n\n/* ACTIONS */\n\n/* global process */\n/* global require */\n\n/* actions to ignore in logging and in the redux dev tool\n * Mainly used for actions generated by third party libraries, such as redux-form\n */\n\nconst predicate = (state, action) => !action.type.startsWith('@@redux-form')\n\n//const predicate = () => true // if you want to see all actions\n\nconst configureStore = reducer => {\n  let store\n  if (process.env.NODE_ENV === `development`) {\n    const { createLogger } = require(`redux-logger`)\n    const { composeWithDevTools } = require('redux-devtools-extension')\n    const composeEnhancers = composeWithDevTools({ predicate })\n    store = createStore(\n      reducer,\n      composeEnhancers(\n        applyMiddleware(\n          thunkMiddleware,\n          createLogger({ predicate }),\n        )\n      )\n    )\n  }\n  else {\n    store = createStore(\n      reducer,\n      applyMiddleware(\n        thunkMiddleware,\n      )\n    )\n  }\n  return store\n}\n\n/* REDUCER */\n\nexport default configureStore(combineReducers({\n  win,\n  notify,\n  docs,\n  tables,\n  me,\n  filters,\n  alter,\n  form,\n  select,\n  grid,\n}))\n\n/* SELECTORS */\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/roots.js","import merge from 'lodash/merge'\nimport { makeReducer, emptyO } from 'utils'\n\n/* ACTIONS */\n\nexport const setSearch = (tag, search) => ({ type: 'setSearch', tag, search })\nexport const setPopUp = (tag, onOff) => ({ type: 'setPopUp', tag, onOff })\nexport const togglePopUp = tag => ({ type: 'togglePopUp', tag })\n\n/* REDUCER */\n\nconst flows = {\n  setSearch(state, { tag, search }) {\n    const init = initSelect(state, tag)\n    return merge(init, state, { [tag]: { search } })\n  },\n  setPopUp(state, { tag, onOff }) {\n    const init = initSelect(state, tag)\n    return merge(init, state, { [tag]: { popUp: onOff } })\n  },\n  togglePopUp(state, { tag }) {\n    const init = initSelect(state, tag)\n    const { [tag]: myState } = state\n    const newOnOff = myState == null ? true : !myState.popUp\n    return merge(init, state, { [tag]: { popUp: newOnOff } })\n  },\n}\n\nexport default makeReducer(flows, emptyO)\n\n/* SELECTORS */\n\nexport const getSelect = ({ select }, { tag }) => ({ ...(select[tag] || emptyO) })\n\n/* HELPERS */\n\nconst initSelect = (state, tag) => {\n  const { [tag]: myState } = state\n  return myState == null ?\n    { [tag]: { search: '', popUp: false } } :\n    {}\n}\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/select.js","import mergeWith from 'lodash/mergewith'\nimport merge from 'lodash/merge'\nimport { createSelector } from 'reselect'\n\nimport { accessData } from 'server'\nimport { makeReducer, memoize, emptyA, emptyO } from 'utils'\n\n/* ACTIONS */\n/*\n * Most actions call accessData, which will dispatch the ultimate fetch action.\n */\n\nexport const fetchTable = (table, select = 'allIds', grid) => accessData({\n  type: 'fetchTable',\n  contentType: 'db',\n  path: `/${select == 'myIds' ? 'my' : ''}list?table=${table}&grid=${grid}`,\n  desc: `${table} table`,\n  table,\n})\n\nexport const fetchItem = (table, eId) => accessData({\n  type: 'fetchItem',\n  contentType: 'db',\n  path: `/view?table=${table}&id=${eId}`,\n  desc: `${table} record ${eId}`,\n  table,\n})\n\nexport const modItem = (table, eId, values) => accessData({\n  type: 'modItem',\n  contentType: 'db',\n  path: `/mod?table=${table}&action=update`,\n  desc: `${table} update record ${eId}`,\n  sendData: { _id: eId, values },\n  table,\n})\n\nexport const insertItem = (table, select = 'allIds', masterId = null, linkField = null) => accessData({\n  type: 'insertItem',\n  contentType: 'db',\n  path: `/mod?table=${table}&action=insert`,\n  desc: `${table} insert new record`,\n  sendData: { masterId, linkField },\n  table,\n  select,\n})\n\nexport const delItem = (table, eId) => accessData({\n  type: 'delItem',\n  contentType: 'db',\n  path: `/mod?table=${table}&action=delete`,\n  desc: `${table} delete record ${eId}`,\n  sendData: { _id: eId },\n  table,\n})\n\n/* REDUCER */\n\nconst flows = {\n  fetchTable(state, { data }) {\n    if (data == null) {return state}\n    return mergeWith({}, state, data, setComplete)\n  },\n  fetchItem(state, { data, table }) {\n    if (data == null) {return state}\n    const { fields, ...restData } = data\n    const { values, values: { _id } } = restData\n    const newState = merge({}, state, { [table]: { fields, entities: { [_id]: restData } } })\n    newState[table].entities[_id].values = values\n    return newState\n  },\n  modItem(state, { data, table }) {\n    if (data == null) {return state}\n    const { values: { _id }, newValues } = data\n    const newState = merge({}, state, { [table]: { entities: { [_id]: data } } })\n    newState[table].entities[_id].values = data.values\n\n    for (const { _id, rep, relTable, field } of newValues) {\n      newState[relTable].entities[_id] = { values: { _id, rep } }\n      newState[table].valueLists[field].unshift(_id)\n    }\n    return newState\n  },\n  insertItem(state, { data, table, select }) {\n    if (data == null) {return state}\n    const { fields, ...restData } = data\n    const { values: { _id } } = restData\n    return mergeWith({}, state, { [table]: { lastInserted: _id, fields, entities: { [_id]: data }, [select]: [_id] } }, addKey(select))\n  },\n  delItem(state, { data, table }) {\n    if (data == null) {return state}\n    const _id = data\n    const { [table]: { entities: { [_id]: del, ...otherEntities }, myIds, allIds } } = state\n    const otherMyIds = myIds == null ? null : myIds.filter(x => x != _id)\n    const otherAllIds = allIds == null ? null : allIds.filter(x => x != _id)\n    return {\n      ...state,\n      [table]: {\n        ...state[table],\n        entities: otherEntities,\n        allIds: otherAllIds,\n        myIds: otherMyIds,\n      },\n    }\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getTables = ({ tables }) => ({ tables })\n\nexport const getTableFilters = ({ tables }, { table }) => {\n  const { [table]: { fields, filterList } } = tables\n  return { fields, filterList }\n}\n\nexport const getValueList = ({ tables }, { table, field }) => {\n  const { [table]: { valueLists, fieldSpecs } } = tables\n  const { [field]: { valType } } = fieldSpecs\n  if (valueLists == null) {\n    return { valType, table }\n  }\n  const { [field]: valueList } = valueLists\n  return { valType, valueList, table }\n}\n\nconst computeOptions = ({ tables }, { valType, valueList, table }) => {\n  if (valueList == null) {\n    return { options: emptyA, optionLookup: emptyO }\n  }\n  const options = valueList.map(val => ({ value: val, label: repr(tables, table, valType, val) }))\n  const optionLookup = {}\n  options.forEach(({ value: val, label: lab }) => {optionLookup[val] = lab})\n  return { options, optionLookup }\n}\n\nexport const getOptions = createSelector(\n  getTables,\n  getValueList,\n  computeOptions,\n)\n\n/* HELPERS */\n\nexport const toDb = memoize((table, eId, mod) => values => mod(table, eId, values))\n\nconst setComplete = (newValue, oldValue, key) => {\n  if (key == 'complete') {return newValue || oldValue}\n}\n\nconst addKey = listKey => (objValue, srcValue, key) => {\n  if (key == listKey) {\n    return objValue == null ? srcValue : srcValue.concat(objValue)\n  }\n}\n\nconst hasTableKey = (tables, table, key, value = null) => {\n  if (tables == null) {return false}\n  return tables[table] != null && tables[table][key] != null && (value == null || tables[table][key] == value)\n}\n\nexport const needTables = (tables, table, select = 'allIds', complete) => {\n  if (!hasTableKey(tables, table, select)) {return true}\n  if (complete && !hasTableKey(tables, table, 'complete', true)) {return true}\n  const { [table]: { fieldSpecs } } = tables\n  const relTables = Array.from(\n    new Set(\n      Object.entries(fieldSpecs).\n      filter(entry => ((typeof entry[1].valType) == 'object') && entry[1].valType.values != null).\n      map(entry => entry[1].valType.values)\n    )\n  )\n  return relTables.some(relTable => !hasTableKey(tables, relTable, 'allIds'))\n}\n\nexport const needValues = ({ tables, table, eId }) => (\n  tables == null ||\n  tables[table] == null ||\n  tables[table].entities[eId] == null ||\n  tables[table].entities[eId].perm == null ||\n  !tables[table].entities[eId].complete\n)\n\nexport const listValues = ({ tables, table, eId, field }) => (\n  tables == null ? emptyA :\n  tables[table] == null ? emptyA :\n  tables[table].entities[eId] == null ? emptyA :\n  new Set(tables[table].entities[eId][field])\n)\n\nconst repUser = ({ user }, valId) => {\n  let valRep\n  const { entities: { [valId]: entity } } = user\n  if (entity) {\n    const { values: { eppn, firstName, lastName, emailPre, authority, mayLogin } } = entity\n    const email = emailPre || ''\n    let linkText = [firstName || '', lastName || ''].filter(x => x).join(' ')\n    if (linkText == '') {linkText = email}\n    const namePart = linkText && email ? (\n      `[${linkText}](mailto:${email})`\n    ) : (\n      linkText + email\n    )\n    const eppnPart = eppn ? ` eppn=${eppn} ` : ''\n    const authorityPart = authority ? ` authenticated by=${authority} ` : ''\n    const mayLoginPart = mayLogin ? ` active=${mayLogin} ` : ''\n    valRep = [namePart, eppnPart, authorityPart, mayLoginPart].filter(x => x).join('; ')\n  }\n  else {valRep = 'UNKNOWN'}\n  return valRep\n}\n\nconst repCountry = ({ country }, valId) => {\n  const { entities: { [valId]: entity } } = country\n  if (entity) {\n    const { values: { name, iso } } = entity\n    return `${iso}: ${name}`\n  }\n  else {return 'UNKNOWN'}\n}\n\nconst repValue = rel => (tables, valId) => {\n  const { [rel]: { title, entities: { [valId]: entity } } } = tables\n  const useTitle = title || 'rep'\n  if (entity) {\n    const { values: { [useTitle]: rep } } = entity\n    return rep\n  }\n  else {return 'UNKNOWN'}\n}\n\nconst repMap = {\n  user: repUser,\n  country: repCountry,\n  default: repValue,\n}\n\nexport const repRelated = (tables, rel, valId) => (repMap[rel] || repMap.default(rel))(tables, valId)\n\nconst trimDate = text => (text == null ? '' : text.replace(/\\.[0-9]+/, ''))\n\nexport const repr = (tables, table, valType, value) => {\n  if (value == null) {return ''}\n  if (typeof valType == 'string') {\n    switch (valType) {\n      case 'datetime': return trimDate(value)\n      case 'bool': return value ? 'Yes' : 'No'\n      default: return value\n    }\n  }\n  else {\n    const { values: rel } = valType\n    return repRelated(tables, rel, value)\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/tables.js","import { makeReducer } from 'utils'\n\n/* ACTIONS */\n\nexport const changeWinDim = () => dispatch => {\n  dispatch({ type: 'windim', ...initWinDim() })\n}\n\n/* REDUCER */\n\nconst flows = {\n  windim(state, { height, width }) {return { height, width }},\n}\n\nconst initWinDim = () => {\n  const { innerHeight: height, innerWidth: width } = window\n  return { height, width }\n}\n\nexport default makeReducer(flows, initWinDim())\n\n/* SELECTORS */\n\nexport const getWinDim = ({ win: { height, width } }) => ({ height, width })\n\n/* HELPERS */\n\nconst scrollBarWidth = 40\nconst leftMargin = 0\n\nconst topHeight = 50\nconst topMargin = 5\n\nconst divWidthSpec = {\n  left: 120,\n  rightLeft: 380,\n  rightLeftNav: 150,\n}\n\nconst floatSpec = {\n  left: 'left',\n  right: 'right',\n  rightLeft: 'left',\n  rightLeftNav: 'left',\n  rightRight: 'right',\n  rightRightBody: 'right',\n}\n\nexport function columnStyle(kind, { height, width }) {\n  const divHeight = {\n    left: height - topHeight,\n    right: height - topHeight,\n    rightLeft: height - topHeight - topMargin,\n    rightLeftNav: height - topHeight - topMargin,\n    rightRight: height - topHeight - topMargin,\n    rightRightBody: height - topHeight - topMargin,\n  }\n  const { left, rightLeft, rightLeftNav } = divWidthSpec\n  const divWidth = {\n    ...divWidthSpec,\n    right: width - left - scrollBarWidth,\n    rightRight: width - left - rightLeft - 2 * scrollBarWidth - leftMargin,\n    rightRightBody: width - left - rightLeftNav - 2 * scrollBarWidth - leftMargin,\n  }\n\n  return {\n    width: divWidth[kind],\n    height: divHeight[kind],\n    float: floatSpec[kind],\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/win.js","import React from 'react'\nimport { render } from 'react-dom'\nimport { Router, Route, Redirect, IndexRoute, IndexRedirect, browserHistory } from 'react-router'\n\nimport Root from 'Root'\nimport App from 'App'\nimport SubApp from 'SubApp'\nimport Backoffice from 'Backoffice'\nimport ListContainer from 'ListContainer'\nimport Doc from 'Doc'\nimport NotFound from 'NotFound'\n\nrender(\n  <Root>\n    <Router history={browserHistory}>\n      <Redirect from=\"/about\" to=\"/docs/about.md\" />\n      <Redirect from=\"/docs/about\" to=\"/docs/about.md\" />\n      <Redirect from=\"/about.md\" to=\"/docs/about.md\" />\n      <Redirect from=\"/login\" to=\"/docs/about.md\" />\n      <Redirect from=\"/logout\" to=\"/docs/about.md\" />\n      <Redirect from=\"/slogout\" to=\"/docs/about.md\" />\n      <Route path=\"/\" component={App} >\n        <IndexRoute component={App} />\n        <IndexRedirect to=\"/docs/about.md\" />\n        <Route path=\"docs/:docFile\" component={Doc} />\n        <Route path=\"tech/docs/gen/:docFile\" component={Doc} />\n        <Route path=\"tech/docs/:docFile\" component={Doc} />\n        <Route path=\"data\" >\n          <Route path=\":table\" component={SubApp} >\n            <Route path=\"list\" component={ListContainer} mode={'filter'} />\n            <Route path=\"mylist\" component={ListContainer} select={'myIds'} mode={'list'} />\n          </Route>\n        </Route>\n        <Route path=\"backoffice\" component={Backoffice} >\n          <Route path=\":table\" >\n            <Route path=\"grid\" component={ListContainer} select={'allIds'} mode={'grid'} />\n            <Route path=\"list\" component={ListContainer} select={'allIds'} mode={'list'} />\n          </Route>\n        </Route>\n      </Route>\n      <Route path=\"*\" component={NotFound} />\n    </Router>\n  </Root>\n  ,\n  document.getElementById('body')\n)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/main.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { changeFacetAll, getFilterSetting, testAllChecks } from 'filters'\n\nconst indeterminate = states => !states.allTrue && !states.allFalse\n\nclass CheckboxI extends Component {\n  componentDidUpdate() {\n    const { props: { filterSetting } } = this\n    const states = testAllChecks(filterSetting)\n    this.dom.indeterminate = indeterminate(states)\n  }\n  handleCheck = () => {\n    const { props: {filterSetting, table, filterId, handle } } = this\n    const states = testAllChecks(filterSetting)\n    return handle(table, filterId, this.dom.indeterminate || !states.allTrue)\n  }\n  setIndeterminate = domElem => {\n    const { props: { filterSetting } } = this\n    const states = testAllChecks(filterSetting)\n    if (domElem) {\n      this.dom = domElem\n      domElem.indeterminate = indeterminate(states)\n    }\n  }\n  render() {\n    const { props: { filterSetting } } = this\n    const states = testAllChecks(filterSetting)\n    return (\n      <input\n          ref={this.setIndeterminate}\n          type=\"checkbox\"\n          checked={states.allTrue}\n          onChange={this.handleCheck}\n      />\n    )\n  }\n}\n\nexport default connect(getFilterSetting, { handle: changeFacetAll })(CheckboxI)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/CheckboxI.jsx","import React, {Component} from 'react'\nimport { connect } from 'react-redux'\nimport Markdown from 'react-markdown'\nimport { Link } from 'react-router'\n\nimport { combineSelectors } from 'utils'\n\nimport { getDoc, needDoc, changedDoc, fetchDoc } from 'docs'\nimport { getAlts, makeAlt } from 'alter'\n\nconst RouterLink = ({ children, href }) => (\n  href.match(/^(https?:)?\\/\\//) ?\n    <a href={href} >{children}</a> :\n    <Link to={href} >{children}</Link>\n)\nconst renderers = { Link: RouterLink }\n\nclass DocMd extends Component {\n  render() {\n    const {props, props: { docName, text } } = this\n    if (needDoc({ text })) {return <div>{`No document ${docName}`}</div>}\n\n    const { alt, nextAlt } = makeAlt(props, {\n      tag: docName,\n      nAlts: 2,\n      initial: 0,\n    })\n    return (\n      <div style={{paddingLeft: '0.5em'}} >\n        <p style={{float: 'right'}} >\n          <a\n            href=\"#\"\n            className={`control fa fa-${alt == 0 ? 'hand-o-down' : 'file-code-o'}`}\n            title={`${alt == 0 ? 'markdown source' : 'formatted'}`}\n            onClick={nextAlt}\n          />\n        </p>\n        {\n          alt == 0 ?\n            <div>\n              <Markdown\n                source={text}\n                renderers={renderers}\n              />\n            </div> :\n            <div>\n              <pre className=\"md-source\" >{text}</pre>\n            </div>\n        }\n      </div>\n    )\n  }\n  componentDidMount() {\n    const { props, props: {dispatch } } = this\n    dispatch(fetchDoc(props))\n  }\n  componentDidUpdate(prevProps) {\n    const { props, props: {dispatch } } = this\n    if (changedDoc(props, prevProps)) {\n      dispatch(fetchDoc(props))\n    }\n  }\n}\n\nconst getInfo = combineSelectors(getDoc, getAlts)\n\nexport default connect(getInfo)(DocMd)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/DocMd.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport L from 'leaflet'\n\nimport {countryBorders} from 'europe.geo'\nimport { getFilterSetting } from 'filters'\nimport { getTables } from 'tables'\nimport { combineSelectors } from 'utils'\n\nimport ByValue from 'ByValue'\n\nconst mapOptions = {\n  HEIGHT: 250,\n  MAX_RADIUS: 25,\n  LEVEL_OFF: 10,\n  ZOOM_INIT: 3,\n  MAP_CENTER: [52, 12],\n  MAP_BOUNDS: [[30, -20], [70, 40]],\n  MARKER_COLOR: {\n    [true]: {\n      color: '#008800',\n      fillColor: '#00cc00',\n    },\n    [false]: {\n      color: '#888844',\n      fillColor: '#bbbb66',\n    },\n  },\n  MARKER_SHAPE: {\n    weight: 1,\n    fill: true,\n    fillOpacity: 0.8,\n  },\n  COUNTRY_STYLE: {\n    [true]: {\n      color: '#884422',\n      weight: 2,\n      fill: true,\n      fillColor: '#aa7766',\n      fillOpacity: 1,\n    },\n    [false]: {\n      color: '#777777',\n      weight: 1,\n      fill: true,\n      fillColor: '#bbbbbb',\n      fillOpacity: 1,\n    },\n  },\n}\n\nconst computeRadius = (_id, filteredAmountOthers, amounts) => {\n  const amount = amounts ? (amounts[_id] || 0) : 0\n  if (amount == 0) {return 0}\n  const { MAX_RADIUS, LEVEL_OFF } = mapOptions\n  const proportional = MAX_RADIUS * amount / filteredAmountOthers\n  if (filteredAmountOthers < LEVEL_OFF) {return proportional}\n  return LEVEL_OFF * Math.sqrt(proportional)\n}\n\nclass EUMap extends Component {\n  constructor(props) {\n    super(props)\n    this.features = {}\n  }\n  setMap = dom => {if (dom) {this.dom = dom}}\n\n  render() {\n    const { props: { tables, ...byValueProps }, setMap } = this\n    return (\n      <div>\n        <div\n          ref={setMap}\n        />\n        <ByValue {...byValueProps} />\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    const {\n      props: { filterSetting, filteredAmountOthers, amounts, tables: { country } },\n      dom,\n    } = this\n    const { HEIGHT, MAP_CENTER, ZOOM_INIT, MAP_BOUNDS, MARKER_COLOR, MARKER_SHAPE, COUNTRY_STYLE } = mapOptions\n    dom.style.height = HEIGHT\n    this.map = L.map(dom, {\n      attributionControl: false,\n      center: MAP_CENTER,\n      zoom: ZOOM_INIT,\n      maxBounds: MAP_BOUNDS,\n    })\n    const { allIds, entities } = country\n    this.idFromIso = {}\n    this.inDariah = {}\n    allIds.forEach(_id => {\n      const { [_id]: { values: { iso, isMember } } } = entities\n      this.idFromIso[iso] = _id\n      this.inDariah[iso] = isMember\n    })\n    L.geoJSON(countryBorders, {\n      style: feature => COUNTRY_STYLE[this.inDariah[feature.properties.iso2]],\n      onEachFeature: feature => {\n        const { properties: { iso2, lat, lng } } = feature\n        if (this.inDariah[iso2]) {\n          const { idFromIso: { [iso2]: _id } } = this\n          const { [_id]: isOn } = filterSetting\n          const marker = L.circleMarker([lat, lng], {\n            ...MARKER_COLOR[isOn],\n            radius: computeRadius(_id, filteredAmountOthers, amounts),\n            ...MARKER_SHAPE,\n            pane: 'markerPane',\n          }).addTo(this.map)\n          this.features[iso2] = marker\n        }\n      },\n    }).addTo(this.map)\n  }\n\n  componentDidUpdate() {\n    const { props: { filterSetting, filteredAmountOthers, amounts } } = this\n    const { MARKER_COLOR } = mapOptions\n    Object.entries(this.features).forEach(([iso2, marker]) => {\n      const { idFromIso: { [iso2]: _id } } = this\n      const { [_id]: isOn } = filterSetting\n      marker.setRadius(computeRadius(_id, filteredAmountOthers, amounts))\n      marker.setStyle(MARKER_COLOR[isOn])\n    })\n  }\n}\n\nEUMap.displayName = 'EUMap'\n\nexport default connect(combineSelectors(getTables, getFilterSetting))(EUMap)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/EUMap.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { getTables, needValues, fetchItem } from 'tables'\n\nimport ItemForm from 'ItemForm'\n\nclass ItemContainer extends Component {\n  render() {\n    const { props: { tables, table, eId } } = this\n    if (needValues({ tables, table, eId })) {return <div />}\n\n    const { [table]: { fields, entities: { [eId]: entity } } } = tables\n    const { values: initialValues, perm } = entity\n    return (\n      <div>\n        <ItemForm\n          table={table}\n          eId={eId}\n          form={`${table}-${eId}`}\n          key={`${table}-${eId}`}\n          initialValues={initialValues}\n          perm={perm}\n          fields={fields}\n        />\n      </div>\n    )\n    /* Note the key prop passed to ItemForm.\n     * If you do not pass it, you get bugs caused by the mounting and unmounting of this component\n     * due to react-router navigation.\n     * In essence, the callback onChange that redux-form passes to input components, becomes bound to the wrong form!\n     * This workaround is documented here: https://github.com/erikras/redux-form/issues/2886\n    */\n  }\n  componentDidMount() {\n    const { props: { tables, table, eId, fetch } } = this\n    if (needValues({ tables, table, eId })) {fetch(table, eId)}\n  }\n  componentDidUpdate() {\n    const { props: { tables, table, eId, fetch } } = this\n    if (needValues({ tables, table, eId })) {fetch(table, eId)}\n  }\n}\n\nexport default connect(getTables, { fetch: fetchItem })(ItemContainer)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/ItemContainer.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { withParams } from 'utils'\nimport { getTables, needTables, fetchTable } from 'tables'\n\nimport ListGrid from 'ListGrid'\nimport ListPlain from 'ListPlain'\nimport ListFilter from 'ListFilter'\n\nclass ListContainer extends Component {\n  render() {\n    const { props: { table, tables, select, mode } } = this\n    const grid = mode == 'grid'\n    if (needTables(tables, table, select, grid)) {return <div />}\n    const { [table]: { title, perm, myIds, allIds } } = tables\n    const listIds = select == 'myIds' ? myIds : allIds\n    return (\n      mode == 'list' ?\n        <ListPlain\n          table={table}\n          listIds={listIds}\n          select={select}\n          perm={perm}\n          title={title}\n        /> :\n      mode == 'grid' ?\n        <ListGrid\n          table={table}\n          listIds={listIds}\n          select={select}\n          perm={perm}\n          tag={table}\n        /> :\n      mode == 'filter' ?\n        <ListFilter\n          table={table}\n          select={select}\n        /> :\n        <span>{`unknown display mode \"${mode}\" for item list`}</span>\n    )\n  }\n  componentDidMount() {\n    const { props: { tables, table, select, mode, fetch } } = this\n    const grid = mode == 'grid'\n    if (needTables(tables, table, select, grid)) {fetch(table, select, grid)}\n  }\n  componentDidUpdate() {\n    const { props: { tables, table, select, mode, fetch } } = this\n    const grid = mode == 'grid'\n    if (needTables(tables, table, select, grid)) {fetch(table, select, grid)}\n  }\n}\n\nexport default connect(getTables, { fetch: fetchTable })(withParams(ListContainer))\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/ListContainer.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { setupFiltering, getFiltersApplied } from 'filters'\n\nimport ListPlain from 'ListPlain'\nimport Filter from 'Filter'\nimport Pane from 'Pane'\n\n\nclass ListFilter extends Component {\n  constructor(props) {\n    super()\n    const { tables, table, initialized, init } = props\n    if (!initialized) {init(tables, table)}\n  }\n  render() {\n    const {\n      props: {\n        heading,\n        tables, table,\n        masterId, linkField,\n        filteredIds, filteredAmountOthers, amounts,\n        initialized,\n      },\n    } = this\n    if (!initialized) {return <div />}\n    const { [table]: { allIds, title } } = tables\n    return (\n      <div>\n        <Pane format=\"sized\" position=\"rightLeft\">\n          <p>{'Total '}<span className=\"good-o\" >{allIds.length}</span></p>\n          <Filter\n            table={table}\n            filteredAmount={filteredIds.length}\n            filteredAmountOthers={filteredAmountOthers}\n            amounts={amounts}\n          />\n        </Pane>\n        <Pane format=\"sized\" position=\"rightRight\">\n          <ListPlain\n            heading={heading}\n            table={table}\n            listIds={filteredIds}\n            title={title}\n            masterId={masterId}\n            linkField={linkField}\n          />\n        </Pane>\n      </div>\n    )\n  }\n}\n\nexport default connect(getFiltersApplied, { init: setupFiltering })(ListFilter)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/ListFilter.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport isEqual from 'lodash/isequal'\n\nimport { combineSelectors, memoize, emptyO } from 'utils'\nimport { EditStatus } from 'fields'\n\nimport { getTables, insertItem } from 'tables'\nimport { getAlts, makeAlt } from 'alter'\n\nimport ItemContainer from 'ItemContainer'\n\nconst initial = 0\nconst nAlts = 2\n\nclass ListPlain extends Component {\n  handleInsert = () => {\n    const { props: { table, select, masterId, linkField, dispatch } } = this\n    dispatch(insertItem(table, select, masterId, linkField))\n    this.gotoNew = true\n  }\n  gotoItem = eId => {\n    const { props, props: { table } } = this\n    const { nextAlt } = makeAlt(props, { tag: `${table}-${eId}`, nAlts, initial })\n    nextAlt()\n  }\n  closeItem = eId => {\n    const { props, props: { table } } = this\n    const { initAlt } = makeAlt(props, { tag: `${table}-${eId}`, nAlts, initial })\n    initAlt()\n  }\n  handleCloseAll = memoize(items => () => {items.forEach(eId => {this.closeItem(eId)})})\n\n  scroll = domElem => {\n    if (domElem != null) {\n      domElem.scrollIntoViewIfNeeded()\n    }\n  }\n\n  render() {\n    const { props, props: { tables, table, listIds, perm, title } } = this\n    const { [table]: { entities } } = tables\n    return (\n      <div className={'listGeneric'} >\n        <div>\n          {`${listIds.length} item${listIds.length == 1 ? '' : 's'} `}\n          {(perm != null && perm.insert) ? (\n            <span\n              className=\"fa fa-plus button-large\"\n              title={`new ${table}`}\n              onClick={this.handleInsert}\n            />\n          ) : null}\n        </div>\n        {\n          listIds.map(eId => {\n            const { [eId]: { values, perm: ePerm } } = entities\n            const { [title]: entityHead = '-empty-' } = values\n            const tag = `${table}-${eId}`\n            const { alt, nextAlt } = makeAlt(props, { tag, nAlts, initial })\n            const active = alt != initial\n            const scrollProps = active ? { ref: this.scroll } : emptyO\n            return (\n              <div key={eId} >\n                <span {...scrollProps} >\n                  {ePerm != null && ePerm.update ? <EditStatus form={tag} showNeutral={true} /> : null}\n                  <span\n                    className={'link'}\n                    onClick={nextAlt}\n                  >\n                    <span className={`fa fa-angle-${active ? 'up' : 'down'}`} />\n                    {' '}{entityHead}\n                  </span>\n                </span>\n                {active ?\n                  <ItemContainer\n                    table={table}\n                    eId={eId}\n                  /> : null\n                }\n              </div>\n            )\n          })\n        }\n        <div\n          className={'button-large fa fa-angle-double-left'}\n          onClick={this.handleCloseAll(listIds)}\n        />\n      </div>\n    )\n  }\n\n  gotoNewItem() {\n    if (this.gotoNew) {\n      const { props: { tables, table } } = this\n      const { [table]: tableInfo } = tables\n      if (tableInfo == null) {return}\n      const { lastInserted } = tableInfo\n      if (lastInserted != null) {\n        this.gotoNew = false\n        this.gotoItem(lastInserted)\n      }\n    }\n  }\n  shouldComponentUpdate(newProps) {\n    for (const prop in newProps) {\n      if (prop != 'listIds') {\n        if (newProps[prop] !== this.props[prop]) {\n          return true\n        }\n      }\n      else {\n        if (!isEqual(newProps[prop], this.props[prop])) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n  componentDidMount() {\n    this.gotoNewItem()\n  }\n  componentDidUpdate() {\n    this.gotoNewItem()\n  }\n}\n\nconst getInfo = combineSelectors(getTables, getAlts)\n\nexport default connect(getInfo)(ListPlain)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/ListPlain.jsx","import React, {Component} from 'react'\nimport { connect } from 'react-redux'\n\nimport { getMe, fetchMe } from 'me'\n\nclass Login extends Component {\n  render() {\n    const { props: { me } } = this\n    return (\n      <span className=\"login\" >{\n        me.eppn ? (\n          <span>\n            <span className=\"fa fa-user\" title={me.eppn} /><strong>{me.eppn.split('@')[0]}</strong>\n            <span className=\"fa fa-hashtag\" />{me.authority}{' '}\n            <em>{me.groupDesc || 'not authenticated'}</em>\n            <a href=\"/logout\" className=\"control fa fa-user-times\" title=\"log out\" />\n            <a href=\"/slogout\" className=\"control fa fa-users\" title=\"sign out\" />\n          </span>\n        ) : (\n          <a href=\"/login\" className={'control'}><strong className={'fa fa-user-plus'} /><strong>{' login'}</strong></a>\n        )}\n      </span>\n    )\n  }\n  componentDidMount() {\n    const { props: { fetch } } = this\n    fetch({ type: 'fetchMe', contentType: 'db', path: '/who/ami', desc: 'me' })\n  }\n}\n\nexport default connect(getMe, { fetch: fetchMe })(Login)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/Login.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { getNotifications, clear, display } from 'notify'\n\nclass Notification extends Component {\n  constructor(props) {\n    super(props)\n    this.dom = {}\n  }\n  refDom = label => dom => {\n    if (dom) {this.dom[label] = dom}\n  }\n  handleBox = () => {\n    const { props: { show, display } } = this\n    display(!show)\n  }\n  handleHide = () => {\n    const { props: { display } } = this\n    display(false)\n  }\n  handleClear = () => {\n    const { props: { clear } } = this\n    clear()\n  }\n\n  render() {\n    const { props: { notifications, lastNote, lastKind, busy, show } } = this\n    const highlight = lastNote > -1\n    const busyBlocks = new Array(busy < 0 ? 0 : busy).fill(1)\n    return (\n      <div>\n        <p className=\"msg-spinner\" >\n          <span\n            title=\"show/hide notifications and progress messages\"\n            className={highlight ? `spin-${lastKind}` : 'spin-ok'}\n          >\n            { busyBlocks.map((b, i) => <span key={i} className=\"msg-dot fa fa-caret-left\" />) }\n            <span\n              className={`fa fa-${busy == 0 ? 'circle-o' : 'spinner fa-spin'}`}\n              onClick={this.handleBox}\n            />\n          </span>\n        </p>\n        {show ? (\n          <div\n            ref={this.refDom('notbox')}\n            className=\"msg-box\"\n            onClick={this.handleHide}\n          >{\n            (notifications).map((msg, i) => (\n              <p\n                key={i}\n                ref={this.refDom(`m${i}`)}\n                className={`msg-line ${[msg.kind]}-o ${msg.kind != 'info' ? 'msg-high' : ''}`}\n              >{msg.text}</p>\n            ))\n          }\n            <p className=\"msg-dismiss\" >{'(click panel to hide)'}</p>\n            <p className=\"msg-trash\" >\n              <a\n                href=\"#\"\n                title=\"clear messages\"\n                className=\"control fa fa-trash\"\n                onClick={this.handleClear}\n              />\n            </p>\n          </div>\n        ) : null}\n      </div>\n    )\n  }\n  componentDidMount() {this.setView()}\n  componentDidUpdate() {this.setView()}\n\n  setView() {\n    const { props: { show } } = this\n    if (show) {this.setScroll()}\n  }\n  setScroll() {\n    const { props: { show } } = this\n    if (show) {\n      const { props: { lastMsg, lastNote } } = this\n      const highlight = lastNote > -1\n      if (highlight) {\n        this.dom[`m${lastNote}`].scrollIntoView()\n      }\n      else {\n        if (lastMsg > -1) {\n          this.dom[`m${lastMsg}`].scrollIntoView()\n        }\n      }\n    }\n  }\n}\n\nexport default connect(getNotifications, { clear, display })(Notification)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/Notification.jsx","import { Component, Children } from 'react'\nimport { connect } from 'react-redux'\nimport throttle from 'lodash/throttle'\n\nimport { changeWinDim } from 'win'\n\nclass Window extends Component {\n  render() {\n    const { props: { children } } = this\n    return Children.only(children)\n  }\n  newWindowSize = throttle(() => {\n    const { props: { resize } } = this\n    resize()\n  }, 1000)\n\n  componentDidMount() {window.addEventListener(\"resize\", this.newWindowSize)}\n  componentWillUnmount() {window.removeEventListener(\"resize\", this.newWindowSize)}\n}\n\nexport default connect(null, { resize: changeWinDim })(Window)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/Window.jsx","import React from 'react'\n\nimport DocMd from 'DocMd'\nimport DocPdf from 'DocPdf'\nimport DocHtml from 'DocHtml'\nimport NotFound from 'NotFound'\n\nconst docType = {\n  md: DocMd,\n  pdf: DocPdf,\n  html: DocHtml,\n}\n\nconst Doc = ({ location: { pathname: docPath } }) => {\n  const [docDir, docFile] = /^(.*)\\/([^/]+)$/g.exec(docPath).slice(1)\n  const [docName, docExt] = /^(.*)\\.([^.]+)$/g.exec(docFile).slice(1)\n  const { [docExt]: DocClass } = docType\n  return DocClass == null ? (\n    <NotFound splat={`document ${docPath}`} />\n  ) : (\n    <DocClass docDir={docDir} docName={docName} docExt={docExt} tag={docName} />\n  )\n}\n\nexport default Doc\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/Doc.jsx","import React from 'react'\n\nconst DocHtml = ({ docDir, docName, docExt }) => {\n  const src = `/api/file${docDir}/${docName}.${docExt}`\n  return (\n    <iframe\n      height=\"100%\"\n      width=\"100%\"\n      src={src}\n    />\n  )\n}\n\nexport default DocHtml\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/DocHtml.jsx","import React from 'react'\n\nconst DocPdf = ({ docDir, docName, docExt }) => {\n  const href = `/api/file${docDir}/${docName}.${docExt}`\n  const iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream\n  return iOS ? (\n    <p>\n      <a target=\"_blank\" rel=\"noopener noreferrer\" href={href} >{docName}</a>{' (open pdf in a new tab)'}\n    </p>\n  ) : (\n    <object\n      height=\"100%\"\n      width=\"100%\"\n      data={href}\n      type=\"application/pdf\"\n    >\n      <a target=\"_blank\" rel=\"noopener noreferrer\" href={href} >{docName}</a>{' (open pdf in a new tab)'}\n    </object>\n  )\n}\n\nexport default DocPdf\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/DocPdf.jsx","import React from 'react'\n\nimport { editClass } from 'fields'\n\nconst Input = ({ meta: { dirty, invalid, error }, input, type }) => (\n  <span>\n    <input type={type} className={editClass(dirty, invalid)} {...input} />\n    {error && <span className=\"invalid diag\">{error}</span>}\n  </span>\n)\n\nexport default Input\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/Input.jsx","import React from 'react'\nimport { Field } from 'redux-form'\n\nimport { editClass } from 'fields'\n\nconst fieldRemove = (fields, i) => () => {fields.remove(i)}\nconst fieldPush = fields => () => {fields.push()}\n/* N.B.\n * fieldRemove and fieldPush MUST NOT be memoized.\n * Otherwise they may become bound to the wrong form.\n * This happens if you navigate with react-router between forms.\n */\n\nconst InputMulti = ({\n  componentSingle, validateSingle, normalizeSingle,\n  meta: { dirty, invalid, error },\n  fields, table, eId, name,\n  ...props\n}) => (\n  <div\n    className={`${editClass(dirty, invalid)} multi-field`}\n  >\n    {fields.map((field, i) =>\n      <div\n        key={field}\n        className={'multi-content'}\n      >\n        <span\n          className=\"button-small fa fa-close\"\n          title=\"remove\"\n          onClick={fieldRemove(fields, i)}\n        />\n        <Field\n          name={field}\n          component={componentSingle}\n          validate={validateSingle}\n          normalize={normalizeSingle}\n          label={i}\n          table={table}\n          eId={eId}\n          {...props}\n        />\n      </div>\n    )}\n    <div\n      className={'button-small fa fa-plus multi-control'}\n      onClick={fieldPush(fields)}\n    />\n    {error && <p className=\"invalid diag\">{error}</p>}\n  </div>\n)\n\nexport default InputMulti\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/InputMulti.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport Markdown from 'react-markdown'\n\nimport { editClass } from 'fields'\n\nimport { getAlts, makeAlt } from 'alter'\n\nconst MarkdownArea = ({\n    table, eId, meta: { dirty, invalid, error },\n    input: { name, value }, input,\n    ...props\n}) => {\n  const { alt, nextAlt } = makeAlt(props, {\n    tag: `md-${table}-${eId}-${name}`,\n    nAlts: 2,\n    initial: 0,\n  })\n  return (\n    <div className={'md-field'}>\n      <p className={'stick'} >\n        <span\n          className={`button-medium field-control fa fa-${alt == 0 ? 'pencil' : 'hand-o-down'}`}\n          onClick={nextAlt}\n        />\n      </p>\n      {\n        alt == 0 ?\n          <Markdown\n            className={`${editClass(dirty, invalid)} field-content`}\n            key=\"fmt\"\n            source={value}\n          /> :\n          <span key=\"src\" className=\"field-content\">\n            <textarea\n              className={`input ${editClass(dirty, invalid)}`}\n              {...input}\n              wrap=\"soft\"\n            />\n            {error && <span className=\"invalid diag\">{error}</span>}\n          </span>\n      }\n    </div>\n  )\n}\n\nexport default connect(getAlts)(MarkdownArea)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/MarkdownArea.jsx","import React from 'react'\nimport { Link } from 'react-router'\n\nconst NavLink = props => <Link {...props} activeClassName=\"active\" />\n\nexport default NavLink\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/NavLink.jsx","import React from 'react'\n\nconst NotFound = ({ splat }) => (<h1>{'404: '}<code>{splat}</code>{' not found on this site.'}</h1>)\n\nexport default NotFound\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/NotFound.jsx","import React from 'react'\nimport { Provider } from 'react-redux'\n\nimport store from 'roots'\nimport Window from 'Window'\n\nconst Root = ({ children }) => (\n  <Provider store={store}>\n    <Window>\n      {children}\n    </Window>\n  </Provider>\n)\n\nexport default Root\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/Root.jsx","import React from 'react'\n\nconst Stat = ({subTotal, total}) => (\n  <span className=\"good-o\" >\n    {subTotal == null ? '' : `${subTotal}`}\n    {(total == null || subTotal == null) ? '' : ' of '}\n    <strong>{total == null ? '' : `${total}`}</strong>\n  </span>\n)\n\nexport default Stat\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/Stat.jsx","import React from 'react'\n\nimport NavLink from 'NavLink'\n\nconst Static = () => (\n  <span className=\"small\" >\n    <NavLink to=\"/docs/about.md\" >{'About'}</NavLink>\n    <NavLink to=\"/tech/docs/design.pdf\" >{'diagrams'}</NavLink>\n    <a href=\"https://dans-labs.github.io/dariah/\" target=\"_blank\" rel=\"noopener noreferrer\" >{'tech doc'}</a>\n  </span>\n)\n\nexport default Static\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/Static.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors } from 'utils'\n\nimport { getMe } from 'me'\nimport { getWinDim } from 'win'\n\nimport Login from 'Login'\nimport NavLink from 'NavLink'\nimport Static from 'Static'\nimport Notification from 'Notification'\n\nconst App = ({ children, height, width, me }) => {\n  const text = `${width} x ${height}`\n  return (\n    <div>\n      <Notification />\n      <p className=\"nav small top\" >\n        <img\n          src=\"/static/images/inkind_logo_small.png\"\n          title=\"information about this site\"\n        />\n        <NavLink to=\"/data/contrib\" >{'Contributions'}</NavLink>\n        {\n          me.eppn ?\n            <NavLink to=\"/backoffice\" >{'Backoffice'}</NavLink> :\n            null\n        }\n        <Static />\n        <span className=\"resize\" title={text}>{text}</span>\n        <Login />\n      </p>\n      <div>{children}</div>\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getWinDim, getMe)\n\nexport default connect(getInfo)(App)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/App.jsx","import React from 'react'\n\nimport { withParams } from 'utils'\n\nimport NavLink from 'NavLink'\nimport Pane from 'Pane'\n\nconst Backoffice = ({ children }) => (\n  <div>\n    <Pane format=\"nav sized\" position=\"left\">\n      <div>\n        <p><NavLink to={`/backoffice/user/list`} >{'Users'}</NavLink></p>\n        <p><NavLink to={`/backoffice/country/grid`} >{'Countries'}</NavLink></p>\n        <p><NavLink to={`/backoffice/criteria/list`} >{'Criteria (list)'}</NavLink></p>\n        <p><NavLink to={`/backoffice/criteria/grid`} >{'Criteria (grid)'}</NavLink></p>\n        <p><NavLink to={`/backoffice/package/list`} >{'Packages (list)'}</NavLink></p>\n        <p><NavLink to={`/backoffice/package/grid`} >{'Packages (grid)'}</NavLink></p>\n      </div>\n    </Pane>\n    <Pane format=\"sized\" position=\"right\">\n      { children }\n    </Pane>\n  </div>\n)\n\nexport default withParams(Backoffice)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/Backoffice.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors } from 'utils'\nimport { getFieldValues, placeFacets } from 'filters'\nimport { getAlts, makeAlt } from 'alter'\n\nimport Facet from 'Facet'\nimport CheckboxI from 'CheckboxI'\nimport Stat from 'Stat'\n\nconst ByValue = ({\n  table,\n  filterId, filterLabel,\n  fieldValues,\n  filteredAmount, filteredAmountOthers,\n  amounts, maxCols,\n  expanded,\n  ...props\n}) => {\n  const rows = placeFacets(fieldValues, maxCols)\n  if (rows == null) {\n    return <div className=\"facet\" ><p>{' -no facets '}</p></div>\n  }\n  const tag = `${table}-${filterId}`\n  const { alt, nextAlt } = makeAlt(props, { tag, nAlts: 2, initial: expanded ? 0 : 1 })\n  return (\n    <div className=\"facet\" >\n      <p className=\"facet\" >\n        <CheckboxI\n          table={table}\n          filterId={filterId}\n        /> {filterLabel}{' '}\n        <Stat subTotal={filteredAmount} total={filteredAmountOthers} />{' '}\n        <span\n          className={`button-small fa fa-angle-${alt == 0 ? 'up' : 'down'}`}\n          onClick={nextAlt}\n        />\n      </p>\n      {\n        alt == 0 ?\n          <table\n            key=\"table\"\n            className=\"facets\"\n          >\n            <tbody>\n              {rows.map((entity, i) => (\n                <tr key={i} >\n                  {entity.map((f, j) => {\n                    if (f === null) {\n                      return <td key={j} />\n                    }\n                    const [valueId, valueRep] = f\n                    const facetClass = j == 0 ? 'facet' : 'facet mid'\n                    return [(\n                      <td\n                       key={valueId}\n                       className={facetClass}\n                      >\n                        <Facet\n                          table={table}\n                          filterId={filterId}\n                          valueId={valueId}\n                          valueRep={valueRep}\n                        />\n                      </td>\n                    ), (\n                      <td\n                        key=\"stat\"\n                        className=\"statistic\"\n                      >\n                        <Stat subTotal={amounts[valueId]} />\n                      </td>\n                    )]\n                  })}\n                </tr>\n                ))}\n            </tbody>\n          </table> :\n          <div />\n      }\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getFieldValues, getAlts)\n\nexport default connect(getInfo)(ByValue)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ByValue.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { memoize } from 'utils'\nimport { changeFacet, getFilterSetting } from 'filters'\n\nconst handleChange = memoize((handle, table, filterId, valueId, isOn) => () => handle(table, filterId, valueId, !isOn))\n\nconst Facet = ({ table, filterId, valueId, valueRep, filterSetting, handle }) => {\n  const { [valueId]: isOn } = filterSetting\n  return (\n    <span>\n      <input\n        type=\"checkbox\"\n        checked={isOn}\n        className=\"facet\"\n        onChange={handleChange(handle, table, filterId, valueId, isOn)}\n      />\n      {` ${valueRep}`}\n    </span>\n  )\n}\n\nexport default connect(getFilterSetting, { handle: changeFacet })(Facet)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/Facet.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport { Field, FieldArray } from 'redux-form'\n\nimport { validation, normalization, getValType } from 'fields'\nimport { getTables } from 'tables'\n\nimport InputMulti from 'InputMulti'\nimport RelSelect from 'RelSelect'\n\nconst FieldEdit = ({ field, tables, table, eId, ...props }) => {\n  const { [table]: { fieldSpecs } } = tables\n  const { [field]: { valType, valid, multiple } } = fieldSpecs\n  if (typeof valType == 'string') {\n    const typing = getValType(valType)\n    const { component, type } = typing\n    const { [valid || valType]: validate } = validation\n    const { [valid || valType]: normalize } = normalization\n    if (multiple) {\n      return (\n        <FieldArray\n          name={field}\n          component={InputMulti}\n          componentSingle={component}\n          validateSingle={validate}\n          normalizeSingle={normalize}\n          table={table}\n          eId={eId}\n          type={type}\n          {...props}\n        />\n      )\n    }\n    else {\n      return (\n        <Field\n          name={field}\n          component={component}\n          validate={validate}\n          normalize={normalize}\n          table={table}\n          eId={eId}\n          type={type}\n          {...props}\n        />\n      )\n    }\n  }\n  else {\n    const { allowNew } = valType\n    const tag = `${table}-${eId}-${field}`\n    return (\n      <Field\n        name={field}\n        component={RelSelect}\n        tag={tag}\n        field={field}\n        multiple={multiple}\n        allowNew={allowNew}\n        table={table}\n        eId={eId}\n        {...props}\n      />\n    )\n  }\n}\n\nexport default connect(getTables)(FieldEdit)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/FieldEdit.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport Markdown from 'react-markdown'\n\nimport { emptyA } from 'utils'\n\nimport { getTables, repr } from 'tables'\n\nconst FieldRead = ({ field, tables, table, myValues }) => {\n  const { [table]: { fieldSpecs } } = tables\n  const { [field]: { valType, multiple } } = fieldSpecs\n  const isArea = valType == 'textarea'\n  const sep = isArea ? '\\n\\n' : ' | '\n  const myRepr = multiple ?\n    (myValues || emptyA).map(value => repr(tables, table, valType, value)).join(sep) :\n    repr(tables, table, valType, myValues)\n  return isArea ?\n    <Markdown source={myRepr} /> :\n    <span>{myRepr}</span>\n}\n\nexport default connect(getTables)(FieldRead)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/FieldRead.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { getTableFilters } from 'tables'\n\nimport Fulltext from 'Fulltext'\nimport ByValue from 'ByValue'\nimport EUMap from 'EUMap'\n\nconst filterClass = {\n  Fulltext,\n  EUMap,\n  ByValue,\n}\n\nconst Filter = ({\n  table, fields,\n  filterList, filteredAmount, filteredAmountOthers, amounts,\n}) => (\n  <div>\n    {filterList.filter(x => fields[x.field]).map((filter, filterId) => {\n      const { type } = filter\n      const { [type]: Fclass } = filterClass\n      return (\n        <Fclass\n          key={filterId}\n          table={table}\n          filterId={filterId}\n          filterField={filter.field}\n          filterLabel={filter.label}\n          maxCols={filter.maxCols}\n          filteredAmount={filteredAmount}\n          filteredAmountOthers={filteredAmountOthers[filterId]}\n          amounts={amounts[filterId]}\n          expanded={filter.expanded}\n        />\n      )}\n    )}\n  </div>\n)\n\nexport default connect(getTableFilters)(Filter)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/Filter.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { memoize } from 'utils'\nimport { changeFulltext, getFilterSetting } from 'filters'\n\nimport Stat from 'Stat'\n\nconst handleChange = memoize((handle, table, filterId) => event => handle(table, filterId, event.target.value))\n\nconst Fulltext = ({\n  table,\n  filterId, filterField, filterLabel,\n  filterSetting,\n  filteredAmount, filteredAmountOthers,\n  handle,\n}) => (\n  <div>\n    <p title={`Search in ${filterField}`} >\n      <input\n        type=\"text\"\n        className=\"search\"\n        placeholder={`search in ${filterLabel}`}\n        value={filterSetting}\n        onChange={handleChange(handle, table, filterId)}\n      />{' '}\n      <Stat subTotal={filteredAmount} total={filteredAmountOthers} />\n    </p>\n  </div>\n)\n\nexport default connect(getFilterSetting, { handle: changeFulltext })(Fulltext)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/Fulltext.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors } from 'utils'\nimport { makeDetails } from 'fields'\n\nimport { getTables } from 'tables'\nimport { getAlts, makeAlt } from 'alter'\n\nconst ItemDetailHeads = ({ tables, table, eId, detailFragments, ...props }) => {\n  const theFragments = detailFragments == null ? makeDetails(tables, table, eId) : detailFragments\n  return (\n    <div className={'grid fragments'}>{\n      theFragments.map(({ name, label, nDetails }) => {\n        const tag = `detail-${table}-${eId}-${name}`\n        const { nextAlt } = makeAlt(props, { tag, nAlts: 2, initial: 1 })\n        return (\n          <div\n            key={name}\n            className={'grid-row form'}\n          >\n            <div className={'grid-head-cell labelCol'} >{`${label}:`}</div>\n            <div className={'grid-cell valueCol'} >\n              <span\n                className={'link'}\n                onClick={nextAlt}\n              >\n                {`${nDetails} item${nDetails == 1 ? '' : 's'}`}\n              </span>\n            </div>\n          </div>\n        )\n      })\n    }\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getTables, getAlts)\n\nexport default connect(getInfo)(ItemDetailHeads)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ItemDetailHeads.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors, emptyA } from 'utils'\n\nimport { getTables } from 'tables'\nimport { getAlts, makeAlt } from 'alter'\n\nimport ListGrid from 'ListGrid'\nimport ListPlain from 'ListPlain'\nimport ListFilter from 'ListFilter'\n\nconst ItemDetails = ({ tables, table, eId, ...props }) => {\n  const { [table]: { details, detailOrder } } = tables\n  return (\n    <div>\n      {\n        (detailOrder || emptyA).map(name => {\n          const { label, table: detailTable, linkField, mode } = details[name]\n          const {\n            [detailTable]: {\n              title: detailTitle,\n              perm: detailPerm,\n              entities: detailEntities,\n              allIds: detailAllIds,\n            },\n          } = tables\n          const detailListIds = detailAllIds.filter(_id => detailEntities[_id].values[linkField] == eId)\n          const tag = `detail-${table}-${eId}-${name}`\n          const { alt } = makeAlt(props, { tag, nAlts: 2, initial: 1 })\n          return (\n            <div key={name}>\n              {\n                alt == 0 ? (\n                  mode == 'list' ?\n                    <ListPlain\n                      heading={label}\n                      table={detailTable}\n                      listIds={detailListIds}\n                      perm={detailPerm}\n                      title={detailTitle}\n                      masterId={eId}\n                      linkField={linkField}\n                    /> :\n                  mode == 'grid' ?\n                    <ListGrid\n                      heading={label}\n                      table={detailTable}\n                      listIds={detailListIds}\n                      perm={detailPerm}\n                      tag={`${table}-${name}-${eId}`}\n                      masterId={eId}\n                      linkField={linkField}\n                    /> :\n                  mode == 'filter' ?\n                    <ListFilter\n                      heading={label}\n                      table={detailTable}\n                      masterId={eId}\n                      linkField={linkField}\n                    /> :\n                    <span>{`unknown display mode \"${mode}\" for item list`}</span>\n                ) : ''\n              }\n            </div>\n          )\n        })\n      }\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getTables, getAlts)\n\nexport default connect(getInfo)(ItemDetails)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ItemDetails.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport { reduxForm } from 'redux-form'\n\nimport { getTables, modItem, delItem, toDb } from 'tables'\nimport { makeFields, makeDetails, someEditable, onSubmitSuccess, editStatus, editDelete } from 'fields'\nimport { memoize } from 'utils'\nimport { makeOptionStyles } from 'custom'\n\nimport FieldRead from 'FieldRead'\nimport FieldEdit from 'FieldEdit'\nimport ItemDetails from 'ItemDetails'\nimport ItemDetailHeads from 'ItemDetailHeads'\n\nconst deleteit = memoize((del, table, eId) => event => {\n  event.preventDefault()\n  del(table, eId)\n})\n\nconst WrapForm = ({ children, submitFunction }) => (\n  submitFunction ?\n    <form onSubmit={submitFunction} >{children}</form> :\n    <div>{children}</div>\n)\n\nconst ItemForm = props => {\n  const {\n    table, eId, perm,\n    dirty, invalid, submitting, reset, error, mod, del,\n    handleSubmit,\n  } = props\n  let { fieldFragments, detailFragments } = props\n  if (fieldFragments == null) {fieldFragments = makeFields(props)}\n  if (detailFragments == null) {detailFragments = makeDetails(props)}\n  const hasEditable = someEditable(props)\n  return (\n    <div>\n      <WrapForm submitFunction={hasEditable ? handleSubmit(toDb(table, eId, mod)) : null} >\n        <div>\n          {editDelete(perm, 'button-large', deleteit(del, table, eId))}\n          {hasEditable ? editStatus({\n            form: `${table}-${eId}`,\n            showNeutral: false,\n            dirty, invalid, submitting, reset, error,\n          }) : null}\n        </div>\n        <div className={'grid fragments'}>{\n          fieldFragments.map(({\n            field, label,\n            fragment: { editable, table: detailTable, myValues, ...props },\n          }) => (\n            <div\n              key={field}\n              className={'grid-row form'}\n            >\n              <div className={'grid-head-cell labelCol'}>{`${label}:`}</div>\n              <div className={'grid-cell valueCol'} >{editable ?\n                <FieldEdit\n                  field={field}\n                  table={detailTable}\n                  {...props}\n                /> :\n                <FieldRead\n                  field={field}\n                  table={detailTable}\n                  myValues={myValues}\n                />\n              }\n              </div>\n            </div>\n          ))\n        }\n        </div>\n      </WrapForm>\n      <ItemDetailHeads\n        table={table}\n        eId={eId}\n        detailFragments={detailFragments}\n      />\n      <ItemDetails\n        table={table}\n        eId={eId}\n      />\n    </div>\n  )\n}\n\nexport default connect(getTables, {\n  mod: modItem,\n  del: delItem,\n})(reduxForm({\n  destroyOnUnmount: false,\n  enableReinitialize: true,\n  keepDirtyOnReinitialize: true,\n  onSubmitSuccess,\n})(ItemForm))\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ItemForm.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors, memoize } from 'utils'\n\nimport { getTables } from 'tables'\nimport { EditStatus, makeFields, makeDetails, someEditable } from 'fields'\nimport { getAlts, makeAlt } from 'alter'\n\nimport FieldRead from 'FieldRead'\nimport ItemForm from 'ItemForm'\nimport ItemDetails from 'ItemDetails'\n\nconst putFieldFragments = (fieldFragments, widthStyles) => fieldFragments.map(({\n  field, label,\n  fragment: { editable, table, myValues },\n}, i) => {\n  const widthStyle = widthStyles[i]\n  return (\n    <div\n      className={`grid-cell valueColGrid ${editable ? 'editable' : ''}`}\n      style={widthStyle}\n      key={field}\n    >\n      <FieldRead\n        field={field}\n        table={table}\n        myValues={myValues}\n      />\n    </div>\n  )\n})\n\nconst putDetailFragments = (props, table, eId, detailFragments, widthStyles, nFields) => detailFragments.map(({\n  name, label, nDetails,\n}, i) => {\n  const widthStyle = widthStyles[nFields + i]\n  const { nextAlt } = makeAlt(props, { tag: `detail-${table}-${eId}-${name}`, nAlts: 2, initial: 1 })\n  return (\n    <div\n      key={name}\n      className={'grid-cell valueColGrid'}\n      style={widthStyle}\n    >\n      <span\n        className={'link'}\n        onClick={nextAlt}\n      >\n        {`${nDetails} item${nDetails == 1 ? '' : 's'}`}\n      </span>\n    </div>\n  )\n})\n\nconst editControl = memoize((nextAlt, table, eId, mayUpdate, withRow) => (\n  mayUpdate ?\n    <span\n      className={`link fa fa-angle-${withRow ? 'down' : 'up'}`}\n      title={`${withRow ? 'open an' : 'close the'}edit form for this record`}\n      onClick={nextAlt}\n    /> :\n    null\n))\n\nconst ItemRow = ({\n  tables, table, eId, initialValues, perm,\n  fields,\n  widthStyles,\n  ...props\n}) => {\n  const hasEditable = someEditable({ tables, table, eId, fields, perm })\n  const fieldFragments = makeFields({\n    tables, table, eId, initialValues, perm,\n    fields,\n  })\n  const detailFragments = makeDetails({ tables, table, eId })\n  const { update } = perm\n  const nFields = fieldFragments.length\n  const tag = `row-${table}-${eId}`\n  const { alt, nextAlt } = makeAlt(props, { tag, nAlts: 2, initial: 0 })\n  return hasEditable ?\n    <div>\n      {\n        alt == 0 ?\n          <div>\n            <div className={'grid-row'}>\n              <div className=\"grid-status-cell\" >\n                {editControl(nextAlt, table, eId, update, true)}\n                {hasEditable ? <EditStatus form={`${table}-${eId}`} showNeutral={false} /> : null }\n              </div>\n              {putFieldFragments(fieldFragments, widthStyles)}\n              {putDetailFragments(props, table, eId, detailFragments, widthStyles, nFields)}\n            </div>\n            <ItemDetails table={table} eId={eId} />\n          </div> :\n          <div>\n            <div className=\"grid-status-cell\" >\n              {editControl(nextAlt, table, eId, update, false)}\n              {hasEditable ? <EditStatus form={`${table}-${eId}`} showNeutral={true} /> : null}\n            </div>\n            <ItemForm\n              table={table}\n              eId={eId}\n              form={`${table}-${eId}`}\n              initialValues={initialValues}\n              perm={perm}\n              fields={fields}\n              fieldFragments={fieldFragments}\n              detailFragments={detailFragments}\n            />\n          </div>\n      }\n    </div> :\n    <div>\n      <div className=\"grid-row\" >\n        {putFieldFragments(fieldFragments, widthStyles)}\n        {putDetailFragments(props, table, eId, detailFragments, widthStyles, nFields)}\n      </div>\n      <ItemDetails table={table} eId={eId} />\n    </div>\n}\n\nconst getInfo = combineSelectors(getTables, getAlts)\n\nexport default connect(getInfo)(ItemRow)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ItemRow.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors, memoize } from 'utils'\nimport { getSort, getSortedData, resetSort, addColumn, turnColumn, delColumn } from 'grid'\nimport { getTables, insertItem } from 'tables'\n\nimport ItemRow from 'ItemRow'\n\nconst insertit = memoize((insertItem, table, select, masterId, linkField) => () => insertItem(table, select, masterId, linkField))\nconst resetit = memoize((reset, tag) => () => reset(tag))\nconst addCit = memoize((addC, tag, column, direction) => () => addC(tag, column, direction))\nconst turnCit = memoize((turnC, tag, column) => () => turnC(tag, column))\nconst delCit = memoize((delC, tag, column) => () => delC(tag, column))\n\nconst ListGrid = ({\n  heading,\n  tables, table, listIds, select, perm: tablePerm,\n  masterId, linkField,\n  insertItem,\n  tag, sortSpec, reset, addC, turnC, delC,\n  sortedData,\n}) => {\n  const theHeading = heading ? `${heading}: ` : ''\n  const { [table]: { fields, fieldOrder, fieldSpecs, detailOrder, entities } } = tables\n  const xfields = fields\n  const { length: nFields } = fieldOrder\n  const nDetails = detailOrder != null ? detailOrder.length : 0\n  const avLength = `${90 / nFields}%`\n  const widths = fieldOrder.map(field => {\n    const { [field]: { grid } } = fieldSpecs\n    if (grid == null) {\n      return { width: avLength, shrink: 0, grow: 1 }\n    }\n    const { width, grow, shrink } = grid\n    return {\n      width: width == null ? avLength : width,\n      shrink: shrink == null ? 0 : shrink,\n      grow: grow == null ? 0 : grow,\n    }\n  }).concat(new Array(nDetails).fill({ width: avLength, shrink: 0, grow: 0.3 }))\n  const widthStyles = widths.map(({ width, grow, shrink }) => ({\n    flex: `${grow} ${shrink} ${width}`,\n    overflow: 'auto',\n  }))\n\n  const rows = []\n  for (const eId of sortedData) {\n    const { [eId]: { values: initialValues, perm } } = entities\n    rows.push(\n      <ItemRow\n        key={`${table}-${eId}`}\n        table={table}\n        eId={eId}\n        initialValues={initialValues}\n        perm={perm}\n        fields={xfields}\n        widthStyles={widthStyles}\n      />\n    )\n  }\n  return (\n    <div>\n      <p>\n        <span className={'listTitle'}>{theHeading}</span>{`${listIds.length} items `}\n        {(tablePerm != null && tablePerm.insert) ? (\n          <span\n            className=\"fa fa-plus button-large\"\n            title={`new ${table}`}\n            onClick={insertit(insertItem, table, select, masterId, linkField)}\n          />\n        ) : null}\n      </p>\n      {sortSpec.length != 0 ?\n        <p className={'sortspecs'} >\n          {'Sorted: '}\n          {\n            sortSpec.map(([column, direction]) => (\n              <span className={'sortcol'} key={column} >\n                <span>{column}</span>\n                <span className={`fa fa-arrow${direction == -1 ? 'down' : 'up'}`} />\n              </span>\n            ))\n          }\n          <span className={'fa fa-close button-small'} onClick={resetit(reset, tag)} />{' '}\n        </p> : null\n      }\n      <div className=\"grid\" >\n        <div className=\"grid-head\" >\n          <div className=\"grid-status-cell\" />\n          {\n            fieldOrder.filter(field => field != linkField).map((field, i) => {\n              const widthStyle = widthStyles[i]\n              const isSorted = sortSpec.find(x => x[0] == field)\n              const direction = isSorted ? isSorted[1] : 0\n              return (\n                <div\n                  className=\"grid-head-cell labelColGrid\"\n                  key={field}\n                  style={widthStyle}\n                >\n                  {\n                    direction ?\n                      <span className={'sorted button-small'} onClick={delCit(delC, tag, field)} >{field}</span> :\n                      <span className={'unsorted button-small'} onClick={addCit(addC, tag, field, 1)} >{field}</span>\n                  }\n                  {\n                    direction ?\n                      <span\n                        className={`sorted button-small fa fa-arrow-${direction == 1 ? 'up' : 'down'}`}\n                        onClick={turnCit(turnC, tag, field)}\n                      /> :\n                      null\n                  }\n                </div>\n              )\n            })\n          }\n          {\n            (detailOrder || []).map((name, i) => {\n              const widthStyle = widthStyles[i]\n              return (\n                <div\n                  className=\"grid-head-cell labelColGrid\"\n                  key={name}\n                  style={widthStyle}\n                >{name}\n                </div>\n              )\n            })\n          }\n        </div>\n        {rows}\n      </div>\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getTables, getSort, getSortedData)\n\nexport default connect(getInfo, {\n  insertItem,\n  reset: resetSort, addC: addColumn, turnC: turnColumn, delC: delColumn,\n})(ListGrid)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ListGrid.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { getWinDim, columnStyle } from 'win'\n\nconst Pane = ({ format, position, children, height, width }) => (\n  <div\n    className={format}\n    style={columnStyle(position, { height, width })}\n  >\n    {children}\n  </div>\n)\n\nexport default connect(getWinDim)(Pane)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/Pane.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport { combineSelectors, memoize } from 'utils'\n\nimport { getSelect, setSearch, setPopUp, togglePopUp } from 'select'\nimport { getOptions } from 'tables'\n\nconst RelOption = ({ label, xClass, selected, onHit }) => (\n  <p\n    className={`option tag ${xClass} ${selected ? 'selected' : ''}`}\n    onClick={selected ? null : onHit}\n  >{label}</p>\n)\n\nconst handlePopUp = memoize((tag, togglePU) => () => togglePU(tag))\nconst handleSetPopUp = memoize((tag, onOff, setPU) => () => setPU(tag, onOff))\nconst handleSearch = memoize((tag, setS) => event => setS(tag, event.target.value))\nconst handleClear = memoize((tag, setS) => () => setS(tag, ''))\n\nconst removeVal = (value, onChange, val) => event => {\n  event.stopPropagation()\n  if (value.includes(val)) {\n    const newValue = value.filter(v => v != val)\n    onChange(newValue)\n  }\n}\nconst addVal = (optionLookup, multiple, value, onChange, label) => () => {\n  const { [label]: rep } = optionLookup\n  const exists = rep != null || value.includes(label)\n  if (!exists) {\n    const newValue = multiple ? [label, ...value] : label\n    onChange(newValue)\n  }\n}\nconst changeSel = (tag, multiple, value, onChange, setPU, val) => () => {\n  if (multiple) {\n    if (!value.includes(val)) {\n      const newValue = [...value, val]\n      onChange(newValue)\n    }\n  }\n  else {\n    onChange(val)\n    setPU(tag, false)\n  }\n}\n\nconst Tags = ({ tag, optionLookup, optionStyle, value, onChange, togglePU }) => (\n  <div\n    className=\"tags\"\n    onClick={handlePopUp(tag, togglePU)}\n  >{\n    (value != null && value.length) ?\n      value.map(val => {\n        const { [val]: lab = val } = optionLookup\n        const { [val]: xClass = '' } = optionStyle\n        return (\n          <span\n            key={val}\n            className=\"tag\"\n          >\n            <span\n              className={`button-tag ${xClass}`}\n              onClick={removeVal(value, onChange, val)}\n            >{'×'}</span>{' '}\n            <span>{lab}</span>\n          </span>\n        )\n      }) :\n      <span className=\"tag empty\">{'click to enter values'}</span>\n  }\n  </div>\n)\n\nconst Head = ({ optionLookup, optionStyle, value, tag, togglePU }) => {\n  let label = ''\n  const { [value]: lab = value } = optionLookup\n  const { [value]: xClass = '' } = optionStyle\n  label = lab\n  const classes = ['option-head', 'tag', xClass]\n  if (value == '') {\n    label = 'click to enter a value'\n    classes.push('new')\n  }\n  return (\n    <span\n      className={classes.join(' ')}\n      onClick={handlePopUp(tag, togglePU)}\n    >{label}</span>\n  )\n}\n\nconst Typing = ({ tag, search, setS, setPU }) => (\n  <span className=\"option-type\" >\n    <input\n      className=\"invisible\"\n      type=\"text\"\n      placeholder={'filter ...'}\n      value={search || ''}\n      onFocus={handleSetPopUp(tag, true, setPU)}\n      onChange={handleSearch(tag, setS)}\n    />\n    {search ?\n      <span\n        className=\"button-tag\"\n        onClick={handleClear(tag, setS)}\n      >{'×'}</span> : null\n    }\n  </span>\n)\n\nconst Options = ({ tag, optionLookup, optionStyle, multiple, allowNew, options, value, onChange, search, setPU }) => {\n  const pat = search.toLowerCase()\n  return (\n    <div className={'options'} >\n      {(\n        allowNew &&\n        search &&\n        !options.some(({ label }) => label == search) &&\n        !value.includes(search)\n      ) ? (\n        <span\n          className=\"new tag\"\n          onClick={addVal(optionLookup, multiple, value, onChange, search)}\n        >{search}</span>\n      ) : null}\n      {\n        options.map(({ value: val, label: lab }) => {\n          if (\n            (!multiple || !value.includes(val)) &&\n            (pat == null || pat == '' || lab == null || lab.toLowerCase().indexOf(pat) !== -1)\n          ) {\n            const { [val]: xClass = '' } = optionStyle\n            return (\n              <RelOption\n                key={val}\n                label={lab}\n                xClass={xClass}\n                selected={(multiple && value.includes(val)) || (!multiple && value == val)}\n                onHit={changeSel(tag, multiple, value, onChange, setPU, val)}\n              />\n            )\n          }\n          else {\n            return null\n          }\n        })\n      }\n    </div>\n  )\n}\n\nconst RelSelect = ({\n  tag, options, optionLookup, optionStyle = {},\n  input: { value, onChange },\n  multiple, allowNew, popUp, search, togglePU, setPU, setS,\n}) => (\n  <div\n    className={`select ${multiple ? 'multiselect' : ''}`}\n  >\n    {multiple ?\n      <Tags\n        optionLookup={optionLookup}\n        optionStyle={optionStyle}\n        value={value}\n        tag={tag}\n        togglePU={togglePU}\n        onChange={onChange}\n      /> :\n      <Head\n        optionLookup={optionLookup}\n        optionStyle={optionStyle}\n        value={value}\n        popUp={popUp}\n        tag={tag}\n        togglePU={togglePU}\n      />\n    }\n    {popUp ?\n      <Typing\n        tag={tag}\n        search={search}\n        setS={setS}\n        setPU={setPU}\n      /> : null\n    }\n    {popUp ?\n      <Options\n        tag={tag}\n        optionLookup={optionLookup}\n        optionStyle={optionStyle}\n        options={options}\n        multiple={multiple}\n        allowNew={allowNew}\n        value={value}\n        search={search}\n        setPU={setPU}\n        onChange={onChange}\n      /> : null\n    }\n  </div>\n)\n\nconst getSelectOptions = combineSelectors(getOptions, getSelect)\n\nexport default connect(getSelectOptions, { setPU: setPopUp, togglePU: togglePopUp, setS: setSearch})(RelSelect)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/RelSelect.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { withParams } from 'utils'\nimport { getMe } from 'me'\n\nimport NavLink from 'NavLink'\nimport Pane from 'Pane'\n\nconst SubApp = ({ table, me, children }) => (\n  <div>\n    <Pane format=\"nav sized\" position=\"left\">\n      <div>\n        <p><NavLink to={`/data/${table}/list`} >{'All items'}</NavLink></p>\n        {\n          me.eppn ?\n            <p><NavLink to={`/data/${table}/mylist`} >{'My work'}</NavLink></p> :\n            null\n        }\n      </div>\n    </Pane>\n    <Pane format=\"sized\" position=\"right\">\n      { children }\n    </Pane>\n  </div>\n)\n\nexport default connect(getMe)(withParams(SubApp))\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/SubApp.jsx"],"mappings":";;;;;;AAAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACgDA;;;;;;;;AChDA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;A","sourceRoot":""}