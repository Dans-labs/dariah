{"version":3,"file":"app.js","sources":["webpack:///src/js/app/dux/alter.js","webpack:///src/js/app/dux/docs.js","webpack:///src/js/app/dux/filters.js","webpack:///src/js/app/dux/forms.js","webpack:///src/js/app/dux/grid.js","webpack:///src/js/app/dux/me.js","webpack:///src/js/app/dux/notify.js","webpack:///src/js/app/dux/roots.js","webpack:///src/js/app/dux/select.js","webpack:///src/js/app/dux/tables.js","webpack:///src/js/app/dux/win.js","webpack:///src/js/app/main.jsx","webpack:///src/js/app/object/CheckboxI.jsx","webpack:///src/js/app/object/DocMd.jsx","webpack:///src/js/app/object/EUMap.jsx","webpack:///src/js/app/object/ItemContainer.jsx","webpack:///src/js/app/object/ListContainer.jsx","webpack:///src/js/app/object/ListFilter.jsx","webpack:///src/js/app/object/ListPlain.jsx","webpack:///src/js/app/object/Login.jsx","webpack:///src/js/app/object/Notification.jsx","webpack:///src/js/app/object/Window.jsx","webpack:///src/js/app/pure/Backoffice.jsx","webpack:///src/js/app/pure/Doc.jsx","webpack:///src/js/app/pure/DocHtml.jsx","webpack:///src/js/app/pure/DocPdf.jsx","webpack:///src/js/app/pure/Input.jsx","webpack:///src/js/app/pure/InputMulti.jsx","webpack:///src/js/app/pure/MarkdownArea.jsx","webpack:///src/js/app/pure/NavLink.jsx","webpack:///src/js/app/pure/NotFound.jsx","webpack:///src/js/app/pure/Root.jsx","webpack:///src/js/app/pure/Stat.jsx","webpack:///src/js/app/pure/Static.jsx","webpack:///src/js/app/state/App.jsx","webpack:///src/js/app/state/ByValue.jsx","webpack:///src/js/app/state/Facet.jsx","webpack:///src/js/app/state/FieldEdit.jsx","webpack:///src/js/app/state/FieldRead.jsx","webpack:///src/js/app/state/Filter.jsx","webpack:///src/js/app/state/Fulltext.jsx","webpack:///src/js/app/state/ItemDetailHeads.jsx","webpack:///src/js/app/state/ItemDetails.jsx","webpack:///src/js/app/state/ItemForm.jsx","webpack:///src/js/app/state/ItemRow.jsx","webpack:///src/js/app/state/ListGrid.jsx","webpack:///src/js/app/state/RelSelect.jsx","webpack:///src/js/app/state/SubApp.jsx"],"sourcesContent":["import update from 'immutability-helper'\n\nimport { memoize } from 'memo'\nimport { makeReducer } from 'utils'\nimport { handle } from 'fields'\n\n/* ACTIONS */\n\nexport const nextAlt = (alterTag, nAlts, initial) => ({ type: 'nextAlt', alterTag, nAlts, initial })\nexport const setAlt = (alterTag, alt) => ({ type: 'setAlt', alterTag, alt })\n\n/* REDUCER */\n\nconst flows = {\n  nextAlt(state, { alterTag, initial, nAlts }) {\n    const { [alterTag]: oldAlt = (initial || 0) } = state\n    const newAlt = (oldAlt + 1) % nAlts\n    return update(state, { [alterTag]: { $set: newAlt } })\n  },\n  setAlt(state, { alterTag, alt }) {\n    return update(state, { [alterTag]: { $set: alt } })\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getAlt = ({ alter }, { alterTag, initial }) => {\n  const { [alterTag]: alt = initial || 0 } = alter\n  return { alt }\n}\n\nexport const getAlts = ({ alter }) => ({ alter })\n\n/* HELPERS */\n\nexport const makeAlt = ({ alter, dispatch }, { alterTag, initial, nAlts }) => {\n  const { [alterTag]: alt = initial } = alter\n  return ({\n    alt,\n    nextAlt: handle(dispatch, nextAlt, alterTag, nAlts, initial),\n    initAlt: handle(dispatch, setAlt, alterTag, initial),\n    setAlt: memoize(alt => handle(dispatch, setAlt, alterTag, alt)),\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/alter.js","import update from 'immutability-helper'\n\nimport { accessData } from 'server'\nimport { propsChanged, makeReducer } from 'utils'\n\n/* ACTIONS */\n/*\n * Most actions call accessData, which will dispatch the ultimate fetch action.\n */\n\nexport const fetchDoc = props => {\n  const { docDir, docName, docExt } = props\n  const path = `${docDir}/${docName}.${docExt}`\n  return accessData({ type: 'fetchDoc', contentType: 'json', path, desc: `document ${docName}` })\n}\n\n/* REDUCER */\n\nconst flows = {\n  fetchDoc(state, { path, data }) {\n    if (data == null) {return state}\n    return update(state, { [path]: { $set: data } })\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getDoc = ({ docs }, { docDir, docName, docExt }) => ({\n  text: docs[`${docDir}/${docName}.${docExt}`],\n})\n\n/* HELPERS */\n\nexport const needDoc = props => (props.text == null)\n\nexport const changedDoc = (newProps, oldProps) => (\n  propsChanged(newProps, needDoc, oldProps, ['docDir', 'docName', 'docExt'])\n)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/docs.js","import merge from 'lodash/merge'\n//import update from 'immutability-helper'\nimport pickBy from 'lodash/pickby'\n\nimport { memoize } from 'memo'\nimport { makeReducer, emptyO } from 'utils'\nimport { getTables, getTable, repRelated, DETAILS } from 'tables'\n\n/* ACTIONS */\n\nexport const changeFulltext = (table, filterTag, filterId, searchString) => ({ type: 'fulltext', table, filterTag, filterId, data: searchString })\nexport const changeFacet = (table, filterTag, filterId, valueId, onOff) => ({ type: 'facet', table, filterTag, filterId, data: [valueId, onOff] })\nexport const changeFacetAll = (table, filterTag, filterId, onOff) => ({ type: 'facetAll', table, filterTag, filterId, data: onOff })\n\nexport const initFiltering = (tableData, table, filterTag, listIds) => {\n  const fieldIds = compileFieldIds(tableData, filterTag, listIds)\n  return { type: 'initFiltering', tableData, table, filterTag, fieldIds }\n}\n\n/* REDUCER */\n\nconst flows = {\n  initFiltering(state, { tableData, table, filterTag, fieldIds }) {\n    const { [table]: filterData = {} } = state\n    const defaults = initFilterSettings(tableData, filterData, filterTag, fieldIds)\n    return merge({}, state, { [table]: { [filterTag]: defaults } })\n  },\n  fulltext(state, { table, filterTag, filterId, data }) {\n    return merge({}, state, { [table]: { [filterTag]: { [filterId]: data } } })\n  },\n  facetAll(state, { table, filterTag, filterId, data }) {\n    const { [table]: { [filterTag]: { [filterId]: facets } } } = state\n    const sameSettings = {}\n    Object.keys(facets).forEach(valueId => {sameSettings[valueId] = data})\n    return merge({}, state, { [table]: { [filterTag]: { [filterId]: sameSettings } } })\n  },\n  facet(state, { table, filterTag, filterId, data }) {\n    const [valueId, filterSetting] = data\n    return merge({}, state, { [table]: { [filterTag]: { [filterId]: { [valueId]: filterSetting } } } })\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\n/* selector computers */\n\nconst gatherIds = memoize((tableData, listIds, filterFields, fieldSpecs) => {\n  const theseIds = {}\n  const { entities } = tableData\n  const records = listIds.map(eId => entities[eId].values)\n  for (const field of filterFields) {\n    const { [field]: { multiple } } = fieldSpecs\n    const valueSet = new Set()\n    for (const r of records) {\n      const { [field]: val } = r\n      if (val == null) {continue}\n      if (multiple) {for (const v of val) {valueSet.add(v)}}\n      else {valueSet.add(val)}\n    }\n    theseIds[field] = Array.from(new Set(valueSet))\n  }\n  return theseIds\n}, emptyO, { debug: 'gatherIds' })\n\nconst gatherValues = memoize((tables, fieldSpecs, fieldIds, filterField) => {\n  const { [filterField]: { valType } } = fieldSpecs\n  if (fieldIds == null) {return emptyO}\n  const fieldValues = {'': '-none-'}\n  const { values: relTable } = valType\n  fieldIds.forEach(_id => {\n    fieldValues[_id] = repRelated(tables, relTable, _id)\n  })\n  return fieldValues\n}, emptyO, { debug: 'gatherValues' })\n\nconst compileFieldIds = memoize((tableData, filterTag, listIds) => {\n  if (tableData == null) {return emptyO}\n  const { valueLists, fields, filterList, fieldSpecs } = tableData\n  if (filterList == null) {return emptyO}\n  const presentFilterList = filterList.filter(x => fields[x.field])\n  const filterFields = presentFilterList.filter(x => x.type !== 'Fulltext').map(x => x.field)\n  const these = filterTag.startsWith(DETAILS)\n  return these\n  ? gatherIds(tableData, listIds, filterFields, fieldSpecs)\n  : pickBy(valueLists, (value, key) => filterFields.includes(key))\n}, emptyO, { debug: 'compileFieldIds' })\n\nconst initFilterSettings = memoize((tableData, filterData, filterTag, fieldIds) => {\n  if (tableData == null) {return emptyO}\n  const { fields, filterList } = tableData\n  if (filterList == null) {return emptyO}\n  const { [filterTag]: filterSettings = emptyO } = filterData || emptyO\n  const presentFilterList = filterList.filter(x => fields[x.field])\n  const newFilterSettings = {}\n  presentFilterList.forEach((filterSpec, filterId) => {\n    const { [filterId]: filterSetting } = filterSettings\n    if (filterSpec.type == 'Fulltext') {\n      if (filterSetting == null) {newFilterSettings[filterId] = ''}\n    }\n    else {\n      const theFacets = filterSetting || emptyO\n      const newFacets = {}\n      fieldIds[filterSpec.field].forEach(valueId => {\n        if (theFacets[valueId] == null) {newFacets[valueId] = true}\n      })\n      if (theFacets[''] == null) {newFacets[''] = true}\n      if (Object.keys(newFacets).length) {newFilterSettings[filterId] = newFacets}\n    }\n  })\n  return newFilterSettings\n}, emptyO, { debug: 'initFilterSettings' })\n\nconst computeFiltering = memoize((tables, table, listIds, fieldIds, filterSettings) => {\n  if (filterSettings == null) {return emptyO}\n  const { [table]: { entities, fields, fieldSpecs, filterList } } = tables\n  if (filterList == null) {return { filteredIds: listIds }}\n  const presentFilterList = filterList.filter(x => fields[x.field])\n\n  const filterChecks = {}\n\n  const makeFilterCheck = (filterSpec, filterId) => {\n    const { [filterId]: filterSetting } = filterSettings\n    const { field } = filterSpec\n    const { [field]: fieldSpec } = fieldSpecs\n    const filterCheck = filterSpec.type === 'Fulltext' ? fulltextCheck : facetCheck\n    filterChecks[filterId] = filterCheck(tables, field, fieldSpec, filterSetting)\n  }\n\n  const otherFilteredIds = {}\n  presentFilterList.forEach((filterSpec, filterId) => {\n    makeFilterCheck(filterSpec, filterId)\n    otherFilteredIds[filterId] = []\n  })\n  const filteredIds = []\n\n  for (const eId of listIds) {\n    const { [eId]: entity } = entities\n    let theOneFail = null\n    let v = true\n    let discard = false\n    Object.entries(filterChecks).forEach(([filterId, filterCheck]) => {\n      if (!discard) {\n        const pass = filterCheck(entity)\n        if (!pass) {\n          v = false\n          if (theOneFail === null) {theOneFail = filterId}\n          else {discard = true}\n        }\n      }\n    })\n    if (!discard) {\n      if (v) {\n        filteredIds.push(eId)\n        presentFilterList.forEach((filterSpec, filterId) => {\n          otherFilteredIds[filterId].push(eId)\n        })\n      }\n      else {otherFilteredIds[theOneFail].push(eId)}\n    }\n  }\n  const amounts = {}\n  presentFilterList.forEach(({ field, type }, filterId) => {\n    const { [field]: fieldSpec } = fieldSpecs\n    amounts[filterId] = type === 'Fulltext'\n    ? null\n    : countFacets(tables, field, fieldSpec, fieldIds[field], otherFilteredIds[filterId], entities)\n  })\n  const filteredAmountOthers = {}\n  Object.entries(otherFilteredIds).forEach(([filterId, x]) => {\n    filteredAmountOthers[filterId] = x.length\n  })\n  return {\n    filteredIds,\n    filteredAmountOthers,\n    amounts,\n  }\n}, emptyO, { debug: 'computeFiltering' })\n\n/* selectors for export */\n\nexport const getFieldValues = (state, { table, filterTag, listIds, filterField }) => {\n  const { tables } = getTables(state)\n  const { tableData } = getTable(state, { table })\n  if (tableData == null) {return emptyO}\n  const { fieldSpecs } = tableData\n  const fieldIds = compileFieldIds(tableData, filterTag, listIds)[filterField]\n\n  return { fieldValues: gatherValues(tables, fieldSpecs, fieldIds, filterField) }\n}\n\nexport const getFilterSetting = ({ filters }, { table, filterTag, filterId }) => {\n  const { [table]: filterData } = filters\n  if (filterData == null) {return emptyO}\n  const { [filterTag]: filterSettings = emptyO } = filterData\n  const { [filterId]: filterSetting } = filterSettings\n  return { filterSetting }\n}\n\nexport const getFiltersApplied = (state, { table, filterTag, listIds }) => {\n  const { tableData } = getTable(state, { table })\n  const { filters: { [table]: filterData = emptyO } } = state\n  if (tableData == null) {return emptyO}\n  const fieldIds = compileFieldIds(tableData, filterTag, listIds)\n  const { [filterTag]: filterSettings } = filterData\n  if (filterSettings == null) {return { tableData }}\n  const { tables } = getTables(state)\n  return {\n    tableData,\n    filterSettings,\n    ...computeFiltering(tables, table, listIds, fieldIds, filterSettings),\n  }\n}\n\n/* HELPERS */\n\nexport const makeTag = (select, masterId, linkField) => masterId == null\n? select\n: `${select}-${masterId}-${linkField}`\n\nconst getUnpack = (tables, fieldSpec, asString = false) => {\n  const { valType, multiple } = fieldSpec\n  let unpack\n  if (typeof valType == 'string') {\n    unpack = multiple\n    ? asString\n      ? v => v == null\n        ? ''\n        : v.join(' ')\n      : v => v == null\n        ? []\n        : v\n    : asString\n      ? v => v == null\n        ? ''\n        : v\n      : v => v == null\n        ? []\n        : [v]\n  }\n  else {\n    const { values: relTable } = valType\n    unpack = multiple\n    ? asString\n      ? v => v == null\n        ? ''\n        : v.map(v => repRelated(tables, relTable, v).join(' '))\n    : v => v == null\n      ? []\n      : v\n  : asString\n    ? v => v == null\n      ? ''\n      : repRelated(tables, relTable, v)\n    : v => v == null\n      ? []\n      : [v]\n  }\n  return unpack\n}\n\nconst fulltextCheck = memoize((tables, field, fieldSpec, term) => {\n  const unpack = getUnpack(tables, fieldSpec, true)\n  const search = term.toLowerCase()\n  if (search == null || search == '') {\n    return () => true\n  }\n  return entity => {\n    const { values: { [field]: val } } = entity\n    const rep = unpack(val)\n    return rep != null && rep.toLowerCase().indexOf(search) !== -1\n  }\n}, emptyO, { debug: fulltextCheck })\n\nconst facetCheck = memoize((tables, field, fieldSpec, facetSettings) => {\n  const unpack = getUnpack(tables, fieldSpec)\n  if (facetSettings.size === 0) {\n    return () => false\n  }\n  return entity => {\n    const { values: { [field]: val } } = entity\n    const rep = unpack(val)\n    if (rep.length == 0) {\n      return facetSettings['']\n    }\n    for (const r of rep) {\n      if (facetSettings[r]) {\n        return true\n      }\n    }\n    return false\n  }\n}, emptyO, { debug: facetCheck })\n\nconst countFacets = memoize((tables, field, fieldSpec, fieldIds, filteredIds, entities) => {\n  const unpack = getUnpack(tables, fieldSpec)\n  const facetAmounts = {}\n  fieldIds.forEach(_id => {facetAmounts[_id] = 0})\n  for (const eId of filteredIds) {\n    const { [eId]: { values: { [field]: val } } } = entities\n    const rep = unpack(val)\n    if (rep.length == 0) {\n      facetAmounts[''] += 1\n    }\n    else {\n      for (const r of rep) {\n        facetAmounts[r] += 1\n      }\n    }\n  }\n  return facetAmounts\n}, emptyO, { debug: 'countFacets' })\n\nconst INTL = new Intl.Collator('en', { sensitivity: 'base' })\nconst sortEntries = (x, y) => INTL.compare(x[1], y[1])\n\nexport const placeFacets = memoize((fieldValues, maxCols) => {\n  if (fieldValues == null) {return []}\n  const facets = Object.entries(fieldValues).sort(sortEntries)\n  if (facets.length == 0) {return []}\n  const rows = []\n  const { length: lf } = facets\n  const nrows = Math.floor(lf / maxCols) + (lf % maxCols ? 1 : 0)\n  const ncols = Math.floor(lf / nrows) + (lf % nrows ? 1 : 0)\n  for (let r = 0; r < nrows; r++) {\n    const row = []\n    for (let c = 0; c < ncols; c++) {\n      const f = nrows * c + r\n      row.push(f < lf ? facets[f] : null)\n    }\n    rows.push(row)\n  }\n  return rows\n}, emptyO, { debug: 'placeFacets' })\n\nexport const testAllChecks = filterSetting => {\n  let allTrue = true\n  let allFalse = true\n  if (filterSetting == null) {return { allTrue, allFalse }}\n  for (const valueEntry of Object.entries(filterSetting)) {\n    if (valueEntry[1]) {allFalse = false}\n    else {allTrue = false}\n  }\n  return { allTrue, allFalse }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/filters.js","/* ACTIONS */\n\n/* REDUCER */\n\n/* SELECTORS */\n\nexport const getForms = ({ form }) => ({ forms: form })\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/forms.js","import orderBy from 'lodash/orderby'\nimport mapValues from 'lodash/mapvalues'\nimport createCachedSelector from 're-reselect'\nimport { makeReducer, emptyA, emptyO } from 'utils'\n\nimport { getTables, repr } from 'tables'\n\n/* ACTIONS */\n\nexport const resetSort = gridTag => ({ type: 'resetSort', gridTag })\nexport const addColumn = (gridTag, column, direction) => ({ type: 'addColumn', gridTag, column, direction })\nexport const turnColumn = (gridTag, column) => ({ type: 'turnColumn', gridTag, column })\nexport const delColumn = (gridTag, column) => ({ type: 'delColumn', gridTag, column })\n\n/* REDUCER */\n\nconst flows = {\n  resetSort(state, { gridTag }) {\n    return { ...state, [gridTag]: emptyA }\n  },\n  addColumn(state, { gridTag, column, direction }) {\n    const { [gridTag]: sortSpec } = state\n    return { ...state, [gridTag]: (sortSpec || emptyA).filter(x => x[0] != column).concat([[column, direction]]) }\n  },\n  delColumn(state, { gridTag, column }) {\n    const { [gridTag]: sortSpec } = state\n    return { ...state, [gridTag]: (sortSpec || emptyA).filter(x => x[0] != column) }\n  },\n  turnColumn(state, { gridTag, column }) {\n    const { [gridTag]: sortSpec } = state\n    return { ...state, [gridTag]: (sortSpec || emptyA).map(x => [x[0], x[0] == column ? -x[1] : x[1]]) }\n  },\n}\n\nexport default makeReducer(flows, emptyO)\n\n/* SELECTORS */\n\n/* selector computers */\n\nconst reprX = (tables, table) => {\n  const { [table]: { fieldSpecs } } = tables\n  return (myValues, field) => {\n    if (field == '_id') {return myValues}\n    const { [field]: { valType, multiple } } = fieldSpecs\n    return multiple\n    ? (myValues || emptyA).map(value => repr(tables, table, valType, value)).join('|')\n    : repr(tables, table, valType, myValues)\n  }\n}\n\nconst sortData = ({ tables }, { table, listIds, sortSpec }) => {\n  const sortColumns = sortSpec.map(x => x[0])\n  const sortDirs = sortSpec.map(x => x[1] == 1 ? 'asc' : 'desc')\n  const { [table]: { entities } } = tables\n  const r = reprX(tables, table)\n  const fullData = listIds.map(_id => mapValues(entities[_id].values, r))\n  return { sortedData: orderBy(fullData, sortColumns, sortDirs).map(x => x._id) }\n}\n\n/* selectors for export */\n\nexport const getSort = ({ grid }, { table, gridTag, listIds }) => ({ table, gridTag, listIds, sortSpec: grid[gridTag] || emptyA })\n\nexport const getSortedData = createCachedSelector(\n  getTables,\n  getSort,\n  sortData,\n)((state, { gridTag }) => gridTag)\n\n/* HELPERS */\n\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/grid.js","import { accessData } from 'server'\nimport { makeReducer, emptyO } from 'utils'\n\n/* ACTIONS */\n/*\n * Most actions call accessData, which will dispatch the ultimate fetch action.\n */\nexport const fetchMe = () => (\n  accessData({ type: 'fetchMe', contentType: 'db', path: '/who/ami', desc: 'me' })\n)\n\n/* REDUCER */\n\nconst flows = {\n  fetchMe(state, { data }) {\n    if (data == null) {return emptyO}\n    return { ...data }\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getMe = ({ me }) => ({ me })\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/me.js","import mergeWith from 'lodash/mergewith'\nimport { makeReducer, emptyA } from 'utils'\n\n/* ACTIONS */\n\nexport const notify = msgs => ({ type: 'msgs', msgs })\nexport const clear = () => ({ type: 'clear' })\nexport const display = onOff => ({ type: 'display', onOff })\n\n/* REDUCER */\n\nconst subFlows = {\n  pending(state, { desc, busy, extraMsgs }) {\n    return mergeWith({}, state, {\n      notes: [\n        ...extraMsgs,\n        { kind: 'special', text: `waiting for ${desc}`},\n      ],\n      busy: busy + 1,\n    }, addItems)\n  },\n  success(state, { desc, busy, extraMsgs }) {\n    return mergeWith({}, state, {\n      notes: [\n        ...extraMsgs,\n        { kind: 'info', text: `${desc} ok` },\n      ],\n      busy: busy - 1,\n    }, addItems)\n  },\n  error(state, { desc, busy, extraMsgs }) {\n    return mergeWith({}, state, {\n      notes: [\n        ...extraMsgs,\n        { kind: 'error', text: `${desc} failed` },\n      ],\n      busy: busy - 1,\n      show: true,\n    }, addItems)\n  },\n}\n\nconst flows = {\n  async(state, { msgs, status, desc }) {\n    const { busy } = state\n    const extraMsgs = msgs || emptyA\n    const { [status]: subFlow } = subFlows\n    return subFlow\n    ? subFlow(state, { extraMsgs, desc, busy })\n    : state\n  },\n  msgs(state, { msgs }) {\n    return mergeWith({}, state, {\n      notes: [\n        ...msgs,\n      ],\n      show: true,\n    }, addItems)\n  },\n  clear(state) {\n    return {\n      ...state,\n      notes: emptyA,\n      show: false,\n    }\n  },\n  display(state, { onOff }) {\n    return {\n      ...state,\n      show: onOff,\n    }\n  },\n}\n\nexport default makeReducer(flows, { notes: emptyA, busy: 0, show: false })\n\n/* SELECTORS */\n\nexport const getNotifications = ({ notify }) => {\n  const { notes, busy, show } = notify\n  let lastNote = -1\n  let lastKind = ''\n  notes.forEach((note, i) => {\n    const { kind } = note\n    if (kind == 'error') {\n      lastNote = i\n      lastKind = 'error'\n    }\n    else if (kind == 'warning') {\n      if (lastKind != 'error') {\n        lastNote = i\n        lastKind = 'warning'\n      }\n    }\n  })\n  return { notifications: notes, busy, show, lastMsg: notes.length - 1, lastNote, lastKind }\n}\n\n/* HELPERS */\n\nconst addItems = (objValue, srcValue, key) => {\n  if (key == 'notes') {\n    return objValue == null ? srcValue : objValue.concat(srcValue)\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/notify.js","import { combineReducers, createStore, applyMiddleware } from 'redux'\nimport thunkMiddleware from 'redux-thunk'\nimport { reducer as form } from 'redux-form'\n\nimport win from 'win'\nimport notify from 'notify'\nimport docs from 'docs'\nimport tables from 'tables'\nimport me from 'me'\nimport filters from 'filters'\nimport alter from 'alter'\nimport select from 'select'\nimport grid from 'grid'\n\n/* ACTIONS */\n\n/* global process */\n/* global require */\n\n/* actions to ignore in logging and in the redux dev tool\n * Mainly used for actions generated by third party libraries, such as redux-form\n */\n\nconst predicate = (state, action) => !action.type.startsWith('@@redux-form')\n\n//const predicate = () => true // if you want to see all actions\n\nconst configureStore = reducer => {\n  let store\n  if (process.env.NODE_ENV === `development`) {\n    const { createLogger } = require(`redux-logger`)\n    const { composeWithDevTools } = require('redux-devtools-extension')\n    const composeEnhancers = composeWithDevTools({ predicate })\n    store = createStore(\n      reducer,\n      composeEnhancers(\n        applyMiddleware(\n          thunkMiddleware,\n          createLogger({ predicate }),\n        )\n      )\n    )\n  }\n  else {\n    store = createStore(\n      reducer,\n      applyMiddleware(\n        thunkMiddleware,\n      )\n    )\n  }\n  return store\n}\n\n/* REDUCER */\n\nexport default configureStore(combineReducers({\n  win,\n  notify,\n  docs,\n  tables,\n  me,\n  filters,\n  alter,\n  form,\n  select,\n  grid,\n}))\n\n/* SELECTORS */\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/roots.js","import update from 'immutability-helper'\nimport { makeReducer, emptyO } from 'utils'\n\n/* DEFINITIONS */\n\nconst initSelect = { search: '', popUp: false }\n\n/* ACTIONS */\n\nexport const setSearch = (selectTag, search) => ({ type: 'setSearch', selectTag, search })\nexport const setPopUp = (selectTag, onOff) => ({ type: 'setPopUp', selectTag, onOff })\nexport const togglePopUp = selectTag => ({ type: 'togglePopUp', selectTag })\n\n/* REDUCER */\n\nconst flows = {\n  setSearch(state, { selectTag, search }) {\n    return update(state, {\n      [selectTag]: {\n        $apply: st => update(st || initSelect, { search: { $set: search } }),\n      },\n    })\n  },\n  setPopUp(state, { selectTag, onOff }) {\n    return update(state, {\n      [selectTag]: {\n        $apply: st => update(st || initSelect, { popUp: { $set: onOff } }),\n      },\n    })\n  },\n  togglePopUp(state, { selectTag }) {\n    const { [selectTag]: myState } = state\n    const newOnOff = myState == null ? true : !myState.popUp\n    return update(state, {\n      [selectTag]: {\n        $apply: st => update(st || initSelect, { popUp: { $set: newOnOff } }),\n      },\n    })\n  },\n}\n\nexport default makeReducer(flows, emptyO)\n\n/* SELECTORS */\n\nexport const getSelect = ({ select }, { selectTag }) => ({ ...(select[selectTag] || emptyO) })\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/select.js","import { combineReducers } from 'redux'\nimport update from 'immutability-helper'\nimport { createSelector } from 'reselect'\n\nimport { accessData } from 'server'\nimport { memoize } from 'memo'\nimport { makeReducer, updateAuto, emptyA, emptyO } from 'utils'\n\n/* DEFS */\n\nexport const DETAILS = 'details'\nexport const ALLIDS = 'allIds'\nexport const MYIDS = 'myIds'\n\n/* ACTIONS */\n/*\n * Most actions call accessData, which will dispatch the ultimate fetch action.\n */\n\nexport const fetchTable = (table, select = ALLIDS, grid) => accessData({\n  type: 'fetchTable',\n  contentType: 'db',\n  path: `/${select == 'myIds' ? 'my' : ''}list?table=${table}&grid=${grid}`,\n  desc: `${table} table`,\n  table,\n})\n\nexport const fetchItem = (table, eId) => accessData({\n  type: 'fetchItem',\n  contentType: 'db',\n  path: `/view?table=${table}&id=${eId}`,\n  desc: `${table} record ${eId}`,\n  table,\n})\n\nexport const modItem = (table, eId, values) => accessData({\n  type: 'modItem',\n  contentType: 'db',\n  path: `/mod?table=${table}&action=update`,\n  desc: `${table} update record ${eId}`,\n  sendData: { _id: eId, values },\n  table,\n})\n\nexport const insertItem = (table, select = ALLIDS, masterId = null, linkField = null) => accessData({\n  type: 'insertItem',\n  contentType: 'db',\n  path: `/mod?table=${table}&action=insert`,\n  desc: `${table} insert new record`,\n  sendData: { masterId, linkField },\n  table,\n  select,\n})\n\nexport const delItem = (table, eId) => accessData({\n  type: 'delItem',\n  contentType: 'db',\n  path: `/mod?table=${table}&action=delete`,\n  desc: `${table} delete record ${eId}`,\n  sendData: { _id: eId },\n  table,\n})\n\n/* REDUCER */\n\nconst updateItemWithFieldsNew = (state, table, _id, fields, values) => {\n  const newVals = {}\n  fields.forEach(field => {newVals[field] = values[field]})\n  return updateAuto(\n    state,\n    [table, 'entities', _id, 'values'],\n    { $merge: newVals },\n  )\n}\nconst updateItemWithFields = (state, table, _id, fields, values) => update(state, {\n  [table]: {\n    $apply: t => update(t || {}, {\n      entities: {\n        $apply: e => update(e || {}, {\n          [_id]: {\n            $apply: i => update(i || {}, {\n              values: {\n                $apply: vals => {\n                  let newVals = vals || {}\n                  fields.forEach(field => {\n                    newVals = update(newVals, {\n                      [field]: {\n                        $apply: val => {\n                          const newVal = values[field]\n                          return JSON.stringify(val) == JSON.stringify(newVal) ? val : newVal\n                        },\n                      },\n                    })\n                  })\n                  return newVals\n                },\n              },\n            }),\n          },\n        }),\n      },\n    }),\n  },\n})\n\nconst updateItemValues = (state, table, _id, values) => update(state, {\n  [table]: {\n    $apply: t => update(t || {}, {\n      entities: {\n        $apply: e => update(e || {}, {\n          [_id]: {\n            $apply: i => update(i || {}, {\n              values: { $set: values },\n            }),\n          },\n        }),\n      },\n    }),\n  },\n})\n\nconst updateItemWhole = (state, table, _id, data) => update(state, {\n  [table]: {\n    $apply: t => update(t || {}, {\n      entities: {\n        $apply: e => update(e || {}, {\n          [_id]: { $set: data },\n        }),\n      },\n    }),\n  },\n})\n\nconst flowsCore = {\n  fetchTable(state, { data }) {\n    if (data == null) {return state}\n    const { core } = data\n    return core == null ? state : update(state, { $merge: core })\n  },\n  fetchItem(state, { data, table }) {\n    if (data == null) {return state}\n    const { [table]: tableData } = state\n    const { fields } = tableData\n    const { values, values: { _id } } = data\n    const useFields = ['_id', ...Object.keys(fields)]\n    return updateItemWithFields(state, table, _id, useFields, values)\n  },\n  modItem(state, { data, table }) {\n    if (data == null) {return state}\n    const { newValues } = data\n    const { [table]: tableData } = state\n    const { fields } = tableData\n    const { values, values: { _id } } = data\n    const useFields = ['_id', ...Object.keys(fields)]\n    let newState = updateItemWithFields(state, table, _id, useFields, values)\n    const useRelFields = ['_id', 'rep']\n    if (newValues != null) {\n      for (const { _id, rep, relTable, field } of newValues) {\n        newState = updateItemWithFields(state, relTable, _id, useRelFields, { _id, rep })\n        newState = update(newState, { [table]: { valueLists: { [field]: { $unshift: [_id] } } } })\n      }\n    }\n    return newState\n  },\n  insertItem(state, { data, table, select }) {\n    if (data == null) {return state}\n    const { [table]: tableData } = state\n    const { fields } = tableData\n    const { values, values: { _id } } = data\n    const useFields = ['_id', ...Object.keys(fields)]\n    let newState = updateItemWithFields(state, table, _id, useFields, values)\n    newState = updateAuto(newState, [table, ALLIDS], { $unshift: [_id] }, true)\n    if (select == MYIDS) {\n      newState = updateAuto(newState, [table, MYIDS], { $unshift: [_id] }, true)\n    }\n    return update(newState, {\n      [table]: {\n        lastInserted: { $set: _id },\n      },\n    })\n  },\n  delItem(state, { data, table }) {\n    if (data == null) {return state}\n    const { [table]: { myIds, allIds } } = state\n    const _id = data\n    let newState = update(state, { [table]: { entities: { $unset: [_id] } } })\n    Object.entries({ myIds, allIds }).forEach(([name, list]) => {\n      if (list != null) {\n        const otherIds = list.filter(x => x != _id)\n        newState = update(newState, { [table]: { [name]: { $set: otherIds } } })\n      }\n    })\n    return newState\n  },\n}\n\nconst flowsMore = {\n  fetchTable(state, { data }) {\n    if (data == null) {return state}\n    const { more } = data\n    return more == null ? state : update(state, { $merge: more })\n  },\n  fetchItem(state, { data, table }) {\n    if (data == null) {return state}\n    const { values: { _id } } = data\n    return updateItemWhole(state, table, _id, data)\n  },\n  modItem(state, { data, table }) {\n    if (data == null) {return state}\n    const { values, values: { _id } } = data\n    return updateItemValues(state, table, _id, values)\n  },\n  insertItem(state, { data, table }) {\n    if (data == null) {return state}\n    const { values: { _id } } = data\n    return updateItemWhole(state, table, _id, data)\n  },\n  delItem(state, { data, table }) {\n    if (data == null) {return state}\n    const _id = data\n    return update(state, { [table]: { entities: { $unset: [_id] } } })\n  },\n}\n\nconst core = makeReducer(flowsCore, emptyO)\nconst more = makeReducer(flowsMore, emptyO)\nexport default combineReducers({ core, more })\n\n/* SELECTORS */\n\nexport const getTables = ({ tables }) => ({ tables: tables.core })\n\nexport const getTable = ({ tables }, { table }) => ({ tableData: tables.core[table] })\nexport const getTableMore = ({ tables }, { table }) => ({ tableData: tables.more[table] })\n\nexport const getTableFilters = ({ tables }, { table }) => {\n  const { core: { [table]: { fields, filterList } } } = tables\n  return { fields, filterList }\n}\n\nexport const getValueList = ({ tables }, { table, field }) => {\n  const { core: { [table]: { valueLists, fieldSpecs } } } = tables\n  const { [field]: { valType } } = fieldSpecs\n  if (valueLists == null) {\n    return { valType, table }\n  }\n  const { [field]: valueList } = valueLists\n  return { valType, valueList, table }\n}\n\nconst computeOptions = ({ tables }, { valType, valueList, table }) => {\n  if (valueList == null) {\n    return { options: emptyA, optionLookup: emptyO }\n  }\n  const options = valueList.map(val => ({ value: val, label: repr(tables, table, valType, val) }))\n  const optionLookup = {}\n  options.forEach(({ value: val, label: lab }) => {optionLookup[val] = lab})\n  return { options, optionLookup }\n}\n\nexport const getOptions = createSelector(\n  getTables,\n  getValueList,\n  computeOptions,\n)\n\n/* HELPERS */\n\nexport const toDb = memoize((table, eId, dispatch) => values => dispatch(modItem(table, eId, values)))\n\nconst hasTableKey = (tables, table, key, value = null) => {\n  if (tables == null) {return false}\n  const { [table]: tableData } = tables\n  if (tableData == null) {return false}\n  return tableData[key] != null && (value == null || tableData[key] == value)\n}\n\nexport const needTables = (tables, table, select = ALLIDS, complete) => {\n  if (!hasTableKey(tables, table, select)) {return true}\n  if (complete && !hasTableKey(tables, table, 'complete', true)) {return true}\n  const { [table]: fieldSpecs } = tables\n  const relTables = Array.from(\n    new Set(\n      Object.entries(fieldSpecs).\n      filter(entry => ((typeof entry[1].valType) == 'object') && entry[1].valType.values != null).\n      map(entry => entry[1].valType.values)\n    )\n  )\n  return relTables.some(relTable => !hasTableKey(tables, relTable, ALLIDS))\n}\n\nexport const needValues = ({ tableData, eId }) => (\n  tableData == null\n  || tableData.entities[eId] == null\n)\n\nexport const listValues = memoize(({ tables, table, eId, field }) => (\n  tables == null\n  ? emptyA\n  : tables[table] == null\n    ? emptyA\n    : tables[table].entities[eId] == null\n      ? emptyA\n      : new Set(tables[table].entities[eId][field])\n), emptyO)\n\nconst repUser = memoize((tables, valId) => {\n  let valRep\n  const { user: { entities: { [valId]: entity } } } = tables\n  if (entity) {\n    const { values: { eppn, firstName, lastName, emailPre, authority, mayLogin } } = entity\n    const email = emailPre || ''\n    let linkText = [firstName || '', lastName || ''].filter(x => x).join(' ')\n    if (linkText == '') {linkText = email}\n    const namePart = linkText && email\n    ? `[${linkText}](mailto:${email})`\n    : linkText + email\n    const eppnPart = eppn ? ` eppn=${eppn} ` : ''\n    const authorityPart = authority ? ` authenticated by=${authority} ` : ''\n    const mayLoginPart = mayLogin ? ` active=${mayLogin} ` : ''\n    valRep = [namePart, eppnPart, authorityPart, mayLoginPart].filter(x => x).join('; ')\n  }\n  else {valRep = 'UNKNOWN'}\n  return valRep\n})\n\nconst repCountry = (tables, valId) => {\n  const { country: { entities: { [valId]: entity } } } = tables\n  if (entity) {\n    const { values: { name, iso } } = entity\n    return `${iso}: ${name}`\n  }\n  else {return 'UNKNOWN'}\n}\n\nconst repValue = relTable => (tables, valId) => {\n  const { [relTable]: { title, entities: { [valId]: entity } } } = tables\n  const useTitle = title || 'rep'\n  if (entity) {\n    const { values: { [useTitle]: rep } } = entity\n    return rep\n  }\n  else {return 'UNKNOWN'}\n}\n\nconst repMap = {\n  user: repUser,\n  country: repCountry,\n  default: repValue,\n}\n\nexport const repRelated = (tables, relTable, valId) => (repMap[relTable] || repMap.default(relTable))(tables, valId)\n\nconst trimDate = text => (text == null ? '' : text.replace(/\\.[0-9]+/, ''))\n\nexport const repr = (tables, table, valType, value) => {\n  if (value == null) {return ''}\n  if (typeof valType == 'string') {\n    switch (valType) {\n      case 'datetime': return trimDate(value)\n      case 'bool': return value ? 'Yes' : 'No'\n      default: return value\n    }\n  }\n  else {\n    const { values: relTable } = valType\n    return repRelated(tables, relTable, value)\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/tables.js","import { makeReducer } from 'utils'\n\n/* ACTIONS */\n\nexport const changeWinDim = () => dispatch => {\n  dispatch({ type: 'windim', ...initWinDim() })\n}\n\n/* REDUCER */\n\nconst flows = {\n  windim(state, { height, width }) {return { height, width }},\n}\n\nconst initWinDim = () => {\n  const { innerHeight: height, innerWidth: width } = window\n  return { height, width }\n}\n\nexport default makeReducer(flows, initWinDim())\n\n/* SELECTORS */\n\nexport const getWinDim = ({ win: { height, width } }) => ({ height, width })\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/win.js","import React from 'react'\nimport { render } from 'react-dom'\nimport { Router, Route, Redirect, IndexRoute, IndexRedirect, browserHistory } from 'react-router'\n\nimport { ALLIDS, MYIDS } from 'tables'\n\nimport Root from 'Root'\nimport App from 'App'\nimport SubApp from 'SubApp'\nimport Backoffice from 'Backoffice'\nimport ListContainer from 'ListContainer'\nimport Doc from 'Doc'\nimport NotFound from 'NotFound'\n\nrender(\n  <Root>\n    <Router history={browserHistory}>\n      <Redirect from=\"/about\" to=\"/docs/about.md\" />\n      <Redirect from=\"/docs/about\" to=\"/docs/about.md\" />\n      <Redirect from=\"/about.md\" to=\"/docs/about.md\" />\n      <Redirect from=\"/login\" to=\"/docs/about.md\" />\n      <Redirect from=\"/logout\" to=\"/docs/about.md\" />\n      <Redirect from=\"/slogout\" to=\"/docs/about.md\" />\n      <Route path=\"/\" component={App} >\n        <IndexRoute component={App} />\n        <IndexRedirect to=\"/docs/about.md\" />\n        <Route path=\"docs/:docFile\" component={Doc} />\n        <Route path=\"tech/docs/gen/:docFile\" component={Doc} />\n        <Route path=\"tech/docs/:docFile\" component={Doc} />\n        <Route path=\"data\" >\n          <Route path=\":table\" component={SubApp} >\n            <Route path=\"list\" component={ListContainer} select={ALLIDS} mode={'list'} filtered={true} />\n            <Route path=\"mylist\" component={ListContainer} select={MYIDS} mode={'list'} />\n          </Route>\n        </Route>\n        <Route path=\"backoffice\" component={Backoffice} >\n          <Route path=\":table\" >\n            <Route path=\"grid\" component={ListContainer} select={ALLIDS} mode={'grid'} />\n            <Route path=\"list\" component={ListContainer} select={ALLIDS} mode={'list'} />\n          </Route>\n        </Route>\n      </Route>\n      <Route path=\"*\" component={NotFound} />\n    </Router>\n  </Root>\n  ,\n  document.getElementById('body')\n)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/main.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { changeFacetAll, getFilterSetting, testAllChecks } from 'filters'\n\nconst indeterminate = states => !states.allTrue && !states.allFalse\n\nclass CheckboxI extends Component {\n  componentDidUpdate() {\n    const { props: { filterSetting } } = this\n    const states = testAllChecks(filterSetting)\n    this.dom.indeterminate = indeterminate(states)\n  }\n  handleCheck = () => {\n    const { props: {filterSetting, table, filterTag, filterId, dispatch } } = this\n    const states = testAllChecks(filterSetting)\n    return dispatch(changeFacetAll(table, filterTag, filterId, this.dom.indeterminate || !states.allTrue))\n  }\n  setIndeterminate = domElem => {\n    const { props: { filterSetting } } = this\n    const states = testAllChecks(filterSetting)\n    if (domElem) {\n      this.dom = domElem\n      domElem.indeterminate = indeterminate(states)\n    }\n  }\n  render() {\n    const { props: { filterSetting } } = this\n    const states = testAllChecks(filterSetting)\n    return (\n      <input\n          ref={this.setIndeterminate}\n          type=\"checkbox\"\n          checked={states.allTrue}\n          onChange={this.handleCheck}\n      />\n    )\n  }\n}\n\nexport default connect(getFilterSetting)(CheckboxI)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/CheckboxI.jsx","import React, {Component} from 'react'\nimport { connect } from 'react-redux'\nimport Markdown from 'react-markdown'\nimport { Link } from 'react-router'\n\nimport { combineSelectors } from 'utils'\n\nimport { getDoc, needDoc, changedDoc, fetchDoc } from 'docs'\nimport { getAlts, makeAlt } from 'alter'\nconsole.warn('DOC getAlts', getAlts)\n\nconst RouterLink = ({ children, href }) => (\n  href.match(/^(https?:)?\\/\\//)\n  ? <a href={href} >{children}</a>\n  : <Link to={href} >{children}</Link>\n)\nconst renderers = { Link: RouterLink }\n\nclass DocMd extends Component {\n  render() {\n    const {props, props: { docName, text } } = this\n    if (needDoc({ text })) {return <div>{`No document ${docName}`}</div>}\n\n    const { alt, nextAlt } = makeAlt(props, {\n      alterTag: docName,\n      nAlts: 2,\n      initial: 0,\n    })\n    return (\n      <div style={{paddingLeft: '0.5em'}} >\n        <p style={{float: 'right'}} >\n          <a\n            href=\"#\"\n            className={`control fa fa-${alt == 0 ? 'hand-o-down' : 'file-code-o'}`}\n            title={`${alt == 0 ? 'markdown source' : 'formatted'}`}\n            onClick={nextAlt}\n          />\n        </p>\n        {\n          alt == 0\n          ? <div>\n              <Markdown\n                source={text}\n                renderers={renderers}\n              />\n            </div>\n          : <div>\n              <pre className=\"md-source\" >{text}</pre>\n            </div>\n        }\n      </div>\n    )\n  }\n  componentDidMount() {\n    const { props, props: {dispatch } } = this\n    dispatch(fetchDoc(props))\n  }\n  componentDidUpdate(prevProps) {\n    const { props, props: {dispatch } } = this\n    if (changedDoc(props, prevProps)) {\n      dispatch(fetchDoc(props))\n    }\n  }\n}\n\nconst getInfo = combineSelectors(getDoc, getAlts)\n\nexport default connect(getInfo)(DocMd)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/DocMd.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport L from 'leaflet'\n\nimport {countryBorders} from 'europe.geo'\nimport { getFilterSetting } from 'filters'\nimport { getTables } from 'tables'\nimport { combineSelectors, emptyO } from 'utils'\n\nimport ByValue from 'ByValue'\n\nconst mapOptions = {\n  HEIGHT: 250,\n  MAX_RADIUS: 25,\n  LEVEL_OFF: 10,\n  ZOOM_INIT: 3,\n  MAP_CENTER: [52, 12],\n  MAP_BOUNDS: [[30, -20], [70, 40]],\n  MARKER_COLOR: {\n    [true]: {\n      color: '#008800',\n      fillColor: '#00cc00',\n    },\n    [false]: {\n      color: '#888844',\n      fillColor: '#bbbb66',\n    },\n  },\n  MARKER_SHAPE: {\n    weight: 1,\n    fill: true,\n    fillOpacity: 0.8,\n  },\n  COUNTRY_STYLE: {\n    [true]: {\n      color: '#884422',\n      weight: 2,\n      fill: true,\n      fillColor: '#aa7766',\n      fillOpacity: 1,\n    },\n    [false]: {\n      color: '#777777',\n      weight: 1,\n      fill: true,\n      fillColor: '#bbbbbb',\n      fillOpacity: 1,\n    },\n  },\n}\n\nconst computeRadius = (_id, filteredAmountOthers, amounts) => {\n  const amount = amounts ? (amounts[_id] || 0) : 0\n  if (amount == 0) {return 0}\n  const { MAX_RADIUS, LEVEL_OFF } = mapOptions\n  const proportional = MAX_RADIUS * amount / filteredAmountOthers\n  if (filteredAmountOthers < LEVEL_OFF) {return proportional}\n  return LEVEL_OFF * Math.sqrt(proportional)\n}\n\nclass EUMap extends Component {\n  constructor(props) {\n    super(props)\n    this.features = {}\n  }\n  setMap = dom => {if (dom) {this.dom = dom}}\n\n  render() {\n    const { props: { tables, ...byValueProps }, setMap } = this\n    return (\n      <div>\n        <div\n          ref={setMap}\n        />\n        <ByValue {...byValueProps} />\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    const {\n      props: { filterSetting, filteredAmountOthers, amounts, tables: { country } },\n      dom,\n    } = this\n    const { HEIGHT, MAP_CENTER, ZOOM_INIT, MAP_BOUNDS, MARKER_COLOR, MARKER_SHAPE, COUNTRY_STYLE } = mapOptions\n    dom.style.height = HEIGHT\n    this.map = L.map(dom, {\n      attributionControl: false,\n      center: MAP_CENTER,\n      zoom: ZOOM_INIT,\n      maxBounds: MAP_BOUNDS,\n    })\n    const { allIds, entities } = country\n    this.idFromIso = {}\n    this.inDariah = {}\n    allIds.forEach(_id => {\n      const { [_id]: { values: { iso, isMember } } } = entities\n      this.idFromIso[iso] = _id\n      this.inDariah[iso] = isMember\n    })\n    L.geoJSON(countryBorders, {\n      style: feature => COUNTRY_STYLE[this.inDariah[feature.properties.iso2]],\n      onEachFeature: feature => {\n        const { properties: { iso2, lat, lng } } = feature\n        if (this.inDariah[iso2]) {\n          const { idFromIso: { [iso2]: _id } } = this\n          const { [_id]: isOn = false } = filterSetting || emptyO\n          const marker = L.circleMarker([lat, lng], {\n            ...MARKER_COLOR[isOn],\n            radius: computeRadius(_id, filteredAmountOthers, amounts),\n            ...MARKER_SHAPE,\n            pane: 'markerPane',\n          }).addTo(this.map)\n          this.features[iso2] = marker\n        }\n      },\n    }).addTo(this.map)\n  }\n\n  componentDidUpdate() {\n    const { props: { filterSetting, filteredAmountOthers, amounts } } = this\n    const { MARKER_COLOR } = mapOptions\n    Object.entries(this.features).forEach(([iso2, marker]) => {\n      const { idFromIso: { [iso2]: _id } } = this\n      const { [_id]: isOn = false } = filterSetting || emptyO\n      marker.setRadius(computeRadius(_id, filteredAmountOthers, amounts))\n      marker.setStyle(MARKER_COLOR[isOn])\n    })\n  }\n}\n\nEUMap.displayName = 'EUMap'\n\nexport default connect(combineSelectors(getTables, getFilterSetting))(EUMap)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/EUMap.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { getTableMore, needValues, fetchItem } from 'tables'\n\nimport ItemForm from 'ItemForm'\n\nclass ItemContainer extends Component {\n  render() {\n    const { props: { tableData, table, eId } } = this\n    if (needValues({ tableData, eId })) {return <div />}\n\n    const { entities: { [eId]: { fields, values: initialValues, perm } } } = tableData\n    return (\n      <div>\n        <ItemForm\n          table={table}\n          eId={eId}\n          form={`${table}-${eId}`}\n          key={`${table}-${eId}`}\n          initialValues={initialValues}\n          perm={perm}\n          fields={fields}\n        />\n      </div>\n    )\n    /* Note the key prop passed to ItemForm.\n     * If you do not pass it, you get bugs caused by the mounting and unmounting of this component\n     * due to react-router navigation.\n     * In essence, the callback onChange that redux-form passes to input components, becomes bound to the wrong form!\n     * This workaround is documented here: https://github.com/erikras/redux-form/issues/2886\n    */\n  }\n  componentDidMount() {\n    const { props: { tableData, table, eId, dispatch } } = this\n    if (needValues({ tableData, eId })) {dispatch(fetchItem(table, eId))}\n  }\n  componentDidUpdate() {\n    const { props: { tableData, table, eId, dispatch } } = this\n    if (needValues({ tableData, eId })) {dispatch(fetchItem(table, eId))}\n  }\n}\n\nexport default connect(getTableMore)(ItemContainer)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/ItemContainer.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { withParams } from 'utils'\nimport { getTables, needTables, fetchTable, MYIDS } from 'tables'\nimport { makeTag } from 'filters'\n\nimport ListGrid from 'ListGrid'\nimport ListPlain from 'ListPlain'\nimport ListFilter from 'ListFilter'\n\nclass ListContainer extends Component {\n  render() {\n    const { props: { tables, table, select, mode, filtered } } = this\n    const grid = mode == 'grid'\n    if (needTables(tables, table, select, grid)) {return <div />}\n    const { [table]: tableData } = tables\n    const { title, perm, myIds, allIds } = tableData\n    const listIds = select == MYIDS ? myIds : allIds\n    const filterTag = makeTag(select, null, null)\n    return filtered\n    ? <ListFilter\n        table={table}\n        listIds={listIds}\n        perm={perm}\n        select={select}\n        mode={mode}\n        title={title}\n        filterTag={filterTag}\n        gridTag={table}\n      />\n    : mode == 'list'\n      ? <ListPlain\n          table={table}\n          listIds={listIds}\n          select={select}\n          perm={perm}\n          title={title}\n        />\n      : mode == 'grid'\n        ? <ListGrid\n            table={table}\n            listIds={listIds}\n            select={select}\n            perm={perm}\n            gridTag={table}\n          />\n        : <span>{`unknown display mode \"${mode}\" for item list`}</span>\n  }\n  componentDidMount() {\n    const { props: { tables, table, select, mode, dispatch } } = this\n    const grid = mode == 'grid'\n    if (needTables(tables, table, select, grid)) {dispatch(fetchTable(table, select, grid))}\n  }\n  componentDidUpdate() {\n    const { props: { tables, table, select, mode, dispatch } } = this\n    const grid = mode == 'grid'\n    if (needTables(tables, table, select, grid)) {dispatch(fetchTable(table, select, grid))}\n  }\n}\n\nexport default connect(getTables)(withParams(ListContainer))\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/ListContainer.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { initFiltering, getFiltersApplied } from 'filters'\n\nimport ListPlain from 'ListPlain'\nimport ListGrid from 'ListGrid'\nimport Filter from 'Filter'\n\nclass ListFilter extends Component {\n  componentWillMount() {\n    const { props: { tableData, table, filterTag, listIds, dispatch } } = this\n    dispatch(initFiltering(tableData, table, filterTag, listIds))\n  }\n  render() {\n    const {\n      props: {\n        heading,\n        table,\n        perm,\n        select, masterId, linkField,\n        listIds,\n        filteredIds, filteredAmountOthers, amounts,\n        mode, title,\n        filterTag, gridTag,\n      },\n    } = this\n    if (filteredIds == null) {return <div />}\n    return (\n      <div className={'list-filter'}>\n        <div className={'filters'}>\n          <p>{'Total '}<span className=\"good-o\" >{listIds.length}</span></p>\n          <Filter\n            table={table}\n            filterTag={filterTag}\n            listIds={listIds}\n            filteredAmount={filteredIds.length}\n            filteredAmountOthers={filteredAmountOthers}\n            amounts={amounts}\n          />\n        </div>\n        <div className={'list'}>\n          {\n            mode == 'list'\n            ? <ListPlain\n                heading={heading}\n                table={table}\n                listIds={filteredIds}\n                perm={perm}\n                select={select}\n                title={title}\n                masterId={masterId}\n                linkField={linkField}\n              />\n            : mode == 'grid'\n              ? <ListGrid\n                  heading={heading}\n                  table={table}\n                  listIds={filteredIds}\n                  perm={perm}\n                  select={select}\n                  gridTag={gridTag}\n                  masterId={masterId}\n                  linkField={linkField}\n                />\n              : <span>{`unknown display mode \"${mode}\" for item list`}</span>\n          }\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default connect(getFiltersApplied)(ListFilter)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/ListFilter.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport isEqual from 'lodash/isequal'\n\nimport { memoize } from 'memo'\nimport { combineSelectors, emptyO } from 'utils'\nimport { EditStatus } from 'fields'\n\nimport { getTables, insertItem } from 'tables'\nimport { getForms } from 'forms'\nimport { getAlts, makeAlt } from 'alter'\n\nimport ItemContainer from 'ItemContainer'\n\nconst initial = 0\nconst nAlts = 2\n\nclass ListPlain extends Component {\n  handleInsert = () => {\n    const { props: { table, select, masterId, linkField, dispatch } } = this\n    dispatch(insertItem(table, select, masterId, linkField))\n    this.gotoNew = true\n  }\n  gotoItem = eId => {\n    const { props, props: { table } } = this\n    const { nextAlt } = makeAlt(props, { alterTag: `${table}-${eId}`, nAlts, initial })\n    nextAlt()\n  }\n  closeItem = eId => {\n    const { props, props: { table } } = this\n    const { initAlt } = makeAlt(props, { alterTag: `${table}-${eId}`, nAlts, initial })\n    initAlt()\n  }\n  handleCloseAll = memoize(items => () => {items.forEach(eId => {this.closeItem(eId)})})\n\n  scroll = domElem => {\n    if (domElem != null) {\n      domElem.scrollIntoViewIfNeeded()\n    }\n  }\n\n  render() {\n    const { props, props: { tables, forms, table, listIds, perm, title } } = this\n    const { [table]: { entities } } = tables\n    const nItemsRep = `${listIds.length} item${listIds.length == 1 ? '' : 's'} `\n    return (\n      <div className={'listGeneric'} >\n        <div>\n          {nItemsRep}\n          {\n            (perm != null && perm.insert)\n            ? <span\n                className=\"fa fa-plus button-large\"\n                title={`new ${table}`}\n                onClick={this.handleInsert}\n              />\n            : null\n          }\n        </div>\n        {\n          listIds.map(eId => {\n            const { [eId]: { values } } = entities\n            const { [title]: entityHead = '-empty-' } = values\n            const formTag = `${table}-${eId}`\n            const { [formTag]: form } = forms\n            const alterTag = `${table}-${eId}`\n            const { alt, nextAlt } = makeAlt(props, { alterTag, nAlts, initial })\n            const active = alt != initial\n            const scrollProps = active ? { ref: this.scroll } : emptyO\n            return (\n              <div key={eId} >\n                <span className={'itemHead'} {...scrollProps} >\n                  {\n                    form\n                    ? <EditStatus form={formTag} showNeutral={true} />\n                    : <span>\n                        <span className={'fa fa-fw'} title={'not yet open'} />\n                        {' '}\n                      </span>\n                  }\n                  <span className={'link head'} onClick={nextAlt} >\n                    <span className={`fa fa-angle-${active ? 'up' : 'down'}`} />\n                    {' '}{entityHead}\n                  </span>\n                </span>\n                {\n                  active\n                  ? <ItemContainer table={table} eId={eId} />\n                  : null\n                }\n              </div>\n            )\n          })\n        }\n        <div\n          className={'button-large fa fa-angle-double-left'}\n          title={'Close all opened items'}\n          onClick={this.handleCloseAll(listIds)}\n        />\n      </div>\n    )\n  }\n\n  gotoNewItem() {\n    if (this.gotoNew) {\n      const { props: { tables, table } } = this\n      const { [table]: tableInfo } = tables\n      if (tableInfo == null) {return}\n      const { lastInserted } = tableInfo\n      if (lastInserted != null) {\n        this.gotoNew = false\n        this.gotoItem(lastInserted)\n      }\n    }\n  }\n  shouldComponentUpdate(newProps) {\n    for (const prop in newProps) {\n      if (prop != 'listIds') {\n        if (newProps[prop] !== this.props[prop]) {\n          return true\n        }\n      }\n      else {\n        if (!isEqual(newProps[prop], this.props[prop])) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n  componentDidMount() {\n    this.gotoNewItem()\n  }\n  componentDidUpdate() {\n    this.gotoNewItem()\n  }\n}\n\nconst getInfo = combineSelectors(getTables, getForms, getAlts)\n\nexport default connect(getInfo)(ListPlain)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/ListPlain.jsx","import React, {Component} from 'react'\nimport { connect } from 'react-redux'\n\nimport { getMe, fetchMe } from 'me'\n\nclass Login extends Component {\n  render() {\n    const { props: { me } } = this\n    return (\n      <span className=\"login\" >\n        {\n          me.eppn\n          ? <span>\n              <span className=\"fa fa-user\" title={me.eppn} /><strong>{me.eppn.split('@')[0]}</strong>\n              <span className=\"fa fa-hashtag\" />{me.authority}{' '}\n              <em>{me.groupDesc || 'not authenticated'}</em>\n              <a href=\"/logout\" className=\"control fa fa-user-times\" title=\"log out\" />\n              <a href=\"/slogout\" className=\"control fa fa-users\" title=\"sign out\" />\n            </span>\n          : <a href=\"/login\" className={'control'} >\n              <strong className={'fa fa-user-plus'} /><strong>{' login'}</strong>\n            </a>\n        }\n      </span>\n    )\n  }\n  componentDidMount() {\n    const { props: { dispatch } } = this\n    dispatch(fetchMe({ type: 'fetchMe', contentType: 'db', path: '/who/ami', desc: 'me' }))\n  }\n}\n\nexport default connect(getMe)(Login)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/Login.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { getNotifications, clear, display } from 'notify'\n\nclass Notification extends Component {\n  constructor(props) {\n    super(props)\n    this.dom = {}\n  }\n  refDom = label => dom => {\n    if (dom) {this.dom[label] = dom}\n  }\n  handleBox = () => {\n    const { props: { show, dispatch } } = this\n    dispatch(display(!show))\n  }\n  handleHide = () => {\n    const { props: { dispatch } } = this\n    dispatch(display(false))\n  }\n  handleClear = () => {\n    const { props: { dispatch } } = this\n    dispatch(clear())\n  }\n\n  render() {\n    const { props: { notifications, lastNote, lastKind, busy, show } } = this\n    const highlight = lastNote > -1\n    const busyBlocks = new Array(busy < 0 ? 0 : busy).fill(1)\n    return (\n      <div>\n        <p className=\"msg-spinner\" >\n          <span\n            title=\"show/hide notifications and progress messages\"\n            className={highlight ? `spin-${lastKind}` : 'spin-ok'}\n          >\n            { busyBlocks.map((b, i) => <span key={i} className=\"msg-dot fa fa-caret-left\" />) }\n            <span\n              className={`fa fa-${busy == 0 ? 'circle-o' : 'spinner fa-spin'}`}\n              onClick={this.handleBox}\n            />\n          </span>\n        </p>\n        {\n          show\n          ? <div\n              ref={this.refDom('notbox')}\n              className=\"msg-box\"\n              onClick={this.handleHide}\n            >{\n              (notifications).map((msg, i) => (\n                <p\n                  key={i}\n                  ref={this.refDom(`m${i}`)}\n                  className={`msg-line ${[msg.kind]}-o ${msg.kind != 'info' ? 'msg-high' : ''}`}\n                >{msg.text}</p>\n              ))\n            }\n              <p className=\"msg-dismiss\" >{'(click panel to hide)'}</p>\n              <p className=\"msg-trash\" >\n                <a\n                  href=\"#\"\n                  title=\"clear messages\"\n                  className=\"control fa fa-trash\"\n                  onClick={this.handleClear}\n                />\n              </p>\n            </div>\n          : null\n        }\n      </div>\n    )\n  }\n  componentDidMount() {this.setView()}\n  componentDidUpdate() {this.setView()}\n\n  setView() {\n    const { props: { show } } = this\n    if (show) {this.setScroll()}\n  }\n  setScroll() {\n    const { props: { show } } = this\n    if (show) {\n      const { props: { lastMsg, lastNote } } = this\n      const highlight = lastNote > -1\n      if (highlight) {\n        this.dom[`m${lastNote}`].scrollIntoView()\n      }\n      else {\n        if (lastMsg > -1) {\n          this.dom[`m${lastMsg}`].scrollIntoView()\n        }\n      }\n    }\n  }\n}\n\nexport default connect(getNotifications)(Notification)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/Notification.jsx","import { Component, Children } from 'react'\nimport { connect } from 'react-redux'\nimport throttle from 'lodash/throttle'\n\nimport { changeWinDim } from 'win'\n\nclass Window extends Component {\n  render() {\n    const { props: { children } } = this\n    return Children.only(children)\n  }\n  newWindowSize = throttle(() => {\n    const { props: { dispatch } } = this\n    dispatch(changeWinDim())\n  }, 1000)\n\n  componentDidMount() {window.addEventListener(\"resize\", this.newWindowSize)}\n  componentWillUnmount() {window.removeEventListener(\"resize\", this.newWindowSize)}\n}\n\nexport default connect()(Window)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/object/Window.jsx","import React from 'react'\n\nimport { withParams } from 'utils'\n\nimport NavLink from 'NavLink'\n\nconst Backoffice = ({ children }) => (\n  <div className={'backoffice'} >\n    <div className={'nav bar'} >\n      <p><NavLink to={`/backoffice/user/list`} >{'Users'}</NavLink></p>\n      <p><NavLink to={`/backoffice/country/grid`} >{'Countries'}</NavLink></p>\n      <p><NavLink to={`/backoffice/criteria/list`} >{'Criteria (list)'}</NavLink></p>\n      <p><NavLink to={`/backoffice/criteria/grid`} >{'Criteria (grid)'}</NavLink></p>\n      <p><NavLink to={`/backoffice/package/list`} >{'Packages (list)'}</NavLink></p>\n      <p><NavLink to={`/backoffice/package/grid`} >{'Packages (grid)'}</NavLink></p>\n    </div>\n    <div className={'details'} >\n      { children }\n    </div>\n  </div>\n)\n\nexport default withParams(Backoffice)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/Backoffice.jsx","import React from 'react'\n\nimport DocMd from 'DocMd'\nimport DocPdf from 'DocPdf'\nimport DocHtml from 'DocHtml'\nimport NotFound from 'NotFound'\n\nconst docType = {\n  md: DocMd,\n  pdf: DocPdf,\n  html: DocHtml,\n}\n\nconst Doc = ({ location: { pathname: docPath } }) => {\n  const [docDir, docFile] = /^(.*)\\/([^/]+)$/g.exec(docPath).slice(1)\n  const [docName, docExt] = /^(.*)\\.([^.]+)$/g.exec(docFile).slice(1)\n  const { [docExt]: DocClass } = docType\n  return DocClass == null\n  ? <NotFound splat={`document ${docPath}`} />\n  : <DocClass docDir={docDir} docName={docName} docExt={docExt} />\n}\n\nexport default Doc\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/Doc.jsx","import React from 'react'\n\nconst DocHtml = ({ docDir, docName, docExt }) => {\n  const src = `/api/file${docDir}/${docName}.${docExt}`\n  return (\n    <iframe\n      height=\"100%\"\n      width=\"100%\"\n      src={src}\n    />\n  )\n}\n\nexport default DocHtml\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/DocHtml.jsx","import React from 'react'\n\nconst DocPdf = ({ docDir, docName, docExt }) => {\n  const href = `/api/file${docDir}/${docName}.${docExt}`\n  const iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream\n  return iOS\n  ? <p>\n      <a target=\"_blank\" rel=\"noopener noreferrer\" href={href} >{docName}</a>{' (open pdf in a new tab)'}\n    </p>\n  : <object\n      height=\"100%\"\n      width=\"100%\"\n      data={href}\n      type=\"application/pdf\"\n    >\n      <a target=\"_blank\" rel=\"noopener noreferrer\" href={href} >{docName}</a>{' (open pdf in a new tab)'}\n    </object>\n}\n\nexport default DocPdf\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/DocPdf.jsx","import React from 'react'\n\nimport { editClass } from 'fields'\n\nconst Input = ({ meta: { dirty, invalid, error }, input, type }) => (\n  <span>\n    <input type={type} className={editClass(dirty, invalid)} {...input} />\n    {error && <span className=\"invalid diag\">{error}</span>}\n  </span>\n)\n\nexport default Input\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/Input.jsx","import React from 'react'\nimport { Field } from 'redux-form'\n\nimport { editClass } from 'fields'\n\nconst fieldRemove = (fields, i) => () => {fields.remove(i)}\nconst fieldPush = fields => () => {fields.push()}\n/* N.B.\n * fieldRemove and fieldPush MUST NOT be memoized.\n * Otherwise they may become bound to the wrong form.\n * This happens if you navigate with react-router between forms.\n */\n\nconst InputMulti = ({\n  componentSingle, validateSingle, normalizeSingle,\n  meta: { dirty, invalid, error },\n  fields, table, eId, name,\n  ...props\n}) => (\n  <div\n    className={`${editClass(dirty, invalid)} multi-field`}\n  >\n    {fields.map((field, i) =>\n      <div\n        key={field}\n        className={'multi-content'}\n      >\n        <span\n          className=\"button-small fa fa-close\"\n          title=\"remove\"\n          onClick={fieldRemove(fields, i)}\n        />\n        <Field\n          name={field}\n          component={componentSingle}\n          validate={validateSingle}\n          normalize={normalizeSingle}\n          label={i}\n          table={table}\n          eId={eId}\n          {...props}\n        />\n      </div>\n    )}\n    <div\n      className={'button-small fa fa-plus multi-control'}\n      onClick={fieldPush(fields)}\n    />\n    {error && <p className=\"invalid diag\">{error}</p>}\n  </div>\n)\n\nexport default InputMulti\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/InputMulti.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport Markdown from 'react-markdown'\n\nimport { editClass } from 'fields'\n\nimport { getAlts, makeAlt } from 'alter'\n\nconsole.warn('MD getAlts', getAlts)\n\nconst MarkdownArea = ({\n    table, eId, meta: { dirty, invalid, error },\n    input: { name, value }, input,\n    ...props\n}) => {\n  const { alt, nextAlt } = makeAlt(props, {\n    alterTag: `md-${table}-${eId}-${name}`,\n    nAlts: 2,\n    initial: 0,\n  })\n  return (\n    <div className={'md-field'}>\n      <p className={'stick'} >\n        <span\n          className={`button-medium field-control fa fa-${alt == 0 ? 'pencil' : 'hand-o-down'}`}\n          onClick={nextAlt}\n        />\n      </p>\n      {\n        alt == 0\n        ? <Markdown\n            className={`${editClass(dirty, invalid)} field-content`}\n            key=\"fmt\"\n            source={value}\n          />\n        : <span key=\"src\" className=\"field-content\">\n            <textarea\n              className={`input ${editClass(dirty, invalid)}`}\n              {...input}\n              wrap=\"soft\"\n            />\n            {error && <span className=\"invalid diag\">{error}</span>}\n          </span>\n      }\n    </div>\n  )\n}\n\nexport default connect(getAlts)(MarkdownArea)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/MarkdownArea.jsx","import React from 'react'\nimport { Link } from 'react-router'\n\nconst NavLink = props => <Link {...props} activeClassName=\"active\" />\n\nexport default NavLink\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/NavLink.jsx","import React from 'react'\n\nconst NotFound = ({ splat }) => (<h1>{'404: '}<code>{splat}</code>{' not found on this site.'}</h1>)\n\nexport default NotFound\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/NotFound.jsx","import React from 'react'\nimport { Provider } from 'react-redux'\n\nimport store from 'roots'\nimport Window from 'Window'\n\nconst Root = ({ children }) => (\n  <Provider store={store}>\n    <Window>\n      {children}\n    </Window>\n  </Provider>\n)\n\nexport default Root\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/Root.jsx","import React from 'react'\n\nconst Stat = ({subTotal, total}) => (\n  <span className=\"good-o stat\" >\n    {subTotal == null ? '' : `${subTotal}`}\n    {(total == null || subTotal == null) ? '' : ' of '}\n    <strong>{total == null ? '' : `${total}`}</strong>\n  </span>\n)\n\nexport default Stat\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/Stat.jsx","import React from 'react'\n\nimport NavLink from 'NavLink'\n\nconst Static = () => (\n  <span className=\"small\" >\n    <NavLink to=\"/docs/about.md\" >{'About'}</NavLink>\n    <NavLink to=\"/tech/docs/design.pdf\" >{'diagrams'}</NavLink>\n    <a href=\"https://dans-labs.github.io/dariah/\" target=\"_blank\" rel=\"noopener noreferrer\" >{'tech doc'}</a>\n  </span>\n)\n\nexport default Static\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/pure/Static.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors } from 'utils'\n\nimport { getMe } from 'me'\nimport { getWinDim } from 'win'\n\nimport Login from 'Login'\nimport NavLink from 'NavLink'\nimport Static from 'Static'\nimport Notification from 'Notification'\n\nconst App = ({ children, height, width, me }) => {\n  const text = `${width} x ${height}`\n  return (\n    <div>\n      <Notification />\n      <p className=\"nav small top\" >\n        <img\n          src=\"/static/images/inkind_logo_small.png\"\n          title=\"information about this site\"\n        />\n        <NavLink to=\"/data/contrib\" >{'Contributions'}</NavLink>\n        {\n          me.eppn\n          ? <NavLink to=\"/backoffice\" >{'Backoffice'}</NavLink>\n          : null\n        }\n        <Static />\n        <span className=\"resize\" title={text}>{text}</span>\n        <Login />\n      </p>\n      <div>{children}</div>\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getWinDim, getMe)\n\nexport default connect(getInfo)(App)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/App.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors } from 'utils'\nimport { getFieldValues, placeFacets } from 'filters'\nimport { getAlts, makeAlt } from 'alter'\n\nimport Facet from 'Facet'\nimport CheckboxI from 'CheckboxI'\nimport Stat from 'Stat'\n\nconst ByValue = ({\n  table, filterTag,\n  filterId, filterLabel,\n  fieldValues,\n  filteredAmount, filteredAmountOthers,\n  amounts, maxCols,\n  expanded,\n  ...props\n}) => {\n  const rows = placeFacets(fieldValues, maxCols)\n  if (rows == null) {\n    return <div className=\"facet\" ><p>{' -no facets '}</p></div>\n  }\n  const alterTag = `${table}-${filterId}`\n  const { alt, nextAlt } = makeAlt(props, { alterTag, nAlts: 2, initial: expanded ? 0 : 1 })\n  return (\n    <div className=\"facet\" >\n      <p className=\"facet\" >\n        <CheckboxI\n          table={table}\n          filterId={filterId}\n          filterTag={filterTag}\n        /> {filterLabel}{' '}\n        <Stat subTotal={filteredAmount} total={filteredAmountOthers} />{' '}\n        <span\n          className={`button-small fa fa-angle-${alt == 0 ? 'up' : 'down'}`}\n          onClick={nextAlt}\n        />\n      </p>\n      {\n        alt == 0\n        ? <table key=\"table\" className=\"facets\" >\n            <tbody>\n              {rows.map((entity, i) => (\n                <tr key={i} >\n                  {\n                    entity.map((f, j) => {\n                      if (f === null) {\n                        return <td key={j} />\n                      }\n                      const [valueId, valueRep] = f\n                      const facetClass = j == 0 ? 'facet' : 'facet mid'\n                      return [(\n                        <td\n                         key={valueId}\n                         className={facetClass}\n                        >\n                          <Facet\n                            table={table}\n                            filterTag={filterTag}\n                            filterId={filterId}\n                            valueId={valueId}\n                            valueRep={valueRep}\n                          />\n                        </td>\n                      ), (\n                        <td\n                          key=\"stat\"\n                          className=\"statistic\"\n                        >\n                          <Stat subTotal={amounts[valueId]} />\n                        </td>\n                      )]\n                    })\n                  }\n                </tr>\n                ))}\n            </tbody>\n          </table>\n        : <div />\n      }\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getFieldValues, getAlts)\n\nexport default connect(getInfo)(ByValue)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ByValue.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { emptyO } from 'utils'\nimport { handlE } from 'fields'\n\nimport { changeFacet, getFilterSetting } from 'filters'\n\nconst Facet = ({ table, filterTag, filterId, valueId, valueRep, filterSetting, dispatch }) => {\n  const { [valueId]: isOn = false } = filterSetting || emptyO\n  return (\n    <span>\n      <input\n        type=\"checkbox\"\n        checked={isOn}\n        className=\"facet\"\n        onChange={handlE(dispatch, changeFacet, table, filterTag, filterId, valueId, !isOn)}\n      />\n      {` ${valueRep}`}\n    </span>\n  )\n}\n\nexport default connect(getFilterSetting)(Facet)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/Facet.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport { Field, FieldArray } from 'redux-form'\n\nimport { validation, normalization, getValType } from 'fields'\nimport { getTables } from 'tables'\n\nimport InputMulti from 'InputMulti'\nimport RelSelect from 'RelSelect'\n\nconst FieldEdit = ({ field, tables, table, eId, ...props }) => {\n  const { [table]: { fieldSpecs } } = tables\n  const { [field]: { valType, valid, multiple } } = fieldSpecs\n  if (typeof valType == 'string') {\n    const typing = getValType(valType)\n    const { component, type } = typing\n    const { [valid || valType]: validate } = validation\n    const { [valid || valType]: normalize } = normalization\n    if (multiple) {\n      return (\n        <FieldArray\n          name={field}\n          component={InputMulti}\n          componentSingle={component}\n          validateSingle={validate}\n          normalizeSingle={normalize}\n          table={table}\n          eId={eId}\n          type={type}\n          {...props}\n        />\n      )\n    }\n    else {\n      return (\n        <Field\n          name={field}\n          component={component}\n          validate={validate}\n          normalize={normalize}\n          table={table}\n          eId={eId}\n          type={type}\n          {...props}\n        />\n      )\n    }\n  }\n  else {\n    const { allowNew } = valType\n    const selectTag = `${table}-${eId}-${field}`\n    return (\n      <Field\n        name={field}\n        component={RelSelect}\n        selectTag={selectTag}\n        field={field}\n        multiple={multiple}\n        allowNew={allowNew}\n        table={table}\n        eId={eId}\n        {...props}\n      />\n    )\n  }\n}\n\nexport default connect(getTables)(FieldEdit)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/FieldEdit.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport Markdown from 'react-markdown'\n\nimport { emptyA } from 'utils'\n\nimport { getTables, repr } from 'tables'\n\nconst FieldRead = ({ field, tables, table, myValues }) => {\n  const { [table]: { fieldSpecs } } = tables\n  const { [field]: { valType, multiple } } = fieldSpecs\n  const isArea = valType == 'textarea'\n  const sep = isArea ? '\\n\\n' : ' | '\n  const myRepr = multiple\n  ? (myValues || emptyA).map(value => repr(tables, table, valType, value)).join(sep)\n  : repr(tables, table, valType, myValues)\n  return isArea\n  ? <Markdown source={myRepr} />\n  : <span>{myRepr}</span>\n}\n\nexport default connect(getTables)(FieldRead)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/FieldRead.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { getTableFilters } from 'tables'\n\nimport Fulltext from 'Fulltext'\nimport ByValue from 'ByValue'\nimport EUMap from 'EUMap'\n\nconst filterClass = {\n  Fulltext,\n  EUMap,\n  ByValue,\n}\n\nconst Filter = ({\n  table, filterTag, listIds,\n  fields,\n  filterList, filteredAmount, filteredAmountOthers, amounts,\n}) => (\n  filterList == null\n  ? <div>\n      {'No filters for this list'}\n    </div>\n  : <div>\n      {filterList.filter(x => fields[x.field]).map((filter, filterId) => {\n        const { type } = filter\n        const { [type]: Fclass } = filterClass\n        return (\n          <Fclass\n            key={filterId}\n            table={table}\n            filterTag={filterTag}\n            listIds={listIds}\n            filterId={filterId}\n            filterField={filter.field}\n            filterLabel={filter.label}\n            maxCols={filter.maxCols}\n            filteredAmount={filteredAmount}\n            filteredAmountOthers={filteredAmountOthers[filterId]}\n            amounts={amounts[filterId]}\n            expanded={filter.expanded}\n          />\n        )}\n      )}\n    </div>\n)\n\nexport default connect(getTableFilters)(Filter)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/Filter.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { handlEV } from 'fields'\n\nimport { changeFulltext, getFilterSetting } from 'filters'\n\nimport Stat from 'Stat'\n\nconst Fulltext = ({\n  table, filterTag,\n  filterId, filterLabel,\n  filterSetting = '',\n  filteredAmount, filteredAmountOthers,\n  dispatch,\n}) => (\n  <div className={'fulltext'} title={`Search in ${filterLabel}`} >\n    <input\n      type=\"text\"\n      className=\"search\"\n      placeholder={`search in ${filterLabel}`}\n      value={filterSetting}\n      onChange={handlEV(dispatch, changeFulltext, table, filterTag, filterId)}\n    />{' '}\n    <Stat subTotal={filteredAmount} total={filteredAmountOthers} />\n  </div>\n)\n\nexport default connect(getFilterSetting)(Fulltext)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/Fulltext.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors } from 'utils'\nimport { makeDetails } from 'fields'\n\nimport { getTables, DETAILS } from 'tables'\nimport { getAlts, makeAlt } from 'alter'\n\nconst ItemDetailHeads = ({ tables, table, eId, detailFragments, ...props }) => {\n  const theFragments = detailFragments == null\n  ? makeDetails(tables, table, eId)\n  : detailFragments\n  return (\n    <div className={'grid fragments'}>{\n      theFragments.map(({ name, label, nDetails }) => {\n        const alterTag = `${DETAILS}-${table}-${eId}-${name}`\n        const { nextAlt } = makeAlt(props, { alterTag, nAlts: 2, initial: 1 })\n        return (\n          <div\n            key={name}\n            className={'grid-row form'}\n          >\n            <div className={'grid-head-cell labelCol'} >{`${label}:`}</div>\n            <div className={'grid-cell valueCol'} >\n              <span\n                className={'link'}\n                onClick={nextAlt}\n              >\n                {`${nDetails} item${nDetails == 1 ? '' : 's'}`}\n              </span>\n            </div>\n          </div>\n        )\n      })\n    }\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getTables, getAlts)\n\nexport default connect(getInfo)(ItemDetailHeads)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ItemDetailHeads.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors, emptyA } from 'utils'\n\nimport { getTables, DETAILS } from 'tables'\nimport { makeTag } from 'filters'\nimport { getAlts, makeAlt } from 'alter'\n\nimport ListGrid from 'ListGrid'\nimport ListPlain from 'ListPlain'\nimport ListFilter from 'ListFilter'\n\nconst ItemDetails = ({ tables, table, eId, ...props }) => {\n  const { [table]: { details, detailOrder } } = tables\n  return (\n    <div>\n      {\n        (detailOrder || emptyA).map(name => {\n          const { label, table: detailTable, linkField, mode, filtered } = details[name]\n          const {\n            [detailTable]: {\n              title: detailTitle,\n              perm: detailPerm,\n              entities: detailEntities,\n              allIds: detailAllIds,\n            },\n          } = tables\n          const detailListIds = detailAllIds.filter(_id => detailEntities[_id].values[linkField] == eId)\n          const filterTag = makeTag(DETAILS, eId, linkField)\n          const gridTag = `${table}-${name}-${eId}`\n          const alterTag = `${DETAILS}-${table}-${eId}-${name}`\n          const { alt } = makeAlt(props, { alterTag, nAlts: 2, initial: 1 })\n          return (\n            <div key={name}>\n              {\n                alt == 0\n                ? filtered\n                  ? <ListFilter\n                      heading={label}\n                      table={detailTable}\n                      listIds={detailListIds}\n                      perm={detailPerm}\n                      select={DETAILS}\n                      mode={mode}\n                      title={detailTitle}\n                      gridTag={gridTag}\n                      filterTag={filterTag}\n                      masterId={eId}\n                      linkField={linkField}\n                    />\n                  : mode == 'list'\n                    ? <ListPlain\n                        heading={label}\n                        table={detailTable}\n                        listIds={detailListIds}\n                        perm={detailPerm}\n                        title={detailTitle}\n                        masterId={eId}\n                        linkField={linkField}\n                      />\n                    : mode == 'grid'\n                      ? <ListGrid\n                          heading={label}\n                          table={detailTable}\n                          listIds={detailListIds}\n                          perm={detailPerm}\n                          gridTag={gridTag}\n                          masterId={eId}\n                          linkField={linkField}\n                        />\n                      : <span>{`unknown display mode \"${mode}\" for item list`}</span>\n                : ''\n              }\n            </div>\n          )\n        })\n      }\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getTables, getAlts)\n\nexport default connect(getInfo)(ItemDetails)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ItemDetails.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport { reduxForm } from 'redux-form'\n\nimport { makeFields, makeDetails, someEditable, onSubmitSuccess, editStatus, editDelete, handle } from 'fields'\n\nimport { getTables, delItem, toDb } from 'tables'\n\n//import { makeOptionStyles } from 'custom'\n\nimport FieldRead from 'FieldRead'\nimport FieldEdit from 'FieldEdit'\nimport ItemDetails from 'ItemDetails'\nimport ItemDetailHeads from 'ItemDetailHeads'\n\nconst WrapForm = ({ children, submitFunction }) => (\n  submitFunction\n  ? <form onSubmit={submitFunction} >{children}</form>\n  : <div>{children}</div>\n)\n\nconst ItemForm = props => {\n  const {\n    table, eId, perm,\n    dirty, invalid, submitting, reset, error,\n    handleSubmit,\n    dispatch,\n  } = props\n  let { fieldFragments, detailFragments } = props\n  if (fieldFragments == null) {fieldFragments = makeFields(props)}\n  if (detailFragments == null) {detailFragments = makeDetails(props)}\n  const hasEditable = someEditable(props)\n  return (\n    <div>\n      <WrapForm submitFunction={hasEditable ? handleSubmit(toDb(table, eId, dispatch)) : null} >\n        <div>\n          {editDelete(perm, 'button-large', handle(dispatch, delItem, table, eId))}\n          {\n            hasEditable\n            ? editStatus(\n              {\n                form: `${table}-${eId}`,\n                showNeutral: false,\n                dirty, invalid, submitting, reset, error,\n              })\n            : null\n          }\n        </div>\n        <div className={'grid fragments'}>{\n          fieldFragments.map(({\n            field, label,\n            fragment: { editable, table: detailTable, myValues, ...props },\n          }) => (\n            <div\n              key={field}\n              className={'grid-row form'}\n            >\n              <div className={'grid-head-cell labelCol'}>{`${label}:`}</div>\n              <div className={'grid-cell valueCol'} >\n                {\n                  editable\n                  ? <FieldEdit\n                      field={field}\n                      table={detailTable}\n                      eId={eId}\n                      {...props}\n                    />\n                  : <FieldRead\n                      field={field}\n                      table={detailTable}\n                      eId={eId}\n                      myValues={myValues}\n                    />\n              }\n              </div>\n            </div>\n          ))\n        }\n        </div>\n      </WrapForm>\n      <ItemDetailHeads\n        table={table}\n        eId={eId}\n        detailFragments={detailFragments}\n      />\n      <ItemDetails\n        table={table}\n        eId={eId}\n      />\n    </div>\n  )\n}\n\nexport default connect(getTables)(reduxForm({\n  destroyOnUnmount: false,\n  enableReinitialize: true,\n  keepDirtyOnReinitialize: true,\n  onSubmitSuccess,\n})(ItemForm))\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ItemForm.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { memoize } from 'memo'\nimport { combineSelectors } from 'utils'\n\nimport { getTables, DETAILS } from 'tables'\nimport { getForms } from 'forms'\nimport { EditStatus, makeFields, makeDetails, someEditable } from 'fields'\nimport { getAlts, makeAlt } from 'alter'\n\nimport FieldRead from 'FieldRead'\nimport ItemForm from 'ItemForm'\nimport ItemDetails from 'ItemDetails'\n\nconst putFieldFragments = (fieldFragments, widthStyles) => fieldFragments.map(({\n  field, label,\n  fragment: { editable, table, myValues },\n}, i) => {\n  const widthStyle = widthStyles[i]\n  return (\n    <div\n      className={`grid-cell valueColGrid ${editable ? 'editable' : ''}`}\n      style={widthStyle}\n      key={field}\n    >\n      <FieldRead\n        field={field}\n        table={table}\n        myValues={myValues}\n      />\n    </div>\n  )\n})\n\nconst putDetailFragments = (props, table, eId, detailFragments, widthStyles, nFields) => detailFragments.map(({\n  name, label, nDetails,\n}, i) => {\n  const widthStyle = widthStyles[nFields + i]\n  const { nextAlt } = makeAlt(props, { alterTag: `${DETAILS}-${table}-${eId}-${name}`, nAlts: 2, initial: 1 })\n  return (\n    <div\n      key={name}\n      className={'grid-cell valueColGrid'}\n      style={widthStyle}\n    >\n      <span\n        className={'link'}\n        onClick={nextAlt}\n      >\n        {`${nDetails} item${nDetails == 1 ? '' : 's'}`}\n      </span>\n    </div>\n  )\n})\n\nconst editControl = memoize((nextAlt, table, eId, mayUpdate, withRow) => (\n  mayUpdate\n  ? <span\n      className={`link fa fa-angle-${withRow ? 'down' : 'up'}`}\n      title={`${withRow ? 'open an' : 'close the'}edit form for this record`}\n      onClick={nextAlt}\n    />\n  : null\n))\n\nconst ItemRow = ({\n  tables, forms, table, eId, initialValues, perm,\n  fields,\n  widthStyles,\n  ...props\n}) => {\n  const hasEditable = someEditable({ tables, table, eId, fields, perm })\n  const fieldFragments = makeFields({\n    tables, table, eId, initialValues, perm,\n    fields,\n  })\n  const detailFragments = makeDetails({ tables, table, eId })\n  const { update } = perm\n  const nFields = fieldFragments.length\n  const alterTag = `row-${table}-${eId}`\n  const { alt, nextAlt } = makeAlt(props, { alterTag, nAlts: 2, initial: 0 })\n  const formTag = `${table}-${eId}`\n  const { [formTag]: form } = forms\n  return hasEditable\n  ? <div>\n      {\n        alt == 0\n        ? <div>\n            <div className={'grid-row'}>\n              <div className=\"grid-status-cell\" >\n                {editControl(nextAlt, table, eId, update, true)}\n                {form ? <EditStatus form={`${table}-${eId}`} showNeutral={true} /> : null }\n              </div>\n              {putFieldFragments(fieldFragments, widthStyles)}\n              {putDetailFragments(props, table, eId, detailFragments, widthStyles, nFields)}\n            </div>\n            <ItemDetails table={table} eId={eId} />\n          </div>\n        : <div>\n            <div className=\"grid-status-cell\" >\n              {editControl(nextAlt, table, eId, update, false)}\n              {form ? <EditStatus form={`${table}-${eId}`} showNeutral={true} /> : null}\n            </div>\n            <ItemForm\n              table={table}\n              eId={eId}\n              form={`${table}-${eId}`}\n              initialValues={initialValues}\n              perm={perm}\n              fields={fields}\n              fieldFragments={fieldFragments}\n              detailFragments={detailFragments}\n            />\n          </div>\n      }\n    </div>\n  : <div>\n      <div className=\"grid-row\" >\n        {putFieldFragments(fieldFragments, widthStyles)}\n        {putDetailFragments(props, table, eId, detailFragments, widthStyles, nFields)}\n      </div>\n      <ItemDetails table={table} eId={eId} />\n    </div>\n}\n\nconst getInfo = combineSelectors(getTables, getForms, getAlts)\n\nexport default connect(getInfo)(ItemRow)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ItemRow.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors } from 'utils'\nimport { handle } from 'fields'\nimport { getSort, getSortedData, resetSort, addColumn, turnColumn, delColumn } from 'grid'\nimport { getTable, insertItem } from 'tables'\n\nimport ItemRow from 'ItemRow'\n\nconst ListGrid = ({\n  heading,\n  tableData, table, listIds, select, perm: tablePerm,\n  masterId, linkField,\n  gridTag, sortSpec,\n  sortedData,\n  dispatch,\n}) => {\n  const theHeading = heading ? `${heading}: ` : ''\n  const { fields, fieldOrder, fieldSpecs, detailOrder, entities } = tableData\n  const xfields = fields\n  const { length: nFields } = fieldOrder\n  const nDetails = detailOrder != null ? detailOrder.length : 0\n  const avLength = `${90 / nFields}%`\n  const widths = fieldOrder.map(field => {\n    const { [field]: { grid } } = fieldSpecs\n    if (grid == null) {\n      return { width: avLength, shrink: 0, grow: 1 }\n    }\n    const { width, grow, shrink } = grid\n    return {\n      width: width == null ? avLength : width,\n      shrink: shrink == null ? 0 : shrink,\n      grow: grow == null ? 0 : grow,\n    }\n  }).concat(new Array(nDetails).fill({ width: avLength, shrink: 0, grow: 0.3 }))\n  const widthStyles = widths.map(({ width, grow, shrink }) => ({\n    flex: `${grow} ${shrink} ${width}`,\n    overflow: 'auto',\n  }))\n  const nItemsRep = `${listIds.length} item${listIds.length == 1 ? '' : 's'} `\n\n  const rows = []\n  for (const eId of sortedData) {\n    const { [eId]: { values: initialValues, perm } } = entities\n    rows.push(\n      <ItemRow\n        key={`${table}-${eId}`}\n        table={table}\n        eId={eId}\n        initialValues={initialValues}\n        perm={perm}\n        fields={xfields}\n        widthStyles={widthStyles}\n      />\n    )\n  }\n  return (\n    <div>\n      <p>\n        <span className={'listTitle'}>{theHeading}</span>{nItemsRep}\n        {\n          (tablePerm != null && tablePerm.insert)\n          ? <span\n              className=\"fa fa-plus button-large\"\n              title={`new ${table}`}\n              onClick={handle(dispatch, insertItem, table, select, masterId, linkField)}\n            />\n          : null\n        }\n      </p>\n      {\n        sortSpec.length != 0\n        ? <p className={'sortspecs'} >\n            {'Sorted: '}\n            {\n              sortSpec.map(([column, direction]) => (\n                <span className={'sortcol'} key={column} >\n                  <span>{column}</span>\n                  <span className={`fa fa-arrow${direction == -1 ? 'down' : 'up'}`} />\n                </span>\n              ))\n            }\n            <span\n              className={'fa fa-close button-small'}\n              title={'remove all sort options'}\n              onClick={handle(dispatch, resetSort, gridTag)}\n            />{' '}\n          </p>\n        : null\n      }\n      <div className=\"grid\" >\n        <div className=\"grid-head\" >\n          <div className=\"grid-status-cell\" />\n          {\n            fieldOrder.filter(field => field != linkField).map((field, i) => {\n              const widthStyle = widthStyles[i]\n              const isSorted = sortSpec.find(x => x[0] == field)\n              const direction = isSorted ? isSorted[1] : 0\n              return (\n                <div\n                  className=\"grid-head-cell labelColGrid\"\n                  key={field}\n                  style={widthStyle}\n                >\n                  {\n                    direction\n                    ? <span\n                        className={'sorted button-small'}\n                        title={'remove column from sort options'}\n                        onClick={handle(dispatch, delColumn, gridTag, field)}\n                      >{field}</span>\n                    : <span\n                        className={'unsorted button-small'}\n                        title={'sort on this column'}\n                        onClick={handle(dispatch, addColumn, gridTag, field, 1)}\n                      >{field}</span>\n                  }\n                  {\n                    direction\n                    ? <span\n                        className={`sorted button-small fa fa-arrow-${direction == 1 ? 'up' : 'down'}`}\n                        title={'change sort direction'}\n                        onClick={handle(dispatch, turnColumn, gridTag, field)}\n                      />\n                    : null\n                  }\n                </div>\n              )\n            })\n          }\n          {\n            (detailOrder || []).map((name, i) => {\n              const widthStyle = widthStyles[i]\n              return (\n                <div\n                  className=\"grid-head-cell labelColGrid\"\n                  key={name}\n                  style={widthStyle}\n                >{name}\n                </div>\n              )\n            })\n          }\n        </div>\n        {rows}\n      </div>\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getTable, getSort, getSortedData)\n\nexport default connect(getInfo)(ListGrid)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/ListGrid.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport { memoize } from 'memo'\nimport { combineSelectors, emptyO } from 'utils'\nimport { handle, handlEV } from 'fields'\n\nimport { getSelect, setSearch, setPopUp, togglePopUp } from 'select'\nimport { getOptions } from 'tables'\n\nconst RelOption = ({ label, xClass, selected, onHit }) => (\n  <p\n    className={`tag option ${xClass} ${selected ? 'selected' : ''}`}\n    onClick={selected ? null : onHit}\n  >{label}</p>\n)\n\nconst removeVal = (value, onChange, val) => event => {\n  event.stopPropagation()\n  if (value.includes(val)) {\n    const newValue = value.filter(v => v != val)\n    onChange(newValue)\n  }\n}\nconst addVal = (optionLookup, multiple, value, onChange, label) => () => {\n  const { [label]: rep } = optionLookup\n  const exists = rep != null || value.includes(label)\n  if (!exists) {\n    const newValue = multiple ? [label, ...value] : label\n    onChange(newValue)\n  }\n}\nconst changeSel = memoize((selectTag, multiple, value, val, onChange, dispatch) => () => {\n  if (multiple) {\n    if (!value.includes(val)) {\n      const newValue = [...value, val]\n      onChange(newValue)\n    }\n  }\n  else {\n    onChange(val)\n    dispatch(setPopUp(selectTag, false))\n  }\n})\n\nconst Tags = ({ selectTag, optionLookup, optionStyle, value, onChange, dispatch }) => (\n  <div\n    className=\"tags\"\n    onClick={handle(dispatch, togglePopUp, selectTag)}\n  >\n    {\n      (value != null && value.length)\n      ? value.map(\n          val => {\n            const { [val]: lab = val } = optionLookup\n            const { [val]: xClass = '' } = optionStyle\n            return (\n              <span\n                key={val}\n                className=\"tag\"\n              >\n                <span\n                  className={`button-tag ${xClass}`}\n                  onClick={removeVal(value, onChange, val)}\n                >{''}</span>{' '}\n                <span>{lab}</span>\n              </span>\n            )\n          }\n        )\n      : <span className=\"tag empty\">{'click to enter values'}</span>\n    }\n  </div>\n)\n\nconst Head = ({ optionLookup, optionStyle, value, selectTag, dispatch }) => {\n  let label = ''\n  const { [value]: lab = value } = optionLookup\n  const { [value]: xClass = '' } = optionStyle\n  label = lab\n  const classes = ['option-head', 'tag', xClass]\n  if (value == '') {\n    label = 'click to enter a value'\n    classes.push('new')\n  }\n  return (\n    <span\n      className={classes.join(' ')}\n      onClick={handle(dispatch, togglePopUp, selectTag)}\n    >{label}</span>\n  )\n}\n\nconst Typing = ({ selectTag, search, dispatch }) => (\n  <span className=\"option-type\" >\n    <input\n      className=\"invisible\"\n      type=\"text\"\n      placeholder={'filter ...'}\n      value={search || ''}\n      onFocus={handle(dispatch, setPopUp, selectTag, true)}\n      onChange={handlEV(dispatch, setSearch, selectTag)}\n    />\n    {\n      search\n      ? <span\n          className=\"button-tag\"\n          onClick={handle(dispatch, setSearch, selectTag, '')}\n        >{''}</span>\n      : null\n    }\n  </span>\n)\n\nconst Options = ({ selectTag, optionLookup, optionStyle, multiple, allowNew, options, value, onChange, search, dispatch }) => {\n  const pat = search.toLowerCase()\n  return (\n    <div className={'options'} >\n      {\n        (\n          allowNew\n          && search\n          && !options.some(({ label }) => label == search)\n          && !value.includes(search)\n        )\n        ? <span\n            className=\"new tag\"\n            onClick={addVal(optionLookup, multiple, value, onChange, search)}\n          >{search}</span>\n        : null\n      }\n      {\n        options.map(({ value: val, label: lab }) => {\n          if (\n            (!multiple || !value.includes(val))\n            && (pat == null || pat == '' || lab == null || lab.toLowerCase().indexOf(pat) !== -1)\n          ) {\n            const { [val]: xClass = '' } = optionStyle\n            return (\n              <RelOption\n                key={val}\n                label={lab}\n                xClass={xClass}\n                selected={(multiple && value.includes(val)) || (!multiple && value == val)}\n                onHit={changeSel(selectTag, multiple, value, val, onChange, dispatch)}\n              />\n            )\n          }\n          else {\n            return null\n          }\n        })\n      }\n    </div>\n  )\n}\n\nconst RelSelect = ({\n  selectTag, options, optionLookup, optionStyle = emptyO,\n  input: { value, onChange },\n  multiple, allowNew, popUp, search, dispatch,\n}) => (\n  <div\n    className={`select ${multiple ? 'multiselect' : ''}`}\n  >\n    {\n      multiple\n      ? <Tags\n          optionLookup={optionLookup}\n          optionStyle={optionStyle}\n          value={value}\n          selectTag={selectTag}\n          dispatch={dispatch}\n          onChange={onChange}\n        />\n      : <Head\n          optionLookup={optionLookup}\n          optionStyle={optionStyle}\n          value={value}\n          popUp={popUp}\n          selectTag={selectTag}\n          dispatch={dispatch}\n        />\n    }\n    {\n      popUp\n      ? <Typing\n          selectTag={selectTag}\n          search={search}\n          dispatch={dispatch}\n        />\n      : null\n    }\n    {\n      popUp\n      ? <Options\n          selectTag={selectTag}\n          optionLookup={optionLookup}\n          optionStyle={optionStyle}\n          options={options}\n          multiple={multiple}\n          allowNew={allowNew}\n          value={value}\n          search={search}\n          dispatch={dispatch}\n          onChange={onChange}\n        />\n      : null\n    }\n  </div>\n)\n\nconst getSelectOptions = combineSelectors(getOptions, getSelect)\n\nexport default connect(getSelectOptions)(RelSelect)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/RelSelect.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { withParams } from 'utils'\nimport { getMe } from 'me'\n\nimport NavLink from 'NavLink'\n\nconst SubApp = ({ table, me, children }) => (\n  <div className={'subApp'} >\n    <div className={'nav bar'} >\n      <p><NavLink to={`/data/${table}/list`} >{'All items'}</NavLink></p>\n      {\n        me.eppn\n        ? <p><NavLink to={`/data/${table}/mylist`} >{'My work'}</NavLink></p>\n        : null\n      }\n    </div>\n    <div className={'details'} >\n      { children }\n    </div>\n  </div>\n)\n\nexport default connect(getMe)(withParams(SubApp))\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/state/SubApp.jsx"],"mappings":";;;;;;AAAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACMA;;;;;;;;ACNA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;A","sourceRoot":""}