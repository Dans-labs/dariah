{"version":3,"file":"app.js","sources":["webpack:///src/js/app/components/App.jsx","webpack:///src/js/app/components/ByValue.jsx","webpack:///src/js/app/components/CheckboxI.jsx","webpack:///src/js/app/components/Doc.jsx","webpack:///src/js/app/components/DocHtml.jsx","webpack:///src/js/app/components/DocMd.jsx","webpack:///src/js/app/components/DocPdf.jsx","webpack:///src/js/app/components/EUMap.jsx","webpack:///src/js/app/components/EditControl.jsx","webpack:///src/js/app/components/EditDelete.jsx","webpack:///src/js/app/components/EditHelp.jsx","webpack:///src/js/app/components/EditInsert.jsx","webpack:///src/js/app/components/EditStatus.jsx","webpack:///src/js/app/components/ErrorBoundary.jsx","webpack:///src/js/app/components/Expand.jsx","webpack:///src/js/app/components/Facet.jsx","webpack:///src/js/app/components/FieldEdit.jsx","webpack:///src/js/app/components/FieldRead.jsx","webpack:///src/js/app/components/FieldSet.jsx","webpack:///src/js/app/components/Filter.jsx","webpack:///src/js/app/components/Fulltext.jsx","webpack:///src/js/app/components/Input.jsx","webpack:///src/js/app/components/InputMulti.jsx","webpack:///src/js/app/components/ItemAction.jsx","webpack:///src/js/app/components/ItemContainer.jsx","webpack:///src/js/app/components/ItemDetails.jsx","webpack:///src/js/app/components/ItemEdit.jsx","webpack:///src/js/app/components/ItemForm.jsx","webpack:///src/js/app/components/ItemRead.jsx","webpack:///src/js/app/components/ItemRow.jsx","webpack:///src/js/app/components/ListContainer.jsx","webpack:///src/js/app/components/ListFilter.jsx","webpack:///src/js/app/components/ListGrid.jsx","webpack:///src/js/app/components/ListPlain.jsx","webpack:///src/js/app/components/Login.jsx","webpack:///src/js/app/components/MarkdownArea.jsx","webpack:///src/js/app/components/NavLink.jsx","webpack:///src/js/app/components/NotFound.jsx","webpack:///src/js/app/components/Notification.jsx","webpack:///src/js/app/components/OpenCloseAll.jsx","webpack:///src/js/app/components/RelSelect.jsx","webpack:///src/js/app/components/Root.jsx","webpack:///src/js/app/components/Stat.jsx","webpack:///src/js/app/components/Static.jsx","webpack:///src/js/app/components/SubApp.jsx","webpack:///src/js/app/components/Templates.jsx","webpack:///src/js/app/components/Window.jsx","webpack:///src/js/app/dux/alter.js","webpack:///src/js/app/dux/docs.js","webpack:///src/js/app/dux/filters.js","webpack:///src/js/app/dux/forms.js","webpack:///src/js/app/dux/grid.js","webpack:///src/js/app/dux/me.js","webpack:///src/js/app/dux/notes.js","webpack:///src/js/app/dux/roots.js","webpack:///src/js/app/dux/select.js","webpack:///src/js/app/dux/server.js","webpack:///src/js/app/dux/settings.js","webpack:///src/js/app/dux/tables.js","webpack:///src/js/app/dux/win.js","webpack:///src/js/app/dux/workflow.js","webpack:///src/js/app/main.jsx"],"sourcesContent":["import React from 'react'\nimport { connect } from 'react-redux'\n\nimport ReactHintFactory from 'react-hint'\nconst ReactHint = ReactHintFactory(React)\n\nimport { getWinDim } from 'win'\n\nimport ErrorBoundary from 'ErrorBoundary'\nimport Login from 'Login'\nimport Static from 'Static'\nimport Notification from 'Notification'\n\nconst App = ({ children, win }) => {\n  const { height, width } = win\n  const text = `${width} x ${height}`\n  return (\n    <ErrorBoundary>\n      <ReactHint events={true} delay={100} />\n      <ErrorBoundary>\n        <Notification />\n      </ErrorBoundary>\n      <p className={'nav small top'} >\n        <img\n          src={'/static/images/inkind_logo_small.png'}\n          data-rh={'information about this site'}\n          data-rh-at={'right'}\n        />\n        <ErrorBoundary>\n          <Static />\n        </ErrorBoundary>\n        <span\n          className={'resize'}\n          data-rh={`current window size: ${text} pixels`}\n          data-rh-at={'bottom'}\n        >{text}</span>\n        <ErrorBoundary>\n          <Login />\n        </ErrorBoundary>\n      </p>\n      <ErrorBoundary>{children}</ErrorBoundary>\n    </ErrorBoundary>\n  )\n}\n\nexport default connect(getWinDim)(App)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/App.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { emptyS, emptyO } from 'utils'\n\nimport { compileValues } from 'filters'\nimport { getAltSection, compileAlternatives } from 'alter'\n\nimport Facet from 'Facet'\nimport CheckboxI from 'CheckboxI'\nimport Stat from 'Stat'\n\nconst ByValue = ({\n  alter, alterSection, tables, table,\n  filterTag, filterSetting,\n  filterId, filterField, filterRelField, filterLabel,\n  listIds,\n  filteredAmount, filteredAmountOthers,\n  amounts, maxCols,\n  expanded,\n  compact,\n  dispatch,\n}) => {\n  const fieldValues = compileValues(tables, table, filterTag, listIds, filterField, filterRelField)\n  if (Object.keys(fieldValues).length == null) {\n    return <div className={'facet'} ><p>{' -no facets '}</p></div>\n  }\n  const initial = expanded ? 0 : 1\n  const { getAlt, nextAlt } = compileAlternatives(alterSection, 2, initial, dispatch)('expand')\n  const alt = getAlt(alter)\n  const attributes = compact ? emptyO : { style: { flexBasis: `${94 / maxCols}%` } }\n  const expand = compact ? 'right' : 'down'\n  const collapse = compact ? 'left' : 'up'\n  return (\n    <div className={`facetFilter ${compact ? 'compact' : emptyS}`} >\n      <div className={`facetHead ${compact ? 'compact' : emptyS}`} >\n        <CheckboxI\n          table={table}\n          filterId={filterId}\n          filterSetting={filterSetting}\n          filterTag={filterTag}\n        /> {filterLabel}{' '}\n        {\n          compact\n          ? null\n          : <Stat\n              subTotal={filteredAmount}\n              total={filteredAmountOthers}\n              className={'facet-stat-all'}\n            />\n        }\n        {' '}\n        <span\n          className={`button-small fa fa-angle-${alt === 0 ? collapse : expand}`}\n          onClick={nextAlt}\n        />\n      </div>\n      {\n        alt === 0\n        ? <div className={`facet-container ${compact ? 'compact' : emptyS}`} >\n            {\n              Object.entries(fieldValues).map(([valueId, valueRep]) => (\n                <div\n                  key={valueId}\n                  className={`facet-row ${compact ? 'compact' : emptyS}`}\n                  {...attributes}\n                >\n                  <Facet\n                    className={`facet-value ${compact ? 'compact' : emptyS}`}\n                    table={table}\n                    filterSetting={filterSetting}\n                    filterTag={filterTag}\n                    filterId={filterId}\n                    valueId={valueId}\n                    valueRep={valueRep}\n                  />\n                  {\n                    compact\n                    ? null\n                    : <Stat\n                        className={'facet-stat'}\n                        subTotal={amounts[valueId]}\n                      />\n                  }\n                </div>\n              ))\n            }\n          </div>\n        : <div />\n      }\n    </div>\n  )\n}\n\nexport default connect(getAltSection)(ByValue)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ByValue.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { changeFacetAll, testAllChecks } from 'filters'\n\nconst indeterminate = states => !states.allTrue && !states.allFalse\n\nclass CheckboxI extends Component {\n  componentDidUpdate() {\n    const { props: { filterSetting } } = this\n    const states = testAllChecks(filterSetting)\n    this.dom.indeterminate = indeterminate(states)\n  }\n  handleCheck = () => {\n    const { props: {filterSetting, table, filterTag, filterId, dispatch } } = this\n    const states = testAllChecks(filterSetting)\n    return dispatch(changeFacetAll(table, filterTag, filterId, this.dom.indeterminate || !states.allTrue))\n  }\n  setIndeterminate = domElem => {\n    const { props: { filterSetting } } = this\n    const states = testAllChecks(filterSetting)\n    if (domElem) {\n      this.dom = domElem\n      domElem.indeterminate = indeterminate(states)\n    }\n  }\n  render() {\n    const { props: { filterSetting } } = this\n    const states = testAllChecks(filterSetting)\n    return (\n      <input\n          ref={this.setIndeterminate}\n          type={'checkbox'}\n          checked={states.allTrue}\n          onChange={this.handleCheck}\n      />\n    )\n  }\n}\n\nexport default connect()(CheckboxI)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/CheckboxI.jsx","import React from 'react'\n\nimport DocMd from 'DocMd'\nimport DocPdf from 'DocPdf'\nimport DocHtml from 'DocHtml'\nimport NotFound from 'NotFound'\n\nconst docType = {\n  md: DocMd,\n  pdf: DocPdf,\n  html: DocHtml,\n}\n\nexport default ({ location: { pathname: docPath } }) => {\n  const [docDir, docFile] = /^(.*)\\/([^/]+)$/g.exec(docPath).slice(1)\n  const [docName, docExt] = /^(.*)\\.([^.]+)$/g.exec(docFile).slice(1)\n  const { [docExt]: DocClass } = docType\n  const docTag = `${docDir}/${docName}.${docExt}`\n  return DocClass == null\n  ? <NotFound splat={`document ${docPath}`} />\n  : <DocClass\n      alterSection={docTag}\n      docDir={docDir}\n      docName={docName}\n      docExt={docExt}\n    />\n}\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Doc.jsx","import React from 'react'\n\nexport default ({ docDir, docName, docExt }) => {\n  const src = `/api/file${docDir}/${docName}.${docExt}`\n  return (\n    <iframe\n      height={'100%'}\n      width={'100%'}\n      src={src}\n    />\n  )\n}\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/DocHtml.jsx","import React, {Component} from 'react'\nimport { connect } from 'react-redux'\nimport Markdown from 'react-markdown'\nimport { Link } from 'react-router'\n\nimport { combineSelectors } from 'utils'\n\nimport { getDoc, needDoc, changedDoc, fetchDoc } from 'docs'\nimport { getAltSection, compileAlternatives } from 'alter'\n\nimport ErrorBoundary from 'ErrorBoundary'\n\nconst RouterLink = ({ children, href }) => (\n  href.match(/^(https?:)?\\/\\//)\n  ? <a href={href} >{children}</a>\n  : <Link to={href} >{children}</Link>\n)\nconst renderers = { Link: RouterLink }\n\nclass DocMd extends Component {\n  render() {\n    const { props: { alter, alterSection, text, docName, dispatch } } = this\n\n    if (needDoc({ text })) {return <div>{`No document ${docName}`}</div>}\n\n    const { getAlt, nextAlt } = compileAlternatives(alterSection, 2, 0, dispatch)('format')\n    const alt = getAlt(alter)\n\n    return (\n      <ErrorBoundary>\n        <div style={{paddingLeft: '0.5em'}} >\n          <p style={{float: 'right'}} >\n            <a\n              href={'#'}\n              className={`control fa fa-${alt === 0 ? 'hand-o-down' : 'file-code-o'}`}\n              data-rh={`${alt === 0 ? 'markdown source' : 'formatted'}`}\n              onClick={nextAlt}\n            />\n          </p>\n          {\n            alt === 0\n            ? <div>\n                <Markdown\n                  source={text}\n                  renderers={renderers}\n                />\n              </div>\n            : <div>\n                <pre className={'md-source'} >{text}</pre>\n              </div>\n          }\n        </div>\n      </ErrorBoundary>\n    )\n  }\n  componentDidMount() {\n    const { props, props: {dispatch } } = this\n    dispatch(fetchDoc(props))\n  }\n  componentDidUpdate(prevProps) {\n    const { props, props: {dispatch } } = this\n    if (changedDoc(props, prevProps)) {\n      dispatch(fetchDoc(props))\n    }\n  }\n}\n\nconst getInfo = combineSelectors(getDoc, getAltSection)\n\nexport default connect(getInfo)(DocMd)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/DocMd.jsx","import React from 'react'\n\nexport default ({ docDir, docName, docExt }) => {\n  const href = `/api/file${docDir}/${docName}.${docExt}`\n  const iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream\n  return iOS\n  ? <p>\n      <a target={'_blank'} rel={'noopener noreferrer'} href={href} >{docName}</a>{' (open pdf in a new tab)'}\n    </p>\n  : <object\n      height={'100%'}\n      width={'100%'}\n      data={href}\n      type={'application/pdf'}\n    >\n      <a target={'_blank'} rel={'noopener noreferrer'} href={href} >{docName}</a>{' (open pdf in a new tab)'}\n    </object>\n}\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/DocPdf.jsx","import React, { Component } from 'react'\nimport L from 'leaflet'\n\nimport { countryBorders } from 'europe.geo'\nimport { emptyO } from 'utils'\n\nimport ByValue from 'ByValue'\n\nconst mapOptions = {\n  HEIGHT: 250,\n  MAX_RADIUS: 25,\n  LEVEL_OFF: 10,\n  ZOOM_INIT: 3,\n  MAP_CENTER: [52, 12],\n  MAP_BOUNDS: [[30, -20], [70, 40]],\n  MARKER_COLOR: {\n    [true]: {\n      color: '#008800',\n      fillColor: '#00cc00',\n    },\n    [false]: {\n      color: '#888844',\n      fillColor: '#bbbb66',\n    },\n  },\n  MARKER_SHAPE: {\n    weight: 1,\n    fill: true,\n    fillOpacity: 0.8,\n  },\n  COUNTRY_STYLE: {\n    [true]: {\n      color: '#884422',\n      weight: 2,\n      fill: true,\n      fillColor: '#aa7766',\n      fillOpacity: 1,\n    },\n    [false]: {\n      color: '#777777',\n      weight: 1,\n      fill: true,\n      fillColor: '#bbbbbb',\n      fillOpacity: 1,\n    },\n  },\n}\n\nconst computeRadius = (_id, filteredAmountOthers, amounts) => {\n  const amount = amounts ? (amounts[_id] || 0) : 0\n  if (amount === 0) {return 0}\n  const { MAX_RADIUS, LEVEL_OFF } = mapOptions\n  const proportional = MAX_RADIUS * amount / filteredAmountOthers\n  if (filteredAmountOthers < LEVEL_OFF) {return proportional}\n  return LEVEL_OFF * Math.sqrt(proportional)\n}\n\nclass EUMap extends Component {\n  constructor(props) {\n    super(props)\n    this.features = {}\n  }\n  setMap = dom => {if (dom) {this.dom = dom}}\n\n  render() {\n    const { props, setMap } = this\n    return (\n      <div>\n        <div\n          ref={setMap}\n        />\n        <ByValue {...props} />\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    const {\n      props: { filterSetting, filteredAmountOthers, amounts, tables: { country } },\n      dom,\n    } = this\n    const { HEIGHT, MAP_CENTER, ZOOM_INIT, MAP_BOUNDS, MARKER_COLOR, MARKER_SHAPE, COUNTRY_STYLE } = mapOptions\n    dom.style.height = HEIGHT\n    this.map = L.map(dom, {\n      attributionControl: false,\n      center: MAP_CENTER,\n      zoom: ZOOM_INIT,\n      maxBounds: MAP_BOUNDS,\n    })\n    const { allIds, entities } = country\n    this.idFromIso = {}\n    this.inDariah = {}\n    allIds.forEach(_id => {\n      const { [_id]: { values: { iso, isMember } } } = entities\n      this.idFromIso[iso] = _id\n      this.inDariah[iso] = isMember\n    })\n    L.geoJSON(countryBorders, {\n      style: feature => COUNTRY_STYLE[this.inDariah[feature.properties.iso2]],\n      onEachFeature: feature => {\n        const { properties: { iso2, lat, lng } } = feature\n        if (this.inDariah[iso2]) {\n          const { idFromIso: { [iso2]: _id } } = this\n          const { [_id]: isOn = false } = filterSetting || emptyO\n          const marker = L.circleMarker([lat, lng], {\n            ...MARKER_COLOR[isOn],\n            radius: computeRadius(_id, filteredAmountOthers, amounts),\n            ...MARKER_SHAPE,\n            pane: 'markerPane',\n          }).addTo(this.map)\n          this.features[iso2] = marker\n        }\n      },\n    }).addTo(this.map)\n  }\n\n  componentDidUpdate() {\n    const { props: { filterSetting, filteredAmountOthers, amounts } } = this\n    const { MARKER_COLOR } = mapOptions\n    Object.entries(this.features).forEach(([iso2, marker]) => {\n      const { idFromIso: { [iso2]: _id } } = this\n      const { [_id]: isOn = false } = filterSetting || emptyO\n      marker.setRadius(computeRadius(_id, filteredAmountOthers, amounts))\n      marker.setStyle(MARKER_COLOR[isOn])\n    })\n  }\n}\n\nEUMap.displayName = 'EUMap'\n\nexport default EUMap\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/EUMap.jsx","import { editControl } from 'edit'\n\nexport default editControl(true)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/EditControl.jsx","import React from 'react'\n\nexport default ({ perm, fixed, button, onClick }) => (\n  !fixed && perm.delete\n  ? <div\n      className={`grid-cell ${button} inlineR error-o fa fa-trash delete`}\n      data-rh={'delete this record'}\n      data-rh-at={'bottom'}\n      onClick={onClick}\n    />\n    : null\n)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/EditDelete.jsx","import React from 'react'\n\nexport default ({ type, dirty }) => [\n  <div key={'G'} className=\"edit-help\">\n    {\n      dirty\n      ? <div className={'help-item'} >\n          {'Press '}\n           <span className={'help-code'}>{'ESC'}</span>\n          {' to cancel'}\n        </div>\n      : null\n    }\n    <div className={'help-item'} >\n      {'Press '}\n      <span className={'help-code'}>{'TAB'}</span>\n      {' or click outside this field to save'}\n    </div>\n  </div>,\n  type == 'markdown'\n  ? <div key={'M'} className=\"edit-help\">\n      <div className={'help-item'}>\n        <span className={'help-code'}>{'['}</span>{'link text'}<span className={'help-code'}>{']('}</span>{'url'}<span className={'help-code'}>{')'}</span>\n      </div>\n      <div className={'help-item'}>\n        <span className={'help-code'}>{'*'}</span><i>{'italic'}</i><span className={'help-code'}>{'*'}</span>\n      </div>\n      <div className={'help-item'}>\n        <span className={'help-code'}>{'**'}</span><b>{'bold'}</b><span className={'help-code'}>{'**'}</span>\n      </div>\n      <div className={'help-item'}>\n        <span className={'help-code'}>{'`'}</span><code>{'code'}</code><span className={'help-code'}>{'`'}</span>\n      </div>\n      <div className={'help-item'}>\n        <span className={'help-code'}>{'# '}</span><span className={'mdh1'}>{'Heading1'}</span>\n      </div>\n      <div className={'help-item'}>\n        <span className={'help-code'}>{'## '}</span><span className={'mdh2'}>{'Heading2'}</span>\n      </div>\n      <div className={'help-item'}>\n        <span className={'help-code'}>{'* '}</span><span className={'mduli'}>{'bullet item'}</span>\n      </div>\n      <div className={'help-item'}>\n        <span className={'help-code'}>{'1. '}</span><span className={'mdoli'}>{'numbered item'}</span>\n      </div>\n      <div className={'help-item'}>\n        <span className={'help-code'}>{'> '}</span><span className={'mdbq'}>{'block quote'}</span>\n      </div>\n    </div>\n  : null,\n]\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/EditHelp.jsx","import React from 'react'\n\nimport { DETAILS } from 'tables'\n\nexport default ({\n  perm, select, fixed, item, button, onInsert,\n}) => {\n  const thing = item[0]\n  return (!fixed && perm != null && perm.insert && (!perm.needMaster || select == DETAILS))\n    ? <span\n        className={`fa fa-plus ${button}`}\n        data-rh={`make a new ${thing}`}\n        data-rh-at={'bottom'}\n        onClick={onInsert}\n      />\n    : null\n}\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/EditInsert.jsx","import { reduxForm } from 'redux-form'\n\nimport { editControl } from 'edit'\n\nexport default reduxForm({\n  destroyOnUnmount: false,\n  enableReinitialize: true,\n  keepDirtyOnReinitialize: true,\n})(editControl(false))\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/EditStatus.jsx","import React, { Component } from 'react'\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false, error: null }\n  }\n\n  componentDidCatch(error) {\n    this.setState({ hasError: true, error: error.message })\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className={'error-boundary'}>\n          {this.state.error}\n        </div>\n      )\n    }\n    return this.props.children\n  }\n}\n\nexport default ErrorBoundary\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ErrorBoundary.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { emptyS } from 'utils'\n\nimport { getAltSection, compileAlternatives } from 'alter'\n\nconst nbsp = ' '\n\nconst cleanPut = text => text || null\n\nconst cleanWrap = (text, next, className) =>\n  text\n  ? <span className={className}>{`${nbsp}${text}${next ? nbsp : emptyS}`}</span>\n  : null\n\nconst Expand = ({\n  alter, alterSection, alterTag,\n  initAlt,\n  headActive, headLine, full,\n  className,\n  iconOpen, iconClose,\n  titleOpen, titleClose,\n  dispatch,\n}) => {\n  const init = initAlt || 0\n  const { getAlt, nextAlt } = compileAlternatives(alterSection, 2, init, dispatch)(alterTag)\n  const alt = getAlt(alter)\n  const iOpen = iconOpen || 'angle-down'\n  const iClose = iconClose || 'angle-up'\n  const tOpen = titleOpen || 'expand'\n  const tClose = titleClose || 'collapse'\n  return (\n    <div className={className}>\n      <span className={'vtop'}>\n        {nbsp}\n        <span\n          className={`link vtop fa fa-${alt === 0 ? iOpen : iClose}`}\n          data-rh={alt === 0 ? tOpen : tClose}\n          onClick={nextAlt}\n        >\n          {cleanWrap(headActive, headLine, 'body')}\n        </span>\n        {cleanPut(headLine)}\n      </span>\n      {\n        alt == 0\n        ? null\n        : <div>{full}</div>\n      }\n    </div>\n  )\n}\n\nconst ExpandHeadPure = ({\n  alter, alterSection, alterTag,\n  initAlt,\n  headActive, headLine,\n  className,\n  iconOpen, iconClose,\n  titleOpen, titleClose,\n  dispatch,\n}) => {\n  const init = initAlt || 0\n  const { getAlt, nextAlt } = compileAlternatives(alterSection, 2, init, dispatch)(alterTag)\n  const alt = getAlt(alter)\n  const iOpen = iconOpen || 'angle-down'\n  const iClose = iconClose || 'angle-up'\n  const tOpen = titleOpen || 'expand'\n  const tClose = titleClose || 'collapse'\n  return (\n    <div className={`vtop ${className}`}>\n      <span\n        className={`link vtop fa fa-${alt === 0 ? iOpen : iClose}`}\n        data-rh={alt === 0 ? tOpen : tClose}\n        onClick={nextAlt}\n      >\n        {cleanWrap(headActive, headLine, 'body')}\n      </span>\n      {cleanPut(headLine)}\n    </div>\n  )\n}\n\nconst ExpandBodyPure = ({\n  alter, alterSection, alterTag,\n  initAlt,\n  full,\n  className,\n  dispatch,\n}) => {\n  const init = initAlt || 0\n  const { getAlt } = compileAlternatives(alterSection, 2, init, dispatch)(alterTag)\n  const alt = getAlt(alter)\n  return (\n    alt == 0\n    ? null\n    : <div className={className}>\n        {\n          <div>{full}</div>\n        }\n      </div>\n  )\n}\n\nexport const ExpandHead = connect(getAltSection)(ExpandHeadPure)\nexport const ExpandBody = connect(getAltSection)(ExpandBodyPure)\n\nexport default connect(getAltSection)(Expand)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Expand.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { emptyO } from 'utils'\nimport { handlE } from 'handle'\n\nimport { changeFacet } from 'filters'\n\nconst Facet = ({ table, filterTag, filterId, valueId, valueRep, filterSetting, className, dispatch }) => {\n  const { [valueId]: isOn = false } = filterSetting || emptyO\n  return (\n    <span className={className}>\n      <input\n        type={'checkbox'}\n        checked={isOn}\n        className={'facet'}\n        onChange={handlE(dispatch, changeFacet, table, filterTag, filterId, valueId, !isOn)}\n      />\n      {` ${valueRep}`}\n    </span>\n  )\n}\n\nexport default connect()(Facet)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Facet.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport { Field, FieldArray } from 'redux-form'\n\nimport { compileActive } from 'workflow'\nimport { validation, normalization, getValType } from 'fields'\n\nimport InputMulti from 'InputMulti'\nimport RelSelect from 'RelSelect'\n\nconst FieldEdit = ({\n  alter, field,\n  tables, table, eId,\n  dispatch, allowed,\n  reset,\n  submitValues,\n  ...props\n}) => {\n  const { [table]: { fieldSpecs } } = tables\n  const { [field]: { valType, valid, multiple } } = fieldSpecs\n  if (typeof valType === 'string') {\n    const typing = getValType(valType)\n    const { component, type, props: componentProps } = typing\n    const { [valid || valType]: validate } = validation\n    const { [valid || valType]: normalize } = normalization\n    if (multiple) {\n      return (\n        <FieldArray\n          name={field}\n          component={InputMulti}\n          componentSingle={component}\n          {...componentProps}\n          validateSingle={validate}\n          normalizeSingle={normalize}\n          tables={tables}\n          table={table}\n          eId={eId}\n          type={type}\n          valType={valType}\n          rerenderOnEveryChange={true}\n          reset={reset}\n          submitValues={submitValues}\n          {...props}\n        />\n      )\n    }\n    else {\n      return (\n        <Field\n          name={field}\n          component={component}\n          {...componentProps}\n          validate={validate}\n          normalize={normalize}\n          tables={tables}\n          table={table}\n          eId={eId}\n          type={type}\n          reset={reset}\n          submitValues={submitValues}\n          {...props}\n        />\n      )\n    }\n  }\n  else {\n    const { allowNew, popUpIfEmpty, inactive } = valType\n    const activeItems = inactive ? compileActive(tables, field) : null\n    const selectTag = `${table}-${eId}-${field}`\n    return (\n      <Field\n        name={field}\n        component={RelSelect}\n        selectTag={selectTag}\n        field={field}\n        multiple={multiple}\n        allowNew={allowNew}\n        popUpIfEmpty={popUpIfEmpty}\n        tables={tables}\n        table={table}\n        eId={eId}\n        allowed={allowed}\n        activeItems={activeItems}\n        inactive={inactive}\n        submitValues={submitValues}\n        {...props}\n      />\n    )\n  }\n}\n\nexport default connect()(FieldEdit)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/FieldEdit.jsx","//import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { emptyO } from 'utils'\nimport { compileActive } from 'workflow'\nimport { wrappedRepr } from 'fields'\n\nimport { getSettings } from 'settings'\n\nconst FieldRead = ({ settings, tables, table, field, relField, myValues }) => {\n  const { [table]: { fieldSpecs } } = tables\n  const { [field]: { valType, multiple } } = fieldSpecs\n  const { inactive = null } = typeof valType === 'object' ? valType : emptyO\n  const activeItems = inactive ? compileActive(tables, field) : null\n  return wrappedRepr(tables, table, field, valType, multiple, relField, activeItems, inactive, myValues, settings)\n}\n\nexport default connect(getSettings)(FieldRead)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/FieldRead.jsx","import { makeSubmitTime } from 'fields'\n\nexport default ({\n  widget,\n  setValue,\n  input: { onChange },\n  submitValues,\n}) => {\n  const submitTime = makeSubmitTime(submitValues)\n  const onChangeSave = () => {onChange(setValue); submitTime()}\n  return widget(onChangeSave)\n}\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/FieldSet.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { emptyS, emptyO } from 'utils'\n\nimport ErrorBoundary from 'ErrorBoundary'\nimport Fulltext from 'Fulltext'\nimport ByValue from 'ByValue'\nimport EUMap from 'EUMap'\n\nconst filterClass = {\n  Fulltext,\n  EUMap,\n  ByValue,\n}\n\nconst Filter = ({\n  filters, tables, table, filterTag, listIds,\n  filteredAmount, filteredAmountOthers, amounts,\n  compact,\n}) => {\n  const { [table]: filterData = emptyO } = filters\n  const { [table]: { fields, filterList } } = tables\n  const { [filterTag]: filterSettings = emptyO } = filterData\n  return (\n    filterList == null\n    ? <div>\n        {'No filters for this list'}\n      </div>\n      : <ErrorBoundary>\n          <div className={`filterSequence ${compact ? 'compact' : emptyS}`} >\n            {filterList.filter(x => fields[x.field]).map((filter, filterId) => {\n              const { type } = filter\n              const { [type]: Fclass } = filterClass\n              const { [filterId]: filterSetting } = filterSettings\n              return (\n                <Fclass\n                  key={filterId}\n                  alterSection={`filter-${table}-${filterId}`}\n                  tables={tables}\n                  table={table}\n                  filterTag={filterTag}\n                  filterSetting={filterSetting}\n                  listIds={listIds}\n                  filterId={filterId}\n                  filterField={filter.field}\n                  filterRelField={filter.relField}\n                  filterLabel={filter.label}\n                  maxCols={filter.maxCols}\n                  filteredAmount={filteredAmount}\n                  filteredAmountOthers={filteredAmountOthers[filterId]}\n                  amounts={amounts[filterId]}\n                  expanded={filter.expanded}\n                  compact={compact}\n                />\n              )}\n            )}\n          </div>\n        </ErrorBoundary>\n  )\n}\n\nexport default connect()(Filter)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Filter.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { emptyS } from 'utils'\n\nimport { handlEV } from 'handle'\n\nimport { changeFulltext } from 'filters'\n\nimport Stat from 'Stat'\n\nconst Fulltext = ({\n  table, filterTag,\n  filterId, filterLabel,\n  filterSetting = emptyS,\n  filteredAmount, filteredAmountOthers,\n  compact,\n  dispatch,\n}) => (\n  <div className={'fulltext'} data-rh={`Search in ${filterLabel}`} >\n    <input\n      type={'text'}\n      className={`search ${compact ? 'compact' : emptyS}`}\n      placeholder={`search${compact ? emptyS : ` in ${filterLabel}`}`}\n      value={filterSetting}\n      onChange={handlEV(dispatch, changeFulltext, table, filterTag, filterId)}\n    />{' '}\n    {\n      compact\n      ? null\n      : <Stat subTotal={filteredAmount} total={filteredAmountOthers} className={'fulltext-stat'} />\n    }\n  </div>\n)\n\nexport default connect()(Fulltext)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Fulltext.jsx","import React from 'react'\n\nimport { editClass, makeSubmit, makeSubmitTime, makeReset } from 'fields'\n\nimport EditHelp from 'EditHelp'\n\nexport default ({\n  meta: { dirty, invalid, submitting, error },\n  input, type,\n  reset, submitValues,\n}) => {\n  const submit = type === 'checkbox'\n  ? makeSubmitTime(submitValues)\n  : makeSubmit(dirty, invalid, submitting, submitValues)\n  const onCancel = makeReset(type, reset)\n  const onAction = type === 'checkbox'\n  ? { onClick: submit }\n  : { onBlur: submit }\n  return (\n    <span>\n      <input\n        type={type}\n        className={editClass(dirty, invalid)}\n        {...input}\n        {...onAction}\n        {...onCancel}\n      />\n      {error && <span className={'invalid diag'}>{error}</span>}\n      <EditHelp type={'text'} dirty={dirty} />\n    </span>\n  )\n}\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Input.jsx","import React from 'react'\nimport { Field } from 'redux-form'\n\nimport { editClass, makeSubmit, makeSubmitTime } from 'fields'\n\nconst fieldRemove = (fields, i, submit) => () => {fields.remove(i); submit()}\nconst fieldPush = (fields, submit) => () => {fields.push(); submit()}\n/* N.B.\n * fieldRemove and fieldPush MUST NOT be memoized.\n * Otherwise they may become bound to the wrong form.\n * This happens if you navigate with react-router between forms.\n */\n\nexport default ({\n  componentSingle, validateSingle, normalizeSingle,\n  meta: { dirty, invalid, submitting, error },\n  fields, table, eId, valType,\n  nameC,\n  reset, submitValues,\n  ...props\n}) => {\n  const submit = makeSubmit(dirty, invalid, submitting, submitValues)\n  const submitTime = makeSubmitTime(submitValues)\n  return (\n    <div\n      className={`${editClass(dirty, invalid)} multi-field ${valType}`}\n    >\n      {fields.map((field, i) =>\n        <div\n          key={field}\n          className={'multi-content'}\n        >\n          <span\n            className={'button-small'}\n            data-rh={'remove'}\n            onClick={fieldRemove(fields, i, submitTime)}\n          >{'×'}</span>\n          {'\\xa0'}\n          <Field\n            name={field}\n            component={componentSingle}\n            validate={validateSingle}\n            normalize={normalizeSingle}\n            label={i}\n            table={table}\n            eId={eId}\n            reset={reset}\n            submitValues={submit}\n            {...props}\n          />\n        </div>\n      )}\n      <div\n        className={'button-small fa fa-plus multi-control'}\n        data-rh={'more entries'}\n        onClick={fieldPush(fields, submitTime)}\n      />\n      {error && <p className={'invalid diag'}>{error}</p>}\n    </div>\n  )\n}\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/InputMulti.jsx","import { connect } from 'react-redux'\nimport { reduxForm } from 'redux-form'\n\nimport { emptyO } from 'utils'\n\nimport { applyEditTemplate } from 'presentation'\nimport { onSubmitSuccess } from 'fields'\nimport { toDb, headEntity } from 'tables'\n\nconst ItemAction = ({\n  settings,\n  tables, table, eId,\n  linkField,\n  fieldFragments,\n  handleSubmit,\n  dispatch,\n}) => {\n  const head = headEntity(tables, table, eId, settings)\n  const submitValues = handleSubmit(toDb(table, eId, head, dispatch))\n  const {\n    [table]: {\n      fieldSpecs: {\n        [linkField]: {\n          valType: { relTable: masterTable } = emptyO,\n        } = emptyO },\n    },\n  } = tables\n  const kind = masterTable ? 'detail' : 'main'\n  return applyEditTemplate(\n    settings, tables, table,\n    `${kind}Action`,\n    masterTable, eId,\n    fieldFragments, null,\n    submitValues,\n  )\n}\n\nexport default connect()(reduxForm({\n  destroyOnUnmount: false,\n  enableReinitialize: true,\n  keepDirtyOnReinitialize: false,\n  touchOnBlur: true,\n  touchOnChange: false,\n  onSubmitSuccess,\n})(ItemAction))\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ItemAction.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { emptyO } from 'utils'\nimport { dealWithProvenance } from 'fields'\n\nimport { getSettings } from 'settings'\nimport { needValues, fetchItem, headEntity } from 'tables'\n\nimport ErrorBoundary from 'ErrorBoundary'\nimport ItemForm from 'ItemForm'\n\nclass ItemContainer extends Component {\n  render() {\n    const {\n      props: {\n        settings, filters, tables, table, eId,\n        masterId, linkField,\n        isactive, startMode, fixed, border,\n      },\n    } = this\n    const {\n      [table]: {\n          entities = emptyO,\n          entities: {\n            [eId]: {\n                fields,\n                values: initialValues,\n                perm,\n                workflow,\n            } = emptyO,\n          },\n      } = emptyO,\n    } = tables\n    if (needValues(entities, eId)) {return <div />}\n\n    const alterSection = `edit-${table}-${eId}`\n    return (\n      <ErrorBoundary>\n        <ItemForm\n          filters={filters}\n          tables={tables}\n          table={table}\n          eId={eId}\n          masterId={masterId}\n          linkField={linkField}\n          alterSection={alterSection}\n          isactive={isactive}\n          startMode={startMode}\n          key={`${table}-${eId}`}\n          initialValues={initialValues}\n          perm={perm}\n          workflow={workflow}\n          fields={dealWithProvenance(settings, fields)}\n          fixed={fixed}\n          border={border}\n        />\n      </ErrorBoundary>\n    )\n  }\n  openItem() {\n    const { props: { settings, tables, table, eId, inhibitFetch, dispatch } } = this\n    const { [table]: { entities = emptyO } } = tables\n    const head = headEntity(tables, table, eId, settings)\n    if (!inhibitFetch && needValues(entities, eId)) {dispatch(fetchItem(table, eId, head))}\n  }\n  componentDidMount() {this.openItem()}\n  componentDidUpdate() {this.openItem()}\n}\n\nexport default connect(getSettings)(ItemContainer)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ItemContainer.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { emptyS } from 'utils'\n\nimport { DETAILS } from 'tables'\nimport { makeTag } from 'filters'\nimport { getAltSection, compileAlternatives } from 'alter'\n\nimport ListGrid from 'ListGrid'\nimport ListPlain from 'ListPlain'\nimport ListFilter from 'ListFilter'\n\nconst ItemDetails = ({ alter, alterSection, filters, tables, table, eId, detailFragments, dispatch }) => {\n  if (detailFragments.length == 0) {return null}\n  const makeAlternatives = compileAlternatives(alterSection, 2, 1, dispatch)\n  return (\n    <div className={'grid fragments'}>\n      {\n        detailFragments.map(({\n          name, detailTitle, detailTable, linkField, detailItem, detailListIds, detailPerm, detailSpecs,\n        }) => {\n          const nDetails = detailListIds.length\n          const { getAlt, nextAlt } = makeAlternatives(name)\n          const alt = getAlt(alter)\n          const { mode, expand, border, filtered, fixed } = detailSpecs\n          const [detailThing, detailThings] = detailItem\n          const filterTag = makeTag(DETAILS, eId, linkField)\n          const gridTag = `${table}-${name}-${eId}`\n          return (\n            <div key={name} className={'grid-row'} >\n              {\n                !expand\n                ? <div\n                    className={'link detail-control'}\n                    data-rh={'show detail records'}\n                    onClick={nextAlt}\n                  >\n                    <span className={`fa fa-angle-${alt === 0 ? 'down' : 'up'}`} />\n                    {\n                      alt === 0\n                      ? `${nDetails} ${nDetails === 1 ? detailThing : detailThings}`\n                      : emptyS\n                    }\n                  </div>\n                : null\n              }\n              <div className={'detail-body'} >\n                {\n                  alt === 1\n                  ? filtered\n                    ? <ListFilter\n                        filters={filters}\n                        tables={tables}\n                        table={detailTable}\n                        listIds={detailListIds}\n                        perm={detailPerm}\n                        select={DETAILS}\n                        mode={mode}\n                        compact={true}\n                        title={detailTitle}\n                        gridTag={gridTag}\n                        filterTag={filterTag}\n                        masterId={eId}\n                        linkField={linkField}\n                        expand={expand}\n                        border={border}\n                        fixed={fixed}\n                      />\n                    : mode === 'list'\n                      ? <ListPlain\n                          alterSection={`list-${detailTable}-${DETAILS}`}\n                          filters={filters}\n                          tables={tables}\n                          table={detailTable}\n                          listIds={detailListIds}\n                          perm={detailPerm}\n                          select={DETAILS}\n                          title={detailTitle}\n                          masterId={eId}\n                          linkField={linkField}\n                          expand={expand}\n                          border={border}\n                          fixed={fixed}\n                        />\n                      : mode === 'grid'\n                        ? <ListGrid\n                            alterSection={`list-${detailTable}-${DETAILS}`}\n                            filters={filters}\n                            tables={tables}\n                            table={detailTable}\n                            listIds={detailListIds}\n                            perm={detailPerm}\n                            select={DETAILS}\n                            gridTag={gridTag}\n                            masterId={eId}\n                            linkField={linkField}\n                            fixed={fixed}\n                          />\n                        : <span>{`unknown display mode \"${mode}\" for ${detailThings}`}</span>\n                  : null\n                }\n              </div>\n            </div>\n          )\n        })\n      }\n    </div>\n  )\n}\n\nexport default connect(getAltSection)(ItemDetails)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ItemDetails.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport { reduxForm } from 'redux-form'\n\nimport { emptyO } from 'utils'\n\nimport { applyEditTemplate } from 'presentation'\nimport { onSubmitSuccess, itemEditField } from 'fields'\nimport { toDb, headEntity } from 'tables'\n\nimport ErrorBoundary from 'ErrorBoundary'\nimport FieldRead from 'FieldRead'\nimport FieldEdit from 'FieldEdit'\nimport EditControl from 'EditControl'\n\nconst ItemEdit = ({\n  settings,\n  tables, table, eId,\n  linkField,\n  dirty, invalid, submitting, reset, error,\n  fieldFragments,\n  handleSubmit,\n  nextAlt,\n  dispatch,\n}) => {\n  const head = headEntity(tables, table, eId, settings)\n  const submitValues = handleSubmit(toDb(table, eId, head, dispatch))\n  const editControlProps = {\n    form: `${table}-${eId}`,\n    dirty, invalid, submitting, reset, error,\n    nextAlt, handleSubmit: submitValues,\n  }\n  const editButton = <EditControl {...editControlProps} />\n  const {\n    [table]: {\n      fieldSpecs: {\n        [linkField]: {\n          valType: { relTable: masterTable } = emptyO,\n        } = emptyO },\n    },\n  } = tables\n  const kind = masterTable ? 'detail' : 'main'\n  return (\n    applyEditTemplate(settings, tables, table, `${kind}Edit`, masterTable, eId, fieldFragments, editButton, submitValues)\n    || <div>\n        <form>\n          {editButton}\n          <div className={'grid fragments'}>{\n            fieldFragments.map(({\n              field, label, valType,\n              fragment: { editable, table, myValues, ...fieldProps },\n            }) => {\n              const thisEditable = editable && (typeof valType != 'object' || !valType.fixed)\n              return (\n                <ErrorBoundary key={field}>\n                  {\n                    itemEditField(\n                      field,\n                      label,\n                      thisEditable\n                      ? <FieldEdit\n                          field={field}\n                          tables={tables}\n                          table={table}\n                          eId={eId}\n                          submitValues={submitValues}\n                          reset={reset}\n                          {...fieldProps}\n                        />\n                      : <FieldRead\n                          field={field}\n                          tables={tables}\n                          table={table}\n                          eId={eId}\n                          myValues={myValues}\n                        />,\n                      thisEditable,\n                    )\n                  }\n                </ErrorBoundary>\n              )\n            })\n          }\n          </div>\n        </form>\n      </div>\n  )\n}\n\nexport default connect()(reduxForm({\n  destroyOnUnmount: false,\n  enableReinitialize: true,\n  keepDirtyOnReinitialize: false,\n  touchOnBlur: true,\n  touchOnChange: false,\n  onSubmitSuccess,\n})(ItemEdit))\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ItemEdit.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors, emptyS } from 'utils'\n\nimport { handle } from 'handle'\nimport { makeFields, makeDetails, someEditable } from 'fields'\n\nimport { delItem, headEntity, DETAILS } from 'tables'\nimport { getAltSection, compileAlternatives } from 'alter'\nimport { getSettings } from 'settings'\n\nimport ItemAction from 'ItemAction'\nimport ItemEdit from 'ItemEdit'\nimport ItemRead from 'ItemRead'\nimport ItemDetails from 'ItemDetails'\nimport EditDelete from 'EditDelete'\n\nconst ItemForm = props => {\n  const {\n    settings,\n    alter, alterSection,\n    filters,\n    tables, table, eId,\n    masterId, linkField,\n    isactive,\n    startMode,\n    fixed,\n    border,\n    initialValues,\n    fields, perm, workflow,\n    dispatch,\n  } = props\n  let { fieldFragments, detailFragments } = props\n  if (fieldFragments == null) {fieldFragments = makeFields(props)}\n  if (detailFragments == null) {detailFragments = makeDetails(props)}\n  const hasEditable = someEditable(fields, perm, workflow)\n  const { getAlt, nextAlt } = compileAlternatives(alterSection, 2, startMode, dispatch)('edit')\n  const alt = getAlt(alter)\n\n  const borderSwitch = border == null\n  ? emptyS\n  : hasEditable && alt === 1\n    ? border.edit != null && !border.edit\n      ? 'noBorder'\n      : emptyS\n    : border.read != null && !border.read\n      ? 'noBorder'\n      : emptyS\n\n  const editSwitch = hasEditable && alt === 1\n      ? 'edit'\n      : emptyS\n\n  const head = headEntity(tables, table, eId, settings)\n  return (\n    <div className={`itemRecord ${borderSwitch} ${editSwitch} ${isactive ? 'isactive' : emptyS}`} >\n      {\n        hasEditable && alt === 1\n        ? <div>\n            <EditDelete\n              perm={perm}\n              fixed={fixed}\n              button={'button-medium'}\n              onClick={handle(dispatch, delItem, table, eId, head)}\n            />\n            <ItemEdit\n              settings={settings}\n              tables={tables}\n              table={table}\n              eId={eId}\n              nextAlt={nextAlt}\n              form={`${table}-${eId}`}\n              initialValues={initialValues}\n              perm={perm}\n              masterId={masterId}\n              linkField={linkField}\n              fieldFragments={fieldFragments}\n            />\n          </div>\n        : <div>\n            {\n              hasEditable\n              ? <span\n                  className={`button-medium inlineL fa fa-pencil`}\n                  data-rh={`open an edit form for this record`}\n                  data-rh-at={'bottom'}\n                  onClick={nextAlt}\n                />\n              : null\n            }\n            <EditDelete\n              perm={perm}\n              fixed={fixed}\n              button={'button-medium'}\n              onClick={handle(dispatch, delItem, table, eId, head)}\n            />\n            <ItemRead\n              settings={settings}\n              tables={tables}\n              table={table}\n              eId={eId}\n              masterId={masterId}\n              linkField={linkField}\n              fieldFragments={fieldFragments}\n            />\n          </div>\n      }\n      <ItemAction\n          settings={settings}\n          tables={tables}\n          table={table}\n          eId={eId}\n          form={`${table}-${eId}`}\n          initialValues={initialValues}\n          linkField={linkField}\n          fieldFragments={fieldFragments}\n      />\n      <ItemDetails\n        alterSection={`list-${table}-${DETAILS}`}\n        detailFragments={detailFragments}\n        filters={filters}\n        tables={tables}\n        table={table}\n        eId={eId}\n      />\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getSettings, getAltSection)\n\nexport default connect(getInfo)(ItemForm)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ItemForm.jsx","import React from 'react'\n\nimport { emptyO } from 'utils'\n\nimport { applyTemplate } from 'presentation'\nimport { toFieldInfo, itemReadField } from 'fields'\n\nimport FieldRead from 'FieldRead'\n\nexport default ({\n  settings, tables, table, eId, fieldFragments,\n  linkField,\n}) => {\n  const {\n    [table]: {\n      fieldSpecs: {\n        [linkField]: {\n          valType: { relTable: masterTable } = emptyO,\n        } = emptyO,\n      },\n      entities: {\n        [eId]: {\n          workflow,\n        },\n      },\n    },\n  } = tables\n  const kind = masterTable ? 'detail' : 'main'\n  return (\n    applyTemplate(settings, tables, table, kind, masterTable, toFieldInfo(eId, fieldFragments), workflow)\n    || <div>\n        <div className={'grid fragments'}>{\n          fieldFragments.map(({\n            field, label,\n            fragment: { table: relTable, myValues },\n          }) => (\n            itemReadField(\n              field,\n              label,\n              <FieldRead\n                field={field}\n                tables={tables}\n                table={relTable}\n                eId={eId}\n                myValues={myValues}\n              />,\n              field,\n            )\n          ))\n        }\n        </div>\n      </div>\n  )\n}\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ItemRead.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { memoize } from 'memo'\nimport { emptyS } from 'utils'\nimport { makeFields, makeDetails } from 'fields'\n\nimport { getForms } from 'forms'\n\nimport EditStatus from 'EditStatus'\nimport FieldRead from 'FieldRead'\nimport ItemForm from 'ItemForm'\n\nconst putFieldFragments = (tables, fieldFragments, widthStyles) => fieldFragments.map(({\n  field,\n  fragment: { editable, table, myValues },\n}, i) => {\n  const widthStyle = widthStyles[i]\n  return (\n    <div\n      className={`grid-cell valueColGrid ${editable ? 'edit' : emptyS}`}\n      style={widthStyle}\n      key={field}\n    >\n      <FieldRead\n        field={field}\n        tables={tables}\n        table={table}\n        myValues={myValues}\n      />\n    </div>\n  )\n})\n\nconst putDetailFragments = (table, eId, detailFragments, widthStyles, nFields) => detailFragments.map(({\n  name, detailListIds,\n}, i) => {\n  const widthStyle = widthStyles[nFields + i]\n  const nDetails = detailListIds.length\n  return (\n    <div\n      key={name}\n      className={'grid-cell value-col-grid'}\n      style={widthStyle}\n    >\n      {nDetails}\n    </div>\n  )\n})\n\nconst fieldsButton = memoize((nextAlt, table, eId, mayUpdate, on) => (\n  mayUpdate\n  ? <span\n      className={`link fa fa-angle-${on ? 'down' : 'up'}`}\n      data-rh={`${on ? 'show' : 'close'} details of this record`}\n      onClick={nextAlt}\n    />\n  : null\n))\n\nconst ItemRow = ({\n  alt, nextAlt, filters, tables, form, table, eId, initialValues,\n  perm, workflow,\n  masterId, linkField,\n  isactive, fixed,\n  fields,\n  widthStyles,\n}) => {\n  const fieldFragments = makeFields({\n    tables, table, eId, initialValues, perm,\n    fields,\n  })\n  const detailFragments = makeDetails({ tables, table, eId })\n  const { update } = perm\n  const nFields = fieldFragments.length\n  const formTag = `${table}-${eId}`\n  const hasForm = form.has(formTag)\n  const alterSection = `edit-${table}-${eId}`\n  return (\n    <div className={isactive ? 'isactive' : emptyS}>\n      {\n        alt === 0\n        ? <div>\n            <div className={'grid-row'}>\n              <div className={'grid-status-cell'} >\n                {fieldsButton(nextAlt, table, eId, update, true)}\n                {hasForm ? <EditStatus form={`${table}-${eId}`} active={false} /> : null}\n              </div>\n              {putFieldFragments(tables, fieldFragments, widthStyles)}\n              {putDetailFragments(table, eId, detailFragments, widthStyles, nFields)}\n            </div>\n          </div>\n        : <div>\n            <div className={'grid-status-cell'} >\n              {fieldsButton(nextAlt, table, eId, update, false)}\n            </div>\n            <ItemForm\n              filters={filters}\n              tables={tables}\n              table={table}\n              eId={eId}\n              masterId={masterId}\n              linkField={linkField}\n              alterSection={alterSection}\n              isactive={isactive}\n              startMode={0}\n              initialValues={initialValues}\n              perm={perm}\n              workflow={workflow}\n              fields={fields}\n              fieldFragments={fieldFragments}\n              detailFragments={detailFragments}\n              fixed={fixed}\n            />\n          </div>\n      }\n    </div>\n  )\n}\n\nexport default connect(getForms)(ItemRow)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ItemRow.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors, withParams, emptyA } from 'utils'\nimport { loadExtra } from 'workflow'\n\nimport { getTables, needTables, fetchTables, MYIDS } from 'tables'\nimport { getFilters, makeTag } from 'filters'\n\nimport ErrorBoundary from 'ErrorBoundary'\nimport ListGrid from 'ListGrid'\nimport ListPlain from 'ListPlain'\nimport ListFilter from 'ListFilter'\n\nclass ListContainer extends Component {\n  render() {\n    const { props: { filters, tables, table, eId, select, mode, filtered } } = this\n    const complete = mode === 'grid'\n    if (needTables(tables, [[table, select, complete]].concat(loadExtra[table] || emptyA))) {return <div />}\n    const { [table]: tableData } = tables\n    const { title, item, perm, myIds, allIds } = tableData\n    const things = item[1]\n    const listIds = select === MYIDS ? myIds : allIds\n    const filterTag = makeTag(select, null, null)\n    return (\n      <ErrorBoundary>\n        {\n          filtered\n          ? <ListFilter\n              filters={filters}\n              tables={tables}\n              table={table}\n              navItem={eId}\n              listIds={listIds}\n              perm={perm}\n              select={select}\n              mode={mode}\n              title={title}\n              filterTag={filterTag}\n              gridTag={table}\n            />\n          : mode === 'list'\n            ? <ListPlain\n                alterSection={`list-${table}-${select}`}\n                filters={filters}\n                tables={tables}\n                table={table}\n                navItem={eId}\n                listIds={listIds}\n                select={select}\n                perm={perm}\n                title={title}\n              />\n            : mode === 'grid'\n              ? <ListGrid\n                  alterSection={`list-${table}-${select}`}\n                  filters={filters}\n                  tables={tables}\n                  table={table}\n                  navItem={eId}\n                  listIds={listIds}\n                  select={select}\n                  perm={perm}\n                  gridTag={table}\n                />\n              : <span>{`unknown display mode \"${mode}\" for ${things}`}</span>\n        }\n      </ErrorBoundary>\n    )\n  }\n  componentDidMount() {\n    const { props: { tables, table, select, mode, dispatch } } = this\n    const complete = mode === 'grid'\n    fetchTables(tables, [[table, select, complete]].concat(loadExtra[table] || emptyA), dispatch)\n  }\n  componentDidUpdate() {\n    const { props: { tables, table, select, mode, dispatch } } = this\n    const complete = mode === 'grid'\n    fetchTables(tables, [[table, select, complete]].concat(loadExtra[table] || emptyA), dispatch)\n  }\n}\n\nconst getInfo = combineSelectors(getTables, getFilters)\n\nexport default connect(getInfo)(withParams(ListContainer))\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ListContainer.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { emptyS, emptyO } from 'utils'\nimport { handle } from 'handle'\n\nimport { initFiltering, computeFiltering } from 'filters'\nimport { insertItem, DETAILS } from 'tables'\n\nimport ListPlain from 'ListPlain'\nimport ListGrid from 'ListGrid'\nimport Filter from 'Filter'\nimport OpenCloseAll from 'OpenCloseAll'\nimport EditInsert from 'EditInsert'\n\nconst initial = 0\nconst nAlts = 2\n\nclass ListFilter extends Component {\n  componentWillMount() {\n    const { props: { tables, table, filterTag, dispatch } } = this\n    dispatch(initFiltering(tables, table, filterTag))\n  }\n  componentWillReceiveProps(newProps) {\n    const {\n      tables,\n       table,\n       filterTag,\n       filters: { [table]: { [filterTag]: filterSettings } = emptyO },\n       dispatch,\n    } = newProps\n    const { props: { table: tableOld, filterTag: filterTagOld } } = this\n    if ((tableOld !== table || filterTagOld !== filterTag) && filterSettings == null) {\n      dispatch(initFiltering(tables, table, filterTag))\n    }\n  }\n  render() {\n    const {\n      props: {\n        tables,\n        filters,\n        table,\n        navItem,\n        perm,\n        select, masterId, linkField, expand, border, fixed,\n        listIds,\n        mode, compact,\n        title,\n        filterTag, gridTag,\n        dispatch,\n      },\n    } = this\n    const {\n      filteredIds, filteredAmountOthers, amounts,\n    } = computeFiltering(tables, filters, table, filterTag, listIds)\n    if (filteredIds == null) {return <div />}\n    const compactClass = compact ? 'compact' : emptyS\n    const { [table]: { item } } = tables\n    const things = item[1]\n    const alterSection = `list-${table}-${select}`\n    return (\n      <div className={`list-filter ${compactClass}`}>\n        {\n          select === DETAILS\n          ? <div>\n              <EditInsert\n                perm={perm}\n                select={select}\n                fixed={fixed}\n                item={item}\n                button={'button-medium'}\n                onInsert={handle(dispatch, insertItem, table, select, masterId, linkField)}\n              />\n              <OpenCloseAll\n                 table={table}\n                 listIds={listIds}\n                 item={item}\n                 button={'button-medium'}\n                 alterSection={alterSection}\n                 nAlts={nAlts}\n                 initial={initial}\n                 openAll={true}\n                 expand={expand}\n              />\n            </div>\n          : null\n        }\n        <div className={`filters ${compactClass}`}>\n          {\n            compact\n            ? null\n            : <p>{'Total '}<span className={'good-o'} >{listIds.length}</span></p>\n          }\n          <Filter\n            filters={filters}\n            tables={tables}\n            table={table}\n            filterTag={filterTag}\n            listIds={listIds}\n            filteredAmount={filteredIds.length}\n            filteredAmountOthers={filteredAmountOthers}\n            amounts={amounts}\n            compact={compact}\n          />\n        </div>\n        <div className={`list ${compactClass}`}>\n          {\n            mode === 'list'\n            ? <ListPlain\n                alterSection={alterSection}\n                filtered={true}\n                filters={filters}\n                tables={tables}\n                table={table}\n                navItem={navItem}\n                listIds={filteredIds}\n                perm={perm}\n                select={select}\n                title={title}\n                masterId={masterId}\n                linkField={linkField}\n                expand={expand}\n                border={border}\n                fixed={fixed}\n              />\n            : mode === 'grid'\n              ? <ListGrid\n                  alterSection={alterSection}\n                  filtered={true}\n                  filters={filters}\n                  tables={tables}\n                  table={table}\n                  navItem={navItem}\n                  listIds={filteredIds}\n                  perm={perm}\n                  select={select}\n                  gridTag={gridTag}\n                  masterId={masterId}\n                  linkField={linkField}\n                  fixed={fixed}\n                />\n              : <span>{`unknown display mode \"${mode}\" for ${things}`}</span>\n          }\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default connect()(ListFilter)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ListFilter.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { combineSelectors, emptyA } from 'utils'\nimport { handle } from 'handle'\n\nimport { getSettings } from 'settings'\nimport { getAltSection, compileAlternatives } from 'alter'\nimport { getGrid, compileSortedData, resetSort, addColumn, turnColumn, delColumn } from 'grid'\nimport { insertItem, DETAILS } from 'tables'\nimport { compileActive } from 'workflow'\n\nimport { dealWithProvenance } from 'fields'\n\nimport ItemRow from 'ItemRow'\nimport EditInsert from 'EditInsert'\nimport OpenCloseAll from 'OpenCloseAll'\n\nconst initial = 0\nconst nAlts = 2\n\nconst ListGrid = ({\n  alter, alterSection, filtered,\n  settings, filters, tables, table, listIds, select, perm: tablePerm,\n  masterId, linkField, fixed,\n  grid, gridTag,\n  dispatch,\n}) => {\n  const { [gridTag]: sortSpec = emptyA } = grid\n  const { [table]: tableData } = tables\n  const {\n    fields: givenFields,\n    fieldOrder: givenFieldOrder,\n    fieldSpecs,\n    item,\n    detailOrder,\n    entities,\n  } = tableData\n  const fields = dealWithProvenance(settings, givenFields)\n  const fieldOrder = givenFieldOrder.filter(field => fields[field])\n  const { length: nFields } = fieldOrder\n  const nDetails = detailOrder != null ? detailOrder.length : 0\n  const avLength = `${90 / nFields}%`\n  const widths = fieldOrder.map(field => {\n    const { [field]: { grid } } = fieldSpecs\n    if (grid == null) {\n      return { width: avLength, shrink: 0, grow: 1 }\n    }\n    const { width, grow, shrink } = grid\n    return {\n      width: width == null ? avLength : width,\n      shrink: shrink == null ? 0 : shrink,\n      grow: grow == null ? 0 : grow,\n    }\n  }).concat(new Array(nDetails).fill({ width: avLength, shrink: 0, grow: 0.3 }))\n  const widthStyles = widths.map(({ width, grow, shrink }) => ({\n    flex: `${grow} ${shrink} ${width}`,\n    overflow: 'auto',\n  }))\n\n  const sortedData = compileSortedData(tables, table, listIds, sortSpec, settings)\n  const makeAlternatives = compileAlternatives(alterSection, 2, 0, dispatch)\n  const activeItems = compileActive(tables, table)\n  const rows = []\n  for (const eId of sortedData) {\n    const { [eId]: { values: initialValues, perm, workflow } } = entities\n    const { getAlt, nextAlt } = makeAlternatives(eId)\n    const alt = getAlt(alter)\n    const isactive = (activeItems != null && activeItems.has(eId))\n    rows.push(\n      <ItemRow\n        key={`${table}-${eId}`}\n        alt={alt}\n        nextAlt={nextAlt}\n        filters={filters}\n        tables={tables}\n        table={table}\n        eId={eId}\n        masterId={masterId}\n        linkField={linkField}\n        isactive={isactive}\n        initialValues={initialValues}\n        perm={perm}\n        workflow={workflow}\n        fields={fields}\n        widthStyles={widthStyles}\n        fixed={fixed}\n      />\n    )\n  }\n  return (\n    <div>\n      {\n        !(filtered && select === DETAILS)\n        ? <div>\n            <EditInsert\n              perm={tablePerm}\n              select={select}\n              fixed={fixed}\n              item={item}\n              button={'button-medium'}\n              onInsert={handle(dispatch, insertItem, table, select, masterId, linkField)}\n            />\n            <OpenCloseAll\n              table={table}\n              listIds={listIds}\n              item={item}\n              button={'button-medium'}\n              alterSection={alterSection}\n              nAlts={nAlts}\n              initial={initial}\n              openAll={select == DETAILS}\n            />\n          </div>\n        : null\n      }\n      {\n        sortSpec.length !== 0\n        ? <p className={'sortspecs'} >\n            {'Sorted: '}\n            {\n              sortSpec.map(([column, direction]) => (\n                <span className={'sortcol'} key={column} >\n                  <span>{column}</span>\n                  <span className={`fa fa-arrow${direction === -1 ? 'down' : 'up'}`} />\n                </span>\n              ))\n            }\n            <span\n              className={'fa fa-close button-small'}\n              data-rh={'remove all sort options'}\n              onClick={handle(dispatch, resetSort, gridTag)}\n            />{' '}\n          </p>\n        : null\n      }\n      <div className={'grid'} >\n        <div className={'grid-head'} >\n          <div className={'grid-status-cell'} />\n          {\n            fieldOrder.filter(field => field !== linkField).map((field, i) => {\n              const widthStyle = widthStyles[i]\n              const isSorted = sortSpec.find(x => x[0] === field)\n              const direction = isSorted ? isSorted[1] : 0\n              return (\n                <div\n                  className={'grid-head-cell label-col-grid'}\n                  key={field}\n                  style={widthStyle}\n                >\n                  {\n                    direction\n                    ? <span\n                        className={'sorted button-small'}\n                        data-rh={'remove column from sort options'}\n                        onClick={handle(dispatch, delColumn, gridTag, field)}\n                      >{field}</span>\n                    : <span\n                        className={'unsorted button-small'}\n                        data-rh={'sort on this column'}\n                        onClick={handle(dispatch, addColumn, gridTag, field, 1)}\n                      >{field}</span>\n                  }\n                  {\n                    direction\n                    ? <span\n                        className={`sorted button-small fa fa-arrow-${direction === 1 ? 'up' : 'down'}`}\n                        data-rh={'change sort direction'}\n                        onClick={handle(dispatch, turnColumn, gridTag, field)}\n                      />\n                    : null\n                  }\n                </div>\n              )\n            })\n          }\n          {\n            (detailOrder || emptyA).map((name, i) => {\n              const widthStyle = widthStyles[i]\n              return (\n                <div\n                  className={'grid-head-cell label-col-grid'}\n                  key={name}\n                  style={widthStyle}\n                >{name}\n                </div>\n              )\n            })\n          }\n        </div>\n        {rows}\n      </div>\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getSettings, getGrid, getAltSection)\n\nexport default connect(getInfo)(ListGrid)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ListGrid.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { browserHistory } from 'react-router'\n\nimport { memoize } from 'memo'\nimport { combineSelectors, withParams, getUrlParts, emptyS, emptyO } from 'utils'\nimport { someEditable } from 'fields'\nimport { editMode } from 'presentation'\n\nimport { insertItem, needValues, headEntity, DETAILS, handleOpenAll } from 'tables'\nimport { getAltSection, compileAlternatives } from 'alter'\nimport { compileActive } from 'workflow'\nimport { getSettings } from 'settings'\n\nimport ErrorBoundary from 'ErrorBoundary'\nimport ItemContainer from 'ItemContainer'\nimport EditStatus from 'EditStatus'\nimport EditInsert from 'EditInsert'\nimport OpenCloseAll from 'OpenCloseAll'\n\nconst initial = 0\nconst nAlts = 2\n\nclass ListPlain extends Component {\n  handleInsert = () => {\n    const { props: { table, select, masterId, linkField, dispatch } } = this\n    dispatch(insertItem(table, select, masterId, linkField))\n    this.gotoNew = true\n  }\n  gotoItem = eId => {\n    const { props: { alterSection, dispatch } } = this\n    const { putAlt } = compileAlternatives(alterSection, nAlts, initial, dispatch)(eId)\n    const theAlt = (initial + 1) % nAlts\n    putAlt(theAlt)\n  }\n\n  scroll = domElem => {\n    if (domElem != null) {\n      //domElem.scrollIntoViewIfNeeded() // this is a non-standard function, only supported by webkit, not by firefox\n      domElem.scrollIntoView()\n    }\n  }\n\n  render() {\n    const {\n      props: {\n        settings, alter, alterSection,\n        filtered, filters,\n        tables, table, select,\n        masterId, linkField,\n        fixed, listIds, expand, border,\n        perm,\n        dispatch,\n      },\n    } = this\n    const { [table]: { item, entities } } = tables\n    const makeAlternatives = compileAlternatives(alterSection, nAlts, initial, dispatch)\n    const activeItems = compileActive(tables, table)\n    let masterTable = null\n    if (linkField != null) {\n      const {\n        [table]: {\n          fieldSpecs: {\n            [linkField]: {\n              valType: { relTable } = emptyO,\n            } = emptyO },\n        },\n      } = tables\n      masterTable = relTable\n    }\n    const startMode = masterTable == null\n    ? 0\n    : editMode(tables, table, 'detail', masterTable)\n    return (\n      <div className={'list-generic'} >\n        {\n          !(filtered && select === DETAILS)\n          ? <div>\n              <EditInsert\n                perm={perm}\n                select={select}\n                fixed={fixed}\n                item={item}\n                button={'button-medium'}\n                onInsert={this.handleInsert}\n              />\n              <OpenCloseAll\n                table={table}\n                listIds={listIds}\n                item={item}\n                button={'button-medium'}\n                alterSection={alterSection}\n                nAlts={nAlts}\n                initial={initial}\n                openAll={select == DETAILS}\n                expand={expand}\n              />\n            </div>\n          : null\n        }\n        {\n          listIds.map(eId => {\n            const { [eId]: { fields, perm, workflow, values } } = entities\n            const head = headEntity(tables, table, eId, settings)\n            const formTag = `${table}-${eId}`\n            const isComplete = !needValues(entities, eId)\n            const { getAlt, nextAlt } = makeAlternatives(eId)\n            const alt = getAlt(alter)\n            const active = alt !== initial\n            const scrollProps = active ? { ref: this.scroll } : emptyO\n            const showStatus = isComplete && someEditable(fields, perm, workflow)\n            const isactive = activeItems != null && activeItems.has(eId)\n            const thisStartMode = startMode === 0 ? startMode : startMode(values)\n\n            return (\n              <div key={eId} className={isactive ? 'isactive' : emptyS} >\n                {\n                  active\n                  ? <div {...scrollProps} >\n                      {\n                        !expand\n                        ? <span className={'link head'} onClick={this.showHide(table, select, eId, false, nextAlt)} >\n                            <span className={`fa fa-angle-up`} />\n                          </span>\n                        : null\n                      }\n                      <ErrorBoundary>\n                        <ItemContainer\n                          filters={filters}\n                          tables={tables}\n                          table={table}\n                          eId={eId}\n                          masterId={masterId}\n                          linkField={linkField}\n                          isactive={isactive}\n                          startMode={thisStartMode}\n                          fixed={fixed}\n                          inhibitFetch={expand}\n                          border={border}\n                        />\n                      </ErrorBoundary>\n                    </div>\n                  : <span className={'item-head'} >\n                      {\n                        showStatus\n                        ? <EditStatus form={formTag} active={active} />\n                        : <span>\n                            <span className={'fa fa-fw'} />\n                            {' '}\n                          </span>\n                      }\n                      <span className={'link head'} onClick={this.showHide(table, select, eId, true, nextAlt)} >\n                        <span className={`fa fa-angle-down`} />\n                        {' '}{head}\n                      </span>\n                    </span>\n                }\n              </div>\n            )\n          })\n        }\n      </div>\n    )\n  }\n\n  showHide = memoize((table, select, eId, active, nextAlt) => () => {\n    if (select === DETAILS) {\n      nextAlt()\n      return\n    }\n    const [base, origEid] = getUrlParts(browserHistory)\n    if (active) {\n      if (origEid !== eId) {\n        browserHistory.push(`${base}/item/${eId}/`)\n      }\n    }\n    else {\n      if (origEid !== '') {\n        browserHistory.push(`${base}/`)\n      }\n      nextAlt()\n    }\n  })\n\n  gotoNewItem() {\n    const { props: { tables, table, navItem } } = this\n    if (this.gotoNew) {\n      const { [table]: tableInfo } = tables\n      if (tableInfo == null) {return}\n      const { lastInserted } = tableInfo\n      if (lastInserted != null) {\n        this.gotoNew = false\n        this.gotoItem(lastInserted)\n      }\n    }\n    else if (navItem != null) {\n      this.gotoItem(navItem)\n    }\n  }\n  openAll() {\n    const {\n      props: {\n        alter, alterSection,\n        table, listIds,\n        expand,\n        dispatch,\n      },\n    } = this\n    if (expand) {\n      handleOpenAll(alter, alterSection, nAlts, initial, table, listIds, dispatch)()\n    }\n  }\n  componentDidMount() {\n    this.openAll()\n    this.gotoNewItem()\n  }\n  componentDidUpdate() {\n    this.openAll()\n    this.gotoNewItem()\n  }\n}\n\nconst getInfo = combineSelectors(getSettings, getAltSection)\n\nexport default connect(getInfo)(withParams(ListPlain))\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/ListPlain.jsx","import React, {Component} from 'react'\nimport { connect } from 'react-redux'\n\nimport { presentUser } from 'tables'\nimport { getMe, fetchMe } from 'me'\n\nclass Login extends Component {\n  render() {\n    const { props: { me } } = this\n    return (\n      <span className={'login'} >\n        {\n          me.eppn\n          ? <span\n              data-rh={'you are logged in'}\n              data-rh-at={'bottom'}\n            >\n              <span className={'fa fa-user'} /><strong>{presentUser(me)}</strong>{' '}\n              <em>{me.groupDesc || 'not authenticated'}</em>\n              <a\n                href={'/logout'}\n                className={'control fa fa-user-times'}\n                data-rh={'log out of this tool'}\n                data-rh-at={'bottom'}\n              />\n              <a\n                href={'/slogout'}\n                className={'control fa fa-users'}\n                data-rh={'sign out from DARIAH'}\n                data-rh-at={'bottom'}\n              />\n            </span>\n          : <a\n              href={'/login'}\n              className={'control'}\n              data-rh={'click to log in'}\n              data-rh-at={'bottom'}\n            >\n              <strong className={'fa fa-user-plus'} /><strong>{' login'}</strong>\n            </a>\n        }\n      </span>\n    )\n  }\n  componentDidMount() {\n    const { props: { dispatch } } = this\n    dispatch(fetchMe({ type: 'fetchMe', contentType: 'db', path: '/who/ami', desc: 'me' }))\n  }\n}\n\nexport default connect(getMe)(Login)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Login.jsx","import React from 'react'\nimport { connect } from 'react-redux'\nimport Markdown from 'react-markdown'\n\nimport { editClass, makeSubmit, makeReset } from 'fields'\n\nimport { getAltSection, compileAlternatives } from 'alter'\n\nimport EditHelp from 'EditHelp'\n\nconst MarkdownArea = ({\n  alter, alterSection, table, eId, meta: { dirty, invalid, submitting, error },\n  input: { name, value }, input,\n  reset, submitValues,\n  dispatch,\n}) => {\n  const alterTag = `${table}-${eId}-${name}`\n  const { getAlt, nextAlt } = compileAlternatives(alterSection, 2, 1, dispatch)(alterTag)\n  const alt = getAlt(alter)\n  return (\n    <div className={'md-field'}>\n      <p className={'stick'} >\n        <span\n          className={`button-medium field-control fa fa-${alt === 0 ? 'pencil' : 'hand-o-down'}`}\n          data-rh={`${alt === 0 ? 'edit text' : 'preview formatted text'}`}\n          onClick={nextAlt}\n        />\n      </p>\n      {\n        alt === 0\n        ? <Markdown\n            className={`${editClass(dirty, invalid)} field-content`}\n            key={'fmt'}\n            source={value}\n          />\n        : <div key={'src'} className={'field-content'}>\n            <textarea\n              className={`input ${editClass(dirty, invalid)}`}\n              {...input}\n              wrap={'soft'}\n              onBlur={makeSubmit(dirty, invalid, submitting, submitValues)}\n              {...makeReset('text', reset)}\n            />\n            {error && <span className={'invalid diag'}>{error}</span>}\n            <EditHelp type={'markdown'} dirty={dirty} />\n          </div>\n      }\n    </div>\n  )\n}\n\nexport default connect(getAltSection)(MarkdownArea)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/MarkdownArea.jsx","import React from 'react'\nimport { Link } from 'react-router'\n\nexport default props => <Link {...props} activeClassName={'active'} />\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/NavLink.jsx","import React from 'react'\n\nexport default ({ splat }) => (<h1>{'404: '}<code>{splat}</code>{' not found on this site.'}</h1>)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/NotFound.jsx","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { emptyS } from 'utils'\n\nimport { getNotes, clear, display } from 'notes'\n\nclass Notification extends Component {\n  constructor(props) {\n    super(props)\n    this.dom = {}\n  }\n  refDom = label => dom => {\n    if (dom) {this.dom[label] = dom}\n  }\n  handleBox = () => {\n    const { props: { show, dispatch } } = this\n    dispatch(display(!show))\n  }\n  handleHide = () => {\n    const { props: { dispatch } } = this\n    dispatch(display(false))\n  }\n  handleClear = () => {\n    const { props: { dispatch } } = this\n    dispatch(clear())\n  }\n\n  render() {\n    const { props: { messages, lastNote, lastKind, busy, show } } = this\n\n    const highlight = lastNote > -1\n    const busyBlocks = new Array(busy < 0 ? 0 : busy).fill(1)\n    return (\n      <div>\n        <p className={'msg-spinner'} >\n          <span\n            data-rh={'click circle to show/hide notifications and progress messages'}\n            data-rh-at={'left'}\n            className={highlight ? `spin-${lastKind}` : 'spin-ok'}\n          >\n            { busyBlocks.map((b, i) => <span key={i} className={'msg-dot fa fa-caret-left'} />) }\n            <span\n              className={`fa fa-${busy === 0 ? 'circle-o' : 'spinner fa-spin'}`}\n              onClick={this.handleBox}\n            />\n          </span>\n        </p>\n        {\n          show\n          ? <div\n              ref={this.refDom('notbox')}\n              className={'msg-box'}\n              data-rh={'click panel to hide it'}\n              data-rh-at={'bottom'}\n              onClick={this.handleHide}\n            >{\n              messages.map((msg, i) => (\n                <p\n                  key={i}\n                  ref={this.refDom(`m${i}`)}\n                  className={`msg-line ${[msg.kind]}-o ${msg.kind !== 'info' ? 'msg-high' : emptyS}`}\n                >{msg.text}</p>\n              ))\n            }\n              <p className={'msg-dismiss'} >{'(click panel to hide)'}</p>\n              <p className={'msg-trash'} >\n                <a\n                  href={'#'}\n                  data-rh={'clear messages'}\n                  className={'control fa fa-trash'}\n                  onClick={this.handleClear}\n                />\n              </p>\n            </div>\n          : null\n        }\n      </div>\n    )\n  }\n  componentDidMount() {this.setView()}\n  componentDidUpdate() {this.setView()}\n\n  setView() {\n    const { props: { show } } = this\n    if (show) {this.setScroll()}\n  }\n  setScroll() {\n    const { props: { show } } = this\n    if (show) {\n      const { props: { lastMsg, lastNote } } = this\n      const highlight = lastNote > -1\n      if (highlight) {\n        this.dom[`m${lastNote}`].scrollIntoView()\n      }\n      else {\n        if (lastMsg > -1) {\n          this.dom[`m${lastMsg}`].scrollIntoView()\n        }\n      }\n    }\n  }\n}\n\nexport default connect(getNotes)(Notification)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Notification.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { getAltSection } from 'alter'\nimport { handleOpenAll, handleCloseAll } from 'tables'\n\nconst OpenCloseAll = ({\n  alter, alterSection,\n  table, listIds, item, button,\n  nAlts, initial,\n  openAll, expand,\n  dispatch,\n}) => {\n  const [thing, things] = item\n  const itemsRep = listIds.length === 1 ? thing : things\n  const nItemsRep = `${listIds.length} ${itemsRep} `\n  return [\n    <span key=\"I\">{nItemsRep}</span>,\n    openAll && !expand\n    ? <div\n        key=\"O\"\n        className={`fa fa-angle-double-down ${button}`}\n        data-rh={`open all ${itemsRep}`}\n        data-rh-at={'bottom'}\n        onClick={handleOpenAll(alter, alterSection, nAlts, initial, table, listIds, dispatch)}\n      />\n    : null,\n    !expand\n    ? <div\n        key=\"C\"\n        className={`fa fa-angle-double-up ${button}`}\n        data-rh={`close all opened ${itemsRep}`}\n        data-rh-at={'bottom'}\n        onClick={handleCloseAll(alter, alterSection, nAlts, initial, listIds, dispatch)}\n      />\n    : null,\n  ]\n}\n\nexport default connect(getAltSection)(OpenCloseAll)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/OpenCloseAll.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { memoize } from 'memo'\nimport { combineSelectors, emptyS, emptyO } from 'utils'\nimport { handle, handlEV } from 'handle'\nimport { composeAttributes, checkDisabled, makeSubmitTime } from 'fields'\n\nimport { getSettings } from 'settings'\nimport { getSelect, compileOptions, setSearch, setPopUp, togglePopUp } from 'select'\n\nconst RelOption = ({ label, attributes, selected, onHit }) => (\n  <p\n    {...attributes}\n    data-rh={'select this option'}\n    data-rh-at={'bottom'}\n    onClick={selected ? null : onHit}\n  >{label}</p>\n)\n\nconst removeVal = (value, onChange, val) => event => {\n  event.stopPropagation()\n  if (value.includes(val)) {\n    const newValue = value.filter(v => v !== val)\n    onChange(newValue)\n  }\n}\nconst addVal = (optionLookup, multiple, value, onChange, label) => () => {\n  const { [label]: rep } = optionLookup\n  const exists = rep != null || value.includes(label)\n  if (!exists) {\n    const newValue = multiple ? [label, ...value] : label\n    onChange(newValue)\n  }\n}\nconst changeSel = memoize((selectTag, multiple, value, val, onChange, dispatch) => () => {\n  if (multiple) {\n    if (!value.includes(val)) {\n      const newValue = [...value, val]\n      onChange(newValue)\n    }\n  }\n  else {\n    onChange(val)\n    dispatch(setPopUp(selectTag, false))\n  }\n})\n\nconst Head = ({ optionLookup, value, popUp, popUpIfEmpty, activeItems, inactive, selectTag, dispatch }) => {\n  const makeAttributes = composeAttributes(activeItems, inactive)\n  let label = emptyS\n  const { [value]: lab = value } = optionLookup\n  label = lab\n  const classes = ['option-head', 'tag']\n  if (value === emptyS) {\n    if (popUpIfEmpty) {\n      return null\n    }\n    else {\n      label = 'click to enter a value'\n      classes.push('new')\n    }\n  }\n  const attributes = makeAttributes(value, classes.join(' '))\n  const dir = popUp ? 'up' : 'down'\n  const present = popUp ? 'hide' : 'show'\n  return (\n    <span\n      {...attributes}\n      data-rh={`click here to ${present} the other options`}\n      data-rh-at={'top'}\n      onClick={handle(dispatch, togglePopUp, selectTag)}\n    >\n      {label}\n      {' '}\n      <span className={`fa fa-arrow-${dir} ${dir}`} />\n    </span>\n  )\n}\n\nconst Tags = ({ selectTag, optionLookup, popUp, popUpIfEmpty, activeItems, inactive, value, onChange, dispatch }) => {\n  const makeAttributes = composeAttributes(activeItems, inactive)\n  const dir = popUp ? 'up' : 'down'\n  const present = popUp ? 'hide' : 'show'\n  return (\n    <div\n      className={'tags'}\n      data-rh={`click to ${present} the remaining options`}\n      data-rh-at={'top'}\n      onClick={handle(dispatch, togglePopUp, selectTag)}\n    >\n      {\n        (value != null && value.length)\n        ? value.map(\n            val => {\n              const { [val]: lab = val } = optionLookup\n              const attributes = makeAttributes(val, 'tag')\n              return (\n                <span\n                  key={val}\n                  {...attributes}\n                >\n                  <span\n                    className={`button-tag`}\n                    data-rh={'UNselect this option'}\n                    data-rh-at={'bottom'}\n                    onClick={removeVal(value, onChange, val)}\n                  >{'×'}</span>{' '}\n                  <span>{lab}</span>\n                </span>\n              )\n            }\n          )\n        : popUpIfEmpty\n          ? null\n          : <span className={'tag empty'}>{'click to enter values'}</span>\n      }\n      <span className={`fa fa-arrow-${dir} ${dir}`} />\n    </div>\n  )\n}\n\nconst Typing = ({ selectTag, search, dispatch, placeHolder }) => (\n  <span className={'option-type'} >\n    {\n      search\n      ? <span\n          className={'button-tag'}\n          data-rh={'clear typing'}\n          data-rh-at={'bottom'}\n          onClick={handle(dispatch, setSearch, selectTag, emptyS)}\n        >{'×'}</span>\n        : <span>{'\\xa0'}</span>\n    }\n    {'\\xa0'}\n    <input\n      className={'typing'}\n      type={'text'}\n      data-rh={placeHolder}\n      data-rh-at={'left'}\n      placeholder={'type here ...'}\n      value={search || emptyS}\n      onFocus={handle(dispatch, setPopUp, selectTag, true)}\n      onChange={handlEV(dispatch, setSearch, selectTag)}\n    />\n  </span>\n)\n\nconst Options = ({\n  selectTag, optionLookup, options,\n  activeItems, inactive,\n  multiple, allowNew,\n  value, onChange, search, dispatch,\n}) => {\n  const pat = (search || emptyS).toLowerCase()\n  const makeAttributes = composeAttributes(activeItems, inactive)\n  const testDisabled = checkDisabled(activeItems, inactive)\n  const oLen = options.length\n  const sizeClass = oLen >= 20\n  ? 'o-large'\n  : 'o-small'\n\n  return (\n    <div className={`options ${sizeClass}`} >\n      {\n        multiple || value == null || value == emptyS\n        ? null\n        : <span\n            className={'button-tag tag option'}\n            data-rh={'do not select any option'}\n            data-rh-at={'bottom'}\n            onClick={changeSel(selectTag, multiple, null, null, onChange, dispatch)}\n          >{'( × )'}</span>\n      }\n      {\n        (\n          allowNew\n          && search\n          && !options.some(({ label }) => label === search)\n          && !value.includes(search)\n        )\n        ? <span\n            className={'new tag'}\n            data-rh={'add this as a NEW option'}\n            data-rh-at={'bottom'}\n            onClick={addVal(optionLookup, multiple, value, onChange, search)}\n          >{search}</span>\n        : null\n      }\n      {\n        options.map(({ value: val, label: lab }) => {\n          if (\n            (!multiple || !value.includes(val))\n            && (pat == null || pat === emptyS || lab == null || lab.toLowerCase().indexOf(pat) !== -1)\n            && !testDisabled(val)\n          ) {\n            const selected = (multiple && value.includes(val)) || (!multiple && value === val)\n            const attributes = makeAttributes(val, `tag option ${selected ? 'selected' : emptyS}`)\n            return (\n              <RelOption\n                key={val}\n                label={lab}\n                attributes={attributes}\n                selected={selected}\n                onHit={changeSel(selectTag, multiple, value, val, onChange, dispatch)}\n              />\n            )\n          }\n          else {\n            return null\n          }\n        })\n      }\n    </div>\n  )\n}\n\nconst RelSelect = ({\n  settings,\n  tables, table,\n  field, selectTag,\n  activeItems, inactive,\n  allowed,\n  input: { value, onChange },\n  multiple, allowNew, popUpIfEmpty, select, dispatch,\n  suppressTyping,\n  submitValues,\n}) => {\n  const submitTime = makeSubmitTime(submitValues)\n  const onChangeSave = val => {onChange(val); submitTime()}\n  const { [selectTag]: { search, popUp } = emptyO } = select\n  const { options, optionLookup } = compileOptions(tables, table, allowed, field, settings)\n  const realPopUp = popUp\n  || (popUpIfEmpty && (value == null || (multiple && value.length == 0) || (!multiple && !value)))\n  const itemType = allowNew === true\n  ? 'value'\n  : allowNew || emptyS\n  const addItem = itemType\n    ? ` or add a new ${itemType}`\n  : emptyS\n  const placeHolder = `filter remaining options${addItem}`\n  return (\n    <div\n      className={`select ${multiple ? 'multiselect' : emptyS}`}\n    >\n      {\n        multiple\n        ? <Tags\n            optionLookup={optionLookup}\n            activeItems={activeItems}\n            inactive={inactive}\n            value={value}\n            selectTag={selectTag}\n            popUp={realPopUp}\n            popUpIfEmpty={popUpIfEmpty}\n            dispatch={dispatch}\n            onChange={onChangeSave}\n          />\n        : <Head\n            optionLookup={optionLookup}\n            activeItems={activeItems}\n            inactive={inactive}\n            value={value}\n            popUp={realPopUp}\n            popUpIfEmpty={popUpIfEmpty}\n            selectTag={selectTag}\n            dispatch={dispatch}\n          />\n      }\n      {\n        realPopUp && !suppressTyping\n        ? <Typing\n            selectTag={selectTag}\n            search={search}\n            dispatch={dispatch}\n            placeHolder={placeHolder}\n          />\n        : null\n      }\n      {\n        realPopUp\n        ? <Options\n            selectTag={selectTag}\n            optionLookup={optionLookup}\n            options={options}\n            activeItems={activeItems}\n            inactive={inactive}\n            multiple={multiple}\n            allowNew={allowNew}\n            value={value}\n            search={search}\n            dispatch={dispatch}\n            onChange={onChangeSave}\n          />\n        : null\n      }\n    </div>\n  )\n}\n\nconst getInfo = combineSelectors(getSettings, getSelect)\n\nexport default connect(getInfo)(RelSelect)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/RelSelect.jsx","import React from 'react'\nimport { Provider } from 'react-redux'\n\nimport store from 'roots'\nimport Window from 'Window'\n\nexport default ({ children }) => (\n  <Provider store={store}>\n    <Window>\n      {children}\n    </Window>\n  </Provider>\n)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Root.jsx","import React from 'react'\n\nimport { emptyS } from 'utils'\n\nexport default ({subTotal, total, className}) => (\n  <span className={className} >\n    {subTotal == null ? emptyS : `${subTotal}`}\n    {(total == null || subTotal == null) ? emptyS : ' of '}\n    <strong>{total == null ? emptyS : `${total}`}</strong>\n  </span>\n)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Stat.jsx","import React from 'react'\n\nimport NavLink from 'NavLink'\n\nexport default () => (\n  <span className={'small'} >\n    <NavLink to={'/docs/about.md'} >{'Home'}</NavLink>\n    <NavLink to={'/data'} >{'Registry'}</NavLink>\n    <a href={'https://github.com/Dans-labs/dariah/wiki'} target={'_blank'} rel={'noopener noreferrer'} >{'Help'}</a>\n    <a href={'https://github.com/Dans-labs/dariah/wiki/Help'} target={'_blank'} rel={'noopener noreferrer'} >{'About'}</a>\n    <a href={'https://dans-labs.github.io/dariah/'} target={'_blank'} rel={'noopener noreferrer'} >{'Tech doc'}</a>\n  </span>\n)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Static.jsx","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { withParams, emptyA } from 'utils'\nimport { getMe } from 'me'\n\nimport ErrorBoundary from 'ErrorBoundary'\nimport NavLink from 'NavLink'\n\nconst levels = {\n  public: 1,\n  auth: 2,\n  office: 3,\n  system: 4,\n  root: 5,\n}\n\nconst forMe = (my, item) => levels[my] >= levels[item]\n\nconst tableLinks = (me, { path, name, forWhom, details }) => forMe(me.groupRep, forWhom)\n  ? <div key={path} className={'nav section'} >\n      <NavLink to={path} className={'head'} >{name}</NavLink>\n      <div className={'nav subsection'} >\n        {\n          (details || emptyA).filter(({ forWhom: subFor }) => forMe(me.groupRep, subFor)).map(\n            ({ path: subPath, name: subName, hint }) =>\n              <NavLink\n                key={subPath}\n                to={`${path}/${subPath}`}\n                data-rh={hint}\n                data-rh-at={'right'}\n              >{subName}</NavLink>\n           )\n        }\n      </div>\n    </div>\n  : null\n\nconst navBarItems = [\n  {\n    path: '/data/contrib',\n    name: 'Contributions',\n    forWhom: 'public',\n    details: [\n      { path: 'filter', name: 'All items', forWhom: 'public', hint: 'Overview of all contributions' },\n      { path: 'mylist', name: 'My items', forWhom: 'auth', hint: 'Start here to add a contribution' },\n    ],\n  },\n  {\n    path: '/data/assessment',\n    name: 'Assessments',\n    forWhom: 'auth',\n    details: [\n      { path: 'filter', name: 'All items', forWhom: 'auth', hint: 'overview of all assessments' },\n      { path: 'mylist', name: 'My items', forWhom: 'auth', hint: 'Look here to see the status of your assessments' },\n    ],\n  },\n  {\n    path: '/data/package',\n    name: 'Packages',\n    forWhom: 'office',\n    details: [\n      { path: 'filter', name: 'list', forWhom: 'office', hint: 'the setup of contribution types and criteria' },\n      { path: 'grid', name: 'table', forWhom: 'office', hint: 'the setup of contribution types and criteria' },\n    ],\n  },\n  {\n    path: '/data/typeContribution',\n    name: 'Contribution types',\n    forWhom: 'office',\n    details: [\n      { path: 'filter', name: 'list', forWhom: 'office', hint: 'overview of all contribution types' },\n      { path: 'grid', name: 'table', forWhom: 'office', hint: 'overview of all contribution types' },\n    ],\n  },\n  {\n    path: '/data/criteria',\n    name: 'Criteria',\n    forWhom: 'office',\n    details: [\n      { path: 'filter', name: 'list', forWhom: 'office', hint: 'overview of all criteria' },\n      { path: 'grid', name: 'table', forWhom: 'office', hint: 'overview of all criteria' },\n    ],\n  },\n  {\n    path: '/data/score',\n    name: 'Scores',\n    forWhom: 'office',\n    details: [\n      { path: 'filter', name: 'list', forWhom: 'office', hint: 'overview of all scores' },\n      { path: 'grid', name: 'table', forWhom: 'office', hint: 'overview of all scores' },\n    ],\n  },\n  {\n    path: '/data/user',\n    name: 'Users',\n    forWhom: 'office',\n    details: [\n      { path: 'filter', name: 'list', forWhom: 'office', hint: 'User management' },\n      { path: 'grid', name: 'table', forWhom: 'office', hint: 'User management' },\n    ],\n  },\n  {\n    path: '/data/country',\n    name: 'Countries',\n    forWhom: 'office',\n    details: [\n      { path: 'filter', name: 'list', forWhom: 'office', hint: 'Country membership management' },\n      { path: 'grid', name: 'table', forWhom: 'office', hint: 'Country membership management' },\n    ],\n  },\n]\n\nconst SubApp = ({ me, table, routes, children }) => (\n  <div className={'sub-app'} >\n    <div className={'nav bar'} >\n      <ErrorBoundary>\n        {navBarItems.map(item => tableLinks(me, item))}\n      </ErrorBoundary>\n    </div>\n    <div className={'details'} >\n      <ErrorBoundary>\n        {\n          routes[1].path === 'data' && routes.length === 1\n          ? <div>{'All tables'}</div>\n          : routes[1].path === 'data' && routes.length === 2\n            ? <div>\n                <h3>{'Registry'}</h3>\n                <p>{'Use the side bar to navigate to a section'}</p>\n              </div>\n              : routes[1].path === 'data' && routes.length === 3\n                ? <div>\n                    <h3>{'Registry'}</h3>\n                    <h4>{`Table ${table}`}</h4>\n                    <p>{'Use the side bar to navigate to a particular view on this table'}</p>\n                  </div>\n                : null\n        }\n      </ErrorBoundary>\n      <ErrorBoundary>\n        { children }\n      </ErrorBoundary>\n    </div>\n  </div>\n)\n\nexport default connect(getMe)(withParams(SubApp))\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/SubApp.jsx","import React from 'react'\n\nimport { emptyS } from 'utils'\nimport { itemReadField, itemEditField } from 'fields'\nimport { assessmentScore } from 'workflow'\n\nimport Expand, { ExpandHead, ExpandBody } from 'Expand'\n\nconst rField = (field, l, f, key) => itemReadField(field, l(field), f(field), key)\nconst eField = (field, l, fe, m, key) => itemEditField(field, l(field), fe(field), m(field), key)\n\nexport const mainTemplates = {\n  assessment({ l, f }) {\n    return (\n      <div>\n        <div className={'grid fragments'}>\n          {rField('title', l, f)}\n          {rField('assessmentType', l, f)}\n          {rField('contrib', l, f)}\n        </div>\n      </div>\n    )\n  },\n}\n\nexport const mainEditTemplates = {\n  assessment({ l, fe, m, editButton }) {\n    return (\n      <div>\n        {editButton}\n        <div className={'grid fragments'}>\n          {eField('title', l, fe, m)}\n          {eField('assessmentType', l, fe, m)}\n          {eField('contrib', l, fe, m)}\n        </div>\n      </div>\n    )\n  },\n}\n\nexport const mainActionTemplates = {\n  contrib({ w }) {\n    return w('locked')\n    ? <div className={'workflow-large invert'} >\n        {`This contribution is locked because it is ${w('lockedReason')}.`}\n      </div>\n    : null\n  },\n  assessment({ tables, l, e, v, fe, fs, m }) {\n    const { overall, relevantScore, relevantMax, allMax, relevantN, allN } = assessmentScore(tables, v('_id'))\n    const irrelevantN = allN - relevantN\n    const isWithdrawn = !e('dateWithdrawn')\n    const isSubmitted = !e('submitted')\n    return (\n      <div>\n        <div className={'ass-score-box'}>\n          <span\n            className={'ass-score'}\n            data-rh={'overall-score of this assessment'}\n            data-rh-at={'right'}\n          >{`${overall} %`}</span>\n          <Expand\n            alterSection={`assessment{v('_id')}`}\n            alterTag={'score'}\n            iconOpen={'calculator'}\n            iconClose={'minus-circle'}\n            titleOpen={'Show derivation'}\n            titleClose={'Hide derivation'}\n            headActive={emptyS}\n            headLine={emptyS}\n            full={\n              <div className={'ass-score-deriv'}>\n                <p>{`This contribution scores ${relevantScore} points.`}</p>\n                <p>{`For this type of contribution there is a total of ${allMax} points,\n                    divided over ${allN} criteria.`}</p>\n                {\n                  irrelevantN\n                  ? <p>{`However,\n                        ${irrelevantN} rule${irrelevantN == 1 ? ' is' : 's are'}\n                        not applicable to this contribution,\n                        which leaves the total amount to\n                        ${relevantMax} points,\n                        divided over ${relevantN} criteria.`}\n                    </p>\n                  : ''\n                }\n                <p>{`The total score is expressed as a percentage:\n                    the fraction of ${relevantScore} scored points with respect to \n                    ${relevantMax} scorable points.`}\n                </p>\n              </div>\n            }\n          />\n        </div>\n        <div className={'grid fragments'}>\n          {m('submitted') ? null : eField('submitted', l, fe, m)}\n          {\n            itemEditField(\n              'submitted',\n              'Submission',\n              <span>\n                {!isSubmitted && isWithdrawn ? `${l('dateWithdrawn')}: ${v('dateWithdrawn')}` : null}\n                {isSubmitted ? `${l('dateSubmitted')}: ${v('dateSubmitted')}` : null}\n                {\n                  fs('submitted', e('submitted'), h =>\n                    <span\n                      className={'button-large invert'}\n                      onClick={h}\n                    >{`${e('submitted') ? 'Submit for' : 'Withdraw from'} review`}</span>\n                  )\n                }\n              </span>,\n              m('submitted'),\n            )\n          }\n          {e('submitted') ? null : eField('reviewerE', l, fe, m)}\n          {e('submitted') ? null : eField('reviewerF', l, fe, m)}\n        </div>\n      </div>\n    )\n  },\n}\n\nexport const detailTemplates = {\n  assessment: {\n    contrib: mainTemplates['assessment'],\n  },\n  criteriaEntry: {\n    assessment({ l, v, e, f }) {\n      const statusClass = (e('evidence') || e('score')) ? 'incomplete' : 'complete'\n      return (\n        <div className={`criteriaEntryRead ${statusClass}`}>\n          <div className={'criteriaEntry'}>\n            <div>{v('seq')}</div>\n            <Expand\n              alterSection={`criteriaEntry${v('_id')}`}\n              alterTag={l('remarks')}\n              iconOpen={'info-circle'}\n              iconClose={'minus-circle'}\n              titleOpen={'Show criteria details'}\n              titleClose={'Hide criteria details'}\n              headActive={''}\n              headLine={f('criteria')}\n              full={<div className={'criteriaRemarks'}>{f('criteria', 'remarks')}</div>}\n              className={'fat'}\n            />\n            <div className={'slim'}>{f('score')}</div>\n            {\n              e('evidence')\n              ? <div className={'xSlim'}>\n                  <span\n                    data-rh={'No evidence yet'}\n                    className={'slim fa fa-file-o tError'}\n                  />\n                </div>\n              : <ExpandHead\n                  alterSection={`criteriaEntry${v('_id')}`}\n                  alterTag={l('evidence')}\n                  initAlt={1}\n                  iconOpen={'file-text'}\n                  iconClose={'minus-square'}\n                  titleOpen={'Show evidence'}\n                  titleClose={'Hide evidence'}\n                  headActive={''}\n                  headLine={''}\n                  className={'xSlim tGood'}\n                />\n            }\n          </div>\n          <ExpandBody\n            alterSection={`criteriaEntry${v('_id')}`}\n            alterTag={l('evidence')}\n            initAlt={1}\n            full={\n              <div>\n                <b>{l('evidence')}</b>\n                {f('evidence')}\n              </div>\n            }\n            className={'evidence'}\n          />\n        </div>\n      )\n    },\n  },\n}\n\nexport const detailEditTemplates = {\n  assessment: {\n    contrib: mainEditTemplates['assessment'],\n  },\n  criteriaEntry: {\n    assessment({ l, v, e, f, fe, editButton }) {\n      const statusClass = (e('evidence') || e('score')) ? 'incomplete' : 'complete'\n      return (\n        <div className={`criteriaEntryEdit ${statusClass}`}>\n          <div key={'H'} className={'criteriaEntry'}>\n            {editButton}\n            {v('seq')}\n            <div className={'fat'}>\n              <div className={'fat'}>{f('criteria')}</div>\n              <div className={'criteriaRemarks'}>{f('criteria', 'remarks')}</div>\n            </div>\n            <div className={'slim'}>{fe('score', { suppressTyping: true })}</div>\n          </div>\n          <p\n            key={'E'}\n            data-rh={'Give evidence'}\n            data-rh-at={'bottom'}\n          ><b>{l('evidence')}</b></p>\n          {fe('evidence')}\n        </div>\n      )\n    },\n  },\n}\n\nexport const detailActionTemplates = {\n  assessment: {\n    contrib: mainActionTemplates['assessment'],\n  },\n}\n\nexport const relatedTemplates = {\n  contrib: {\n    assessment({ v, e, f, linkMe }) {\n      const cTitle = v('title')\n      return (\n        <div>\n          <div>\n            {\n              e('urlContribution')\n              ? cTitle\n              : <a href={v('urlContribution')}>{cTitle}</a>\n            }\n          </div>\n          <div>\n            {v('vcc', null, ', ')}\n            {' '}\n            {v('country')}\n            {' '}\n            {v('year')}\n            {' '}\n            <a href={`mailto:${v('contactPersonEmail')}`}>\n              {v('contactPersonName')}\n            </a>\n          </div>\n          <Expand\n            alterSection={`contribution_in_assessment{v('_id')}`}\n            alterTag={'cost'}\n            iconOpen={'info-circle'}\n            iconClose={'minus-circle'}\n            titleOpen={'Show contribution cost description'}\n            titleClose={'Hide contribution cost description'}\n            headActive={`Cost: ${e('costTotal') ? 'Not given' : v('costTotal')}`}\n            headLine={emptyS}\n            full={<div>{f('costDescription')}</div>}\n          />\n          <Expand\n            alterSection={`contribution_in_assessment{v('_id')}`}\n            alterTag={'description'}\n            iconOpen={'info-circle'}\n            iconClose={'minus-circle'}\n            titleOpen={'Show contribution descriptions'}\n            titleClose={'Hide contribution descriptions'}\n            headActive={'Description fields'}\n            headLine={\n              e('urlAcademic')\n              ? <a href={v('urlAcademic')}>{v('urlAcademic')}</a>\n              : emptyS\n            }\n            full={\n              <div>\n                <div>{f('description')}</div>\n                <div>\n                  <div><b>{'Tadirah:'}</b></div>\n                  <div><i>{'Objects'}</i>{' '}{f('tadirahObject')}</div>\n                  <div><i>{'Activities'}</i>{' '}{f('tadirahActivity')}</div>\n                  <div><i>{'Techniques'}</i>{' '}{f('tadirahTechnique')}</div>\n                  <div><b>{'Disciplines:'}</b>{' '}{f('discipline')}</div>\n                  <div><b>{'Keywords:'}</b>{' '}{f('keyword')}</div>\n                </div>\n              </div>\n            }\n          />\n          <Expand\n            alterSection={`contribution_in_assessment{v('_id')}`}\n            alterTag={'provenance'}\n            iconOpen={'info-circle'}\n            iconClose={'minus-circle'}\n            titleOpen={'Show contribution provenance'}\n            titleClose={'Hide contribution provenance'}\n            headActive={'Provenance'}\n            headLine={emptyS}\n            full={\n              <div>\n                <div>\n                  {'Created '}\n                  {f('dateCreated')}\n                  {' by '}\n                  {v('creator')}\n                </div>\n                <div>\n                  <div><b>{'Modification history'}</b></div>\n                  {\n                    v('modified').map((mod, i) =>\n                      <div key={i}>{mod}</div>\n                    )\n                  }\n                </div>\n              </div>\n            }\n          />\n          <div>{<a href={linkMe}>{'To the contribution record'}</a>}</div>\n          <div>{f('typeContribution')}</div>\n        </div>\n      )\n    },\n  },\n}\n\nexport const consolidatedTemplates = {\n  assessment: {\n    trail({ v }) { // consolidated assessment within a trail record\n      return (\n        <div>\n          <div>{v('title')}</div>\n          <div>\n            {v('vcc', ', ')}\n            {' '}\n            {v.year}\n          </div>\n        </div>\n      )\n    },\n  },\n}\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Templates.jsx","import { Component, Children } from 'react'\nimport { connect } from 'react-redux'\nimport throttle from 'lodash/throttle'\n\nimport { changeWinDim } from 'win'\n\nclass Window extends Component {\n  render() {\n    const { props: { children } } = this\n    return Children.only(children)\n  }\n  newWindowSize = throttle(() => {\n    const { props: { dispatch } } = this\n    dispatch(changeWinDim())\n  }, 1000)\n\n  componentDidMount() {window.addEventListener(\"resize\", this.newWindowSize)}\n  componentWillUnmount() {window.removeEventListener(\"resize\", this.newWindowSize)}\n}\n\nexport default connect()(Window)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/components/Window.jsx","//import update from 'immutability-helper'\n\nimport { memoize } from 'memo'\nimport { makeReducer, updateAuto, emptyO } from 'utils'\nimport { handle } from 'handle'\n\n/* ACTIONS */\n\nexport const nextAlt = (alterSection, alterTag, nAlts, initial) =>\n  ({ type: 'nextAlt', alterSection, alterTag, nAlts, initial })\nexport const setAlt = (alterSection, alterTag, alt) =>\n  ({ type: 'setAlt', alterSection, alterTag, alt })\nexport const setItems = (alts, alterSection, alt) =>\n  ({ type: 'setItems', eIds: alts, alterSection, alt })\n\n/* REDUCER */\n\nconst flows = {\n  nextAlt(state, { alterSection, alterTag, initial, nAlts }) {\n    const { [alterSection]: { [alterTag]: oldAlt = (initial || 0) } = emptyO } = state\n    const newAlt = (oldAlt + 1) % nAlts\n    return updateAuto(state, [alterSection, alterTag], { $set: newAlt })\n  },\n  setAlt(state, { alterSection, alterTag, alt }) {\n    return updateAuto(state, [alterSection, alterTag], { $set: alt })\n  },\n  fetchItems(state, { data, eIds, alterSection, alt }) {\n    let newState = state\n    if (data && eIds != null) {\n      for (const eId of eIds) {\n        newState = updateAuto(newState, [alterSection, eId], { $set: alt })\n      }\n    }\n    return newState\n  },\n  setItems(state, { eIds, alterSection, alt }) {\n    let newState = state\n    if (eIds != null) {\n      for (const eId of eIds) {\n        newState = updateAuto(newState, [alterSection, eId], { $set: alt })\n      }\n    }\n    return newState\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getAltSection = ({ alter }, { alterSection }) => ({ alter: alter[alterSection] || emptyO })\n\n/* HELPERS */\n\nexport const compileAlternatives = memoize((alterSection, nAlts, initial, dispatch) => alterTag => ({\n  getAlt: alter => {\n    const { [alterTag]: alt = (initial || 0) } = alter\n    return alt\n  },\n  nextAlt: handle(dispatch, nextAlt, alterSection, alterTag, nAlts, initial),\n  initAlt: handle(dispatch, setAlt, alterSection, alterTag, initial),\n  setAlt: alt => handle(dispatch, setAlt, alterSection, alterTag, alt),\n  putAlt: alt => dispatch(setAlt(alterSection, alterTag, alt)),\n}), null, { debug: 'compileAlternatives' })\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/alter.js","import update from 'immutability-helper'\n\nimport { accessData } from 'server'\nimport { propsChanged, makeReducer } from 'utils'\n\n/* ACTIONS */\n/*\n * Most actions call accessData, which will dispatch the ultimate fetch action.\n */\n\nexport const fetchDoc = props => {\n  const { docDir, docName, docExt } = props\n  const path = `${docDir}/${docName}.${docExt}`\n  return accessData({ type: 'fetchDoc', contentType: 'json', path, desc: `document ${docName}` })\n}\n\n/* REDUCER */\n\nconst flows = {\n  fetchDoc(state, { path, data }) {\n    if (data == null) {return state}\n    return update(state, { [path]: { $set: data } })\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getDoc = ({ docs }, { docDir, docName, docExt }) => ({\n  text: docs[`${docDir}/${docName}.${docExt}`],\n})\n\n/* HELPERS */\n\nexport const needDoc = props => (props.text == null)\n\nexport const changedDoc = (newProps, oldProps) => (\n  propsChanged(newProps, needDoc, oldProps, ['docDir', 'docName', 'docExt'])\n)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/docs.js","import pickBy from 'lodash/pickby'\n\nimport { memoize } from 'memo'\nimport { makeReducer, updateAuto, emptyS, emptyA, emptyO } from 'utils'\nimport { headEntity, DETAILS } from 'tables'\n\n/* ACTIONS */\n\nexport const changeFulltext = (table, filterTag, filterId, searchString) => ({ type: 'fulltext', table, filterTag, filterId, data: searchString })\nexport const changeFacet = (table, filterTag, filterId, valueId, onOff) => ({ type: 'facet', table, filterTag, filterId, data: [valueId, onOff] })\nexport const changeFacetAll = (table, filterTag, filterId, onOff) => ({ type: 'facetAll', table, filterTag, filterId, data: onOff })\n\nexport const initFiltering = (tables, table, filterTag) => {\n  const { [table]: tableData } = tables\n  const fieldIds = compileAllFieldIds(tableData)\n  return { type: 'initFiltering', tables, table, filterTag, fieldIds }\n}\n\n/* REDUCER */\n\nconst flows = {\n  initFiltering(state, { tables, table, filterTag, fieldIds }) {\n    const { [table]: filterData = {} } = state\n    const defaults = initFilterSettings(tables, table, filterData, filterTag, fieldIds)\n    return updateAuto(state, [table, filterTag], { $set: defaults })\n  },\n  fulltext(state, { table, filterTag, filterId, data }) {\n    return updateAuto(state, [table, filterTag, filterId], { $set: data })\n  },\n  facetAll(state, { table, filterTag, filterId, data }) {\n    const { [table]: { [filterTag]: { [filterId]: facets } } } = state\n    const sameSettings = {}\n    Object.keys(facets).forEach(valueId => {sameSettings[valueId] = data})\n    return updateAuto(state, [table, filterTag, filterId], { $set: sameSettings })\n  },\n  facet(state, { table, filterTag, filterId, data }) {\n    const [valueId, filterSetting] = data\n    return updateAuto(state, [table, filterTag, filterId, valueId], { $set: filterSetting })\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getFilters = ({ filters }) => ({ filters })\n\n/* HELPERS */\n\nconst compileAllFieldIds = memoize(tableData => {\n  if (tableData == null) {return emptyO}\n  const { valueLists, fields, filterList, fieldSpecs } = tableData\n  if (filterList == null) {return emptyO}\n  const presentFilterList = filterList.filter(x => fields[x.field])\n  const filterFields = presentFilterList.filter(x => x.type !== 'Fulltext').map(x => x.field)\n  const gatherFields = filterFields.filter(x => valueLists[x] == null)\n  return {\n    ...pickBy(valueLists, (value, key) => filterFields.includes(key)),\n    ...(gatherFields.length ? gatherAllIds(tableData, gatherFields, fieldSpecs) : emptyO),\n  }\n}, emptyO, { debug: 'compileAllFieldIds' })\n\nconst compileFieldIds = memoize((tableData, filterTag, listIds) => {\n  if (tableData == null) {return emptyO}\n  const { valueLists, fields, filterList, fieldSpecs } = tableData\n  if (filterList == null) {return emptyO}\n  const presentFilterList = filterList.filter(x => fields[x.field])\n  const filterFields = presentFilterList.filter(x => x.type !== 'Fulltext').map(x => x.field)\n  const these = filterTag.startsWith(DETAILS)\n  const gatherFields = filterFields.filter(x => valueLists[x] == null)\n  return these\n  ? gatherIds(tableData, listIds, filterFields, fieldSpecs)\n  : {\n    ...pickBy(valueLists, (value, key) => filterFields.includes(key)),\n    ...(gatherFields.length ? gatherIds(tableData, listIds, gatherFields, fieldSpecs) : emptyO),\n  }\n}, emptyO, { debug: 'compileFieldIds' })\n\nexport const compileValues = memoize((tables, table, filterTag, listIds, filterField, filterRelField) => {\n  const { [table]: tableData } = tables\n  if (tableData == null) {return emptyA}\n  const { fieldSpecs } = tableData\n  const fieldIds = compileFieldIds(tableData, filterTag, listIds)[filterField]\n  return gatherValues(tables, fieldSpecs, fieldIds, filterField, filterRelField)\n}, emptyO, { debug: 'compileValues' })\n\nconst initFilterSettings = memoize((tables, table, filterData, filterTag, fieldIds) => {\n  const { [table]: tableData } = tables\n  if (tableData == null) {return emptyO}\n  const { fields, filterList } = tableData\n  if (filterList == null) {return emptyO}\n  const { [filterTag]: filterSettings = emptyO } = filterData || emptyO\n  const presentFilterList = filterList.filter(x => fields[x.field])\n  const newFilterSettings = {}\n  presentFilterList.forEach((filterSpec, filterId) => {\n    const { [filterId]: filterSetting } = filterSettings\n    if (filterSpec.type === 'Fulltext') {\n      if (filterSetting == null) {newFilterSettings[filterId] = emptyS}\n    }\n    else {\n      const theFacets = filterSetting || emptyO\n      const newFacets = {}\n      const { field, relField } = filterSpec\n      const { [field]: theseIds } = fieldIds\n      if (relField) {\n        const { fieldSpecs } = tableData\n        const fieldValues = gatherValues(tables, fieldSpecs, theseIds, field, relField)\n        for (const value of Object.keys(fieldValues)) {\n          newFacets[value] = theFacets[value] == null ? true : theFacets[value]\n        }\n      }\n      else {\n        theseIds.forEach(valueId => {\n          newFacets[valueId] = theFacets[valueId] == null ? true : theFacets[valueId]\n        })\n      }\n      newFacets[emptyS] = theFacets[emptyS] == null ? true : theFacets[emptyS]\n      if (Object.keys(newFacets).length) {newFilterSettings[filterId] = newFacets}\n    }\n  })\n  return newFilterSettings\n}, emptyO, { debug: 'initFilterSettings' })\n\nexport const computeFiltering = memoize((tables, filters, table, filterTag, listIds) => {\n  const { [table]: tableData } = tables\n  if (tableData == null) {return emptyO}\n  const { entities, fields, fieldSpecs, filterList } = tableData\n  if (filterList == null) {return { filteredIds: listIds }}\n\n  const { [table]: filterData = emptyO } = filters\n  const { [filterTag]: filterSettings } = filterData\n  if (filterSettings == null) {return emptyO}\n\n  const fieldIds = compileFieldIds(tableData, filterTag, listIds)\n  const presentFilterList = filterList.filter(x => fields[x.field])\n\n  const filterChecks = {}\n\n  const makeFilterCheck = (filterSpec, filterId) => {\n    const { [filterId]: filterSetting } = filterSettings\n    const { field, relField } = filterSpec\n    const { [field]: fieldSpec } = fieldSpecs\n    const filterCheck = filterSpec.type === 'Fulltext' ? fulltextCheck : facetCheck\n    filterChecks[filterId] = filterCheck(tables, field, relField, fieldSpec, filterSetting)\n  }\n\n  const otherFilteredIds = {}\n  presentFilterList.forEach((filterSpec, filterId) => {\n    makeFilterCheck(filterSpec, filterId)\n    otherFilteredIds[filterId] = []\n  })\n  const filteredIds = []\n\n  for (const eId of listIds) {\n    const { [eId]: entity } = entities\n    let theOneFail = null\n    let v = true\n    let discard = false\n    Object.entries(filterChecks).forEach(([filterId, filterCheck]) => {\n      if (!discard) {\n        const pass = filterCheck(entity)\n        if (!pass) {\n          v = false\n          if (theOneFail === null) {theOneFail = filterId}\n          else {discard = true}\n        }\n      }\n    })\n    if (!discard) {\n      if (v) {\n        filteredIds.push(eId)\n        presentFilterList.forEach((filterSpec, filterId) => {\n          otherFilteredIds[filterId].push(eId)\n        })\n      }\n      else {otherFilteredIds[theOneFail].push(eId)}\n    }\n  }\n  const amounts = {}\n  presentFilterList.forEach(({ field, relField, type }, filterId) => {\n    amounts[filterId] = type === 'Fulltext'\n    ? null\n    : countFacets(tables, field, relField, fieldSpecs, fieldIds[field], otherFilteredIds[filterId], entities)\n  })\n  const filteredAmountOthers = {}\n  Object.entries(otherFilteredIds).forEach(([filterId, x]) => {\n    filteredAmountOthers[filterId] = x.length\n  })\n  return {\n    filteredIds,\n    filteredAmountOthers,\n    amounts,\n  }\n}, emptyO, { debug: 'computeFiltering' })\n\nconst gatherIds = memoize((tableData, listIds, filterFields, fieldSpecs) => {\n  const theseIds = {}\n  const { entities } = tableData\n  const records = listIds.map(eId => entities[eId].values)\n  for (const field of filterFields) {\n    const { [field]: { multiple } } = fieldSpecs\n    const valueSet = new Set()\n    for (const r of records) {\n      const { [field]: val } = r\n      if (val == null) {continue}\n      if (multiple) {for (const v of val) {valueSet.add(v)}}\n      else {valueSet.add(val)}\n    }\n    theseIds[field] = Array.from(new Set(valueSet))\n  }\n  return theseIds\n}, emptyO, { debug: 'gatherIds' })\n\nconst gatherAllIds = memoize((tableData, filterFields, fieldSpecs) => {\n  const theseIds = {}\n  const { entities } = tableData\n  for (const field of filterFields) {\n    const { [field]: { multiple } } = fieldSpecs\n    const valueSet = new Set()\n    for (const e of Object.values(entities)) {\n      const { values: { [field]: val } } = e\n      if (val == null) {continue}\n      if (multiple) {for (const v of val) {valueSet.add(v)}}\n      else {valueSet.add(val)}\n    }\n    theseIds[field] = Array.from(new Set(valueSet))\n  }\n  return theseIds\n}, emptyO, { debug: 'gatherAllIds' })\n\nconst gatherValues = memoize((tables, fieldSpecs, fieldIds, filterField, filterRelField) => {\n  const { [filterField]: { valType } } = fieldSpecs\n  if (fieldIds == null) {return emptyO}\n  const fieldValues = {[emptyS]: '-none-'}\n  if (typeof valType === 'string') {\n    fieldIds.forEach(_id => {\n      fieldValues[_id] = _id\n    })\n  }\n  else {\n    const { relTable } = valType\n    if (filterRelField == null) {\n      fieldIds.forEach(_id => {\n        fieldValues[_id] = headEntity(tables, relTable, _id)\n      })\n    }\n    else {\n      const { [relTable]: { entities: relEntities } } = tables\n      const relValues = Array.from(new Set(fieldIds.map(_id => relEntities[_id].values[filterRelField]))).sort()\n      relValues.forEach(val => {\n        fieldValues[val] = val\n      })\n    }\n  }\n  return fieldValues\n}, emptyO, { debug: 'gatherValues' })\n\nexport const makeTag = (select, masterId, linkField) => masterId == null\n? select\n: `${select}-${masterId}-${linkField}`\n\nconst entityFieldVal = memoize(relField =>\n  (tables, relTable, valId) => tables[relTable].entities[valId].values[relField],\n  emptyO,\n)\n\nconst getUnpack = (tables, fieldSpec, asString = false, relField = null) => {\n  const { valType, multiple } = fieldSpec\n  let unpack\n  if (typeof valType === 'string') {\n    unpack = multiple\n    ? asString\n      ? v => v == null\n        ? emptyS\n        : v.join(' ')\n      : v => v == null\n        ? emptyA\n        : v\n    : asString\n      ? v => v == null\n        ? emptyS\n        : v\n      : v => v == null\n        ? emptyA\n        : [v]\n  }\n  else {\n    const { relTable } = valType\n    const entityRep = relField\n    ? entityFieldVal(relField)\n    : headEntity\n    unpack = multiple\n    ? asString\n      ? v => v == null\n        ? emptyS\n        : v.map(w => entityRep(tables, relTable, w).join(' '))\n      : v => v == null\n        ? emptyA\n        : relField == null\n          ? v\n          : entityRep(tables, relTable, v)\n    : asString\n      ? v => v == null\n        ? emptyS\n        : entityRep(tables, relTable, v)\n      : v => v == null\n        ? emptyA\n        : relField == null\n          ? [v]\n          : [entityRep(tables, relTable, v)]\n  }\n  return unpack\n}\n\nconst fulltextCheck = memoize((tables, field, relField, fieldSpec, term) => {\n  const unpack = getUnpack(tables, fieldSpec, true)\n  const search = (term || emptyS).toLowerCase()\n  if (search == null || search === emptyS) {\n    return () => true\n  }\n  return entity => {\n    const { values: { [field]: val } } = entity\n    const rep = unpack(val)\n    return rep != null && rep.toLowerCase().indexOf(search) !== -1\n  }\n}, emptyO, { debug: fulltextCheck })\n\nconst facetCheck = memoize((tables, field, relField, fieldSpec, facetSettings) => {\n  const unpack = getUnpack(tables, fieldSpec, false, relField)\n  if ((facetSettings || emptyO).size === 0) {\n    return () => false\n  }\n  return entity => {\n    const { values: { [field]: val } } = entity\n    const rep = unpack(val)\n    if (rep.length === 0) {\n      return facetSettings[emptyS]\n    }\n    for (const r of rep) {\n      if (facetSettings[r]) {\n        return true\n      }\n    }\n    return false\n  }\n}, emptyO, { debug: facetCheck })\n\nconst countFacets = memoize((tables, field, relField, fieldSpecs, fieldIds, filteredIds, entities) => {\n  const { [field]: fieldSpec } = fieldSpecs\n  const unpack = getUnpack(tables, fieldSpec, false, relField)\n  const facetAmounts = {}\n  facetAmounts[emptyS] = 0\n  if (relField) {\n    const fieldValues = gatherValues(tables, fieldSpecs, fieldIds, field, relField)\n    for (const value of Object.keys(fieldValues)) {\n      facetAmounts[value] = 0\n    }\n  }\n  else {\n    fieldIds.forEach(_id => {facetAmounts[_id] = 0})\n  }\n  for (const eId of filteredIds) {\n    const { [eId]: { values: { [field]: val } } } = entities\n    const rep = unpack(val)\n    if (rep.length === 0) {\n      facetAmounts[emptyS] += 1\n    }\n    else {\n      for (const r of rep) {\n        facetAmounts[r] += 1\n      }\n    }\n  }\n  return facetAmounts\n}, emptyO, { debug: 'countFacets' })\n\nexport const testAllChecks = filterSetting => {\n  let allTrue = true\n  let allFalse = true\n  if (filterSetting == null) {return { allTrue, allFalse }}\n  for (const valueEntry of Object.entries(filterSetting)) {\n    if (valueEntry[1]) {allFalse = false}\n    else {allTrue = false}\n  }\n  return { allTrue, allFalse }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/filters.js","import { makeSet } from 'memo'\n\n/* ACTIONS */\n\n/* REDUCER */\n\n/* SELECTORS */\n\nexport const getForms = ({ form }) => ({ form: getKeys(form) })\n\n/* HELPERS */\n\nconst getKeys = form => makeSet(Object.keys(form))\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/forms.js","import orderBy from 'lodash/orderby'\nimport mapValues from 'lodash/mapvalues'\n\nimport { memoize } from 'memo'\nimport { makeReducer, emptyA, emptyO } from 'utils'\n\nimport { repr } from 'tables'\n\n/* ACTIONS */\n\nexport const resetSort = gridTag => ({ type: 'resetSort', gridTag })\nexport const addColumn = (gridTag, column, direction) => ({ type: 'addColumn', gridTag, column, direction })\nexport const delColumn = (gridTag, column) => ({ type: 'delColumn', gridTag, column })\nexport const turnColumn = (gridTag, column) => ({ type: 'turnColumn', gridTag, column })\n\n/* REDUCER */\n\nconst flows = {\n  resetSort(state, { gridTag }) {\n    return { ...state, [gridTag]: emptyA }\n  },\n  addColumn(state, { gridTag, column, direction }) {\n    const { [gridTag]: sortSpec } = state\n    return { ...state, [gridTag]: (sortSpec || emptyA).filter(x => x[0] !== column).concat([[column, direction]]) }\n  },\n  delColumn(state, { gridTag, column }) {\n    const { [gridTag]: sortSpec } = state\n    return { ...state, [gridTag]: (sortSpec || emptyA).filter(x => x[0] !== column) }\n  },\n  turnColumn(state, { gridTag, column }) {\n    const { [gridTag]: sortSpec } = state\n    return { ...state, [gridTag]: (sortSpec || emptyA).map(x => [x[0], x[0] === column ? -x[1] : x[1]]) }\n  },\n}\n\nexport default makeReducer(flows, emptyO)\n\n/* SELECTORS */\n\nexport const getGrid = ({ grid }) => ({ grid })\n\n/* HELPERS */\n\nexport const compileSortedData = memoize((tables, table, listIds, sortSpec, settings) => {\n  const sortColumns = sortSpec.map(x => x[0])\n  const sortDirs = sortSpec.map(x => x[1] === 1 ? 'asc' : 'desc')\n  const { [table]: { entities } } = tables\n  const r = reprX(tables, table, settings)\n  const fullData = listIds.map(_id => mapValues(entities[_id].values, r))\n  return orderBy(fullData, sortColumns, sortDirs).map(x => x._id)\n}, emptyO)\n\nconst reprX = (tables, table, settings) => {\n  const { [table]: { fieldSpecs } } = tables\n  return (myValues, field) => {\n    if (field === '_id') {return myValues}\n    const { [field]: { valType, multiple } } = fieldSpecs\n    return repr(tables, table, field, valType, multiple, null, myValues, settings, '|')\n  }\n}\n\n\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/grid.js","import { accessData } from 'server'\nimport { makeReducer, emptyO } from 'utils'\n\n/* ACTIONS */\n/*\n * Most actions call accessData, which will dispatch the ultimate fetch action.\n */\nexport const fetchMe = () => (\n  accessData({ type: 'fetchMe', contentType: 'db', path: '/who/ami', desc: 'me' })\n)\n\n/* REDUCER */\n\nconst flows = {\n  fetchMe(state, { data }) {\n    if (data == null) {return emptyO}\n    return { ...data }\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getMe = ({ me }) => ({ me })\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/me.js","import update from 'immutability-helper'\n\nimport { makeReducer, emptyS, emptyA } from 'utils'\n\n/* ACTIONS */\n\nexport const notify = msgs => ({ type: 'msgs', msgs })\nexport const clear = () => ({ type: 'clear' })\nexport const display = onOff => ({ type: 'display', onOff })\n\n/* REDUCER */\n\nconst subFlows = {\n  progress(state, { desc }) {\n    return update(state, {\n      messages: { $push: [{ kind: 'special', text: `still waiting for ${desc}`}] },\n    })\n  },\n  pending(state, { desc, busy, extraMsgs }) {\n    return update(state, {\n      messages: { $push: [...extraMsgs, { kind: 'special', text: `waiting for ${desc}`}] },\n      busy: { $set: busy + 1 },\n    })\n  },\n  success(state, { desc, busy, extraMsgs }) {\n    return update(state, {\n      messages: { $push: [...extraMsgs, { kind: 'info', text: `${desc} ok` }] },\n      busy: { $set: busy - 1 },\n      show: { $set: extraMsgs.some(m => m.kind === 'warning' || m.kind === 'error') },\n    })\n  },\n  error(state, { desc, busy, extraMsgs }) {\n    return update(state, {\n      messages: { $push: [...extraMsgs, { kind: 'error', text: `${desc} failed` }] },\n      busy: { $set: busy - 1 },\n      show: { $set: true },\n    })\n  },\n}\n\nconst flows = {\n  async(state, { msgs, status, desc }) {\n    const { busy } = state\n    const extraMsgs = msgs || emptyA\n    const { [status]: subFlow } = subFlows\n    return subFlow\n    ? subFlow(state, { extraMsgs, desc, busy })\n    : state\n  },\n  msgs(state, { msgs }) {\n    return update(state, {\n      messages: { $push: msgs },\n      show: { $set: true },\n    })\n  },\n  clear(state) {\n    return update(state, {\n      messages: { $set: emptyA },\n      show: { $set: false },\n    })\n  },\n  display(state, { onOff }) {\n    return update(state, {\n      show: { $set: onOff },\n    })\n  },\n}\n\nexport default makeReducer(flows, { messages: emptyA, busy: 0, show: false })\n\n/* SELECTORS */\n\nexport const getNotes = ({ notes }) => {\n  const { messages, busy, show } = notes\n  let lastNote = -1\n  let lastKind = emptyS\n  messages.forEach((note, i) => {\n    const { kind } = note\n    if (kind === 'error') {\n      lastNote = i\n      lastKind = 'error'\n    }\n    else if (kind === 'warning') {\n      if (lastKind !== 'error') {\n        lastNote = i\n        lastKind = 'warning'\n      }\n    }\n  })\n  return { messages, busy, show: show || lastKind, lastMsg: messages.length - 1, lastNote, lastKind }\n}\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/notes.js","import { combineReducers, createStore, applyMiddleware } from 'redux'\nimport thunkMiddleware from 'redux-thunk'\nimport { reducer as form } from 'redux-form'\n\nimport settings from 'settings'\nimport win from 'win'\nimport server from 'server'\nimport notes from 'notes'\nimport docs from 'docs'\nimport tables from 'tables'\nimport me from 'me'\nimport filters from 'filters'\nimport alter from 'alter'\nimport select from 'select'\nimport grid from 'grid'\n\n/* ACTIONS */\n\n/* global process */\n/* global require */\n\n/* actions to ignore in logging and in the redux dev tool\n * Mainly used for actions generated by third party libraries, such as redux-form\n */\n\nconst predicate = (state, action) => !action.type.startsWith('@@redux-form')\n\n//const predicate = () => true // if you want to see all actions\n\nconst configureStore = reducer => {\n  let store\n  if (process.env.NODE_ENV === `development`) {\n    const { createLogger } = require(`redux-logger`)\n    const { composeWithDevTools } = require('redux-devtools-extension')\n    const composeEnhancers = composeWithDevTools({ predicate })\n    store = createStore(\n      reducer,\n      composeEnhancers(\n        applyMiddleware(\n          thunkMiddleware,\n          createLogger({ predicate }),\n        )\n      )\n    )\n  }\n  else {\n    store = createStore(\n      reducer,\n      applyMiddleware(\n        thunkMiddleware,\n      )\n    )\n  }\n  return store\n}\n\n/* REDUCER */\n\nexport default configureStore(combineReducers({\n  settings,\n  win,\n  server,\n  notes,\n  docs,\n  tables,\n  me,\n  filters,\n  alter,\n  form,\n  select,\n  grid,\n}))\n\n/* SELECTORS */\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/roots.js","import update from 'immutability-helper'\n\nimport { makeReducer, emptyS, emptyA, emptyO } from 'utils'\nimport { memoize } from 'memo'\n\nimport { repr } from 'tables'\n\n/* DEFINITIONS */\n\nconst initSelect = { search: emptyS, popUp: false }\n\n/* ACTIONS */\n\nexport const setSearch = (selectTag, search) => ({ type: 'setSearch', selectTag, search })\nexport const setPopUp = (selectTag, onOff) => ({ type: 'setPopUp', selectTag, onOff })\nexport const togglePopUp = selectTag => ({ type: 'togglePopUp', selectTag })\n\n/* REDUCER */\n\nconst flows = {\n  setSearch(state, { selectTag, search }) {\n    return update(state, {\n      [selectTag]: {\n        $apply: st => update(st || initSelect, { search: { $set: search } }),\n      },\n    })\n  },\n  setPopUp(state, { selectTag, onOff }) {\n    return update(state, {\n      [selectTag]: {\n        $apply: st => update(st || initSelect, { popUp: { $set: onOff } }),\n      },\n    })\n  },\n  togglePopUp(state, { selectTag }) {\n    const { [selectTag]: myState } = state\n    const newOnOff = myState == null ? true : !myState.popUp\n    return update(state, {\n      [selectTag]: {\n        $apply: st => update(st || initSelect, { popUp: { $set: newOnOff } }),\n      },\n    })\n  },\n}\n\nexport default makeReducer(flows, emptyO)\n\n/* SELECTORS */\n\nexport const getSelect = ({ select }) => ({ select })\n\n/* HELPERS */\n\nexport const compileOptions = memoize((tables, table, allowed, field, settings) => {\n  const { [table]: { valueLists, fieldSpecs } } = tables\n  const { [field]: valueList } = (valueLists || emptyO)\n  if (valueList == null) {return { options: emptyA, optionLookup: emptyO }}\n\n  const { [field]: { valType } } = fieldSpecs\n  const allowedOptions = allowed == null ? valueList : valueList.filter(_id => allowed.includes(_id))\n  const options = allowedOptions.map(val => ({\n    value: val, label: repr(tables, table, field, valType, false, null, val, settings, ', '),\n  }))\n  const optionLookup = {}\n  options.forEach(({ value: val, label: lab }) => {optionLookup[val] = lab})\n  return { options, optionLookup }\n}, emptyO, { debug: 'compileOptions' })\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/select.js","import 'whatwg-fetch'\nimport { SubmissionError } from 'redux-form'\nimport update from 'immutability-helper'\n\nimport { makeReducer } from 'utils'\n\n/* DEFINITIONS */\n\nconst rootUrl = '/api/'\n\n/* ACTIONS */\n\nconst progress = (path, desc) => ({ type: 'async', status: 'progress', path, desc })\nconst ask = (path, desc) => ({ type: 'async', status: 'pending', path, desc })\nconst err = (path, desc, msgs) => ({ type: 'async', status: 'error', path, desc, msgs })\nconst succeed = (path, desc, msgs) => ({ type: 'async', status: 'success', path, desc, msgs })\n\n/* global process */\n\nexport const accessData = task => (dispatch, getState) => {\n  const { path, contentType, desc, sendData } = task\n  const { [path]: asyncState } = getState().server\n  if (asyncState > 0) {\n    dispatch(progress(path, desc))\n    return\n  }\n  dispatch(ask(path, desc))\n\n  let settings = { credentials: 'same-origin' }\n  if (sendData != null) {\n    settings = {\n      ...settings,\n      method: 'POST',\n      body: JSON.stringify(sendData),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    }\n  }\n  const actionUrl = `${rootUrl}${contentType}${path}`\n  return fetch(actionUrl, settings)\n  .then(\n    response => response.ok\n    ? response.json()\n    : { good: false, msgs: [{ kind: 'error', text: `No valid response from the server to ${actionUrl}` }] }\n  )\n  .then(json => {\n    const { msgs, good, data } = json\n    if (good) {\n      dispatch(succeed(path, desc, msgs))\n      dispatch({ ...task, data })\n    }\n    else {\n      dispatch(err(path, desc, msgs))\n    }\n    if (data && data.diags && Object.keys(data.diags).length > 0) {\n      throw new SubmissionError(data.diags)\n    }\n  })\n  .catch(error => {\n    if (process.env.NODE_ENV === `development`) {console.error(error)}\n    if (error instanceof SubmissionError) {\n      throw error\n    }\n    else {\n      dispatch(err(path, desc, [{kind: 'error', text: error.toString()}]))\n    }\n  })\n}\n\n/* REDUCER */\n\nconst subFlows = {\n  progress(state, { path }) {\n    return update(state, { [path]: { $apply: x => x + 1 } })\n  },\n  pending(state, { path }) {\n    return update(state, { [path]: { $set: 1 } })\n  },\n  success(state, { path }) {\n    return update(state, { [path]: { $set: 0 } })\n  },\n  error(state, { path }) {\n    return update(state, { [path]: { $set: -1 } })\n  },\n}\n\nconst flows = {\n  async(state, { status, path }) {\n    const { [status]: subFlow } = subFlows\n    return subFlow\n    ? subFlow(state, { path })\n    : state\n  },\n}\n\nexport default makeReducer(flows)\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/server.js","import update from 'immutability-helper'\nimport { makeReducer } from 'utils'\n\n/* ACTIONS */\n\nexport const set = (key, value) => ({ type: 'setSetting', key, value })\n\n/* REDUCER */\n\nconst flows = {\n  set(state, { key, value }) {return update(state, { [key]: { $set: value } })},\n}\n\nconst initSettings = () => ({\n  provenanceFields: new Set(['creator', 'dateCreated', 'modified']),\n  hideProvenance: true,\n  longDates: {\n    assessment: {\n      dateSubmitted: true,\n      dateWithdrawn: true,\n    },\n  },\n})\n\nexport default makeReducer(flows, initSettings())\n\n/* SELECTORS */\n\nexport const getSettings = ({ settings }) => ({ settings })\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/settings.js","import update from 'immutability-helper'\n\nimport { browserHistory } from 'react-router'\n\nimport { accessData } from 'server'\nimport { memoize } from 'memo'\nimport { makeReducer, updateAuto, getUrlParts, emptyS, emptyA, emptyO } from 'utils'\n\nimport { compileAlternatives, setItems } from 'alter'\n\n/* DEFS */\n\nexport const DETAILS = 'details'\nexport const ALLIDS = 'allIds'\nexport const MYIDS = 'myIds'\n\n/* ACTIONS */\n/*\n * Most actions call accessData, which will dispatch the ultimate fetch action.\n */\n\nexport const fetchTable = (table, select = ALLIDS, complete) => accessData({\n  type: 'fetchTable',\n  contentType: 'db',\n  path: `/${select === MYIDS ? 'my' : emptyS}list?table=${table}&complete=${complete}`,\n  desc: `${table} table`,\n  table,\n})\n\nexport const fetchTables = (tables, tableList, dispatch) => {\n  tableList.forEach(([table, select = ALLIDS, complete = true]) => {\n    if (needTable(tables, table, select, complete)) {dispatch(fetchTable(table, select, complete))}\n  })\n}\n\nexport const fetchItem = (table, eId, head) => accessData({\n  type: 'fetchItem',\n  contentType: 'db',\n  path: `/view?table=${table}&id=${eId}`,\n  desc: `${table} record ${head}`,\n  table,\n})\n\nexport const fetchItems = (table, eIds, alterSection, alt) => accessData({\n  type: 'fetchItems',\n  contentType: 'db',\n  path: `/view?table=${table}`,\n  desc: `${table} records ${eIds.length}`,\n  sendData: eIds,\n  table,\n  eIds, alterSection, alt,\n})\n\nexport const modItem = (table, eId, head, values) => accessData({\n  type: 'modItem',\n  contentType: 'db',\n  path: `/mod?table=${table}&action=update`,\n  desc: `${table} update record ${head}`,\n  sendData: { _id: eId, values },\n  table,\n})\n\nexport const insertItem = (table, select = ALLIDS, masterId = null, linkField = null) => accessData({\n  type: 'insertItem',\n  contentType: 'db',\n  path: `/mod?table=${table}&action=insert`,\n  desc: `${table} insert new record`,\n  sendData: { masterId, linkField },\n  table,\n  select,\n})\n\nexport const delItem = (table, eId, head) => accessData({\n  type: 'delItem',\n  contentType: 'db',\n  path: `/mod?table=${table}&action=delete`,\n  desc: `${table} delete record ${head}`,\n  sendData: { _id: eId },\n  table,\n})\n\n/* REDUCER */\n\nconst updateItemWithFields = (state, table, _id, fields, values) => {\n  const newVals = {}\n  fields.forEach(field => {newVals[field] = values[field]})\n  return updateAuto(\n    state,\n    [table, 'entities', _id, 'values'],\n    { $merge: newVals },\n  )\n}\n\nconst updateEntities = (stateEntities, entities) => {\n  let newEntities = entities\n  Object.entries(stateEntities).forEach(([_id, stateEntity]) => {\n    const newEntity = newEntities[_id]\n    if (newEntity != null && stateEntity.fields != null && newEntity.fields == null) {\n      const theseValues = update(stateEntity.values, { $merge: newEntity.values })\n      newEntities = update(\n        newEntities, {\n          [_id]: {\n            fields: { $set: stateEntity.fields },\n            values: { $merge: theseValues },\n          },\n        },\n      )\n    }\n  })\n  return update(stateEntities, { $merge: newEntities })\n}\n\nconst flows = {\n  fetchTable(state, { data }) {\n    if (data == null) {return state}\n    let newState = state\n    Object.entries(data).forEach(([table, tableData]) => {\n      const { [table]: stateTableData = emptyO } = state\n      const { entities: stateEntities = emptyO } = stateTableData\n      const { entities } = tableData\n\n      const newEntities = updateEntities(stateEntities, entities)\n      const newTableData = update(tableData, { entities: { $set: newEntities } })\n      newState = updateAuto(newState, [table], { $merge: newTableData })\n    })\n    return newState\n  },\n  fetchItem(state, { data, table }) {\n    if (data == null) {return state}\n    const { values: { _id } } = data\n    return updateAuto(state, [table, 'entities', _id], { $set: data })\n  },\n  fetchItems(state, { data, table }) {\n    if (data == null || data.length == 0) {return state}\n    let newState = state\n    for (const dataSlice of data) {\n      const { values: { _id } } = dataSlice\n      newState = updateAuto(newState, [table, 'entities', _id], { $set: dataSlice })\n    }\n    return newState\n  },\n  modItem(state, { data, table }) {\n    if (data == null) {return state}\n    const { values, values: { _id }, newValues, workflow } = data\n    const fieldUpdates = {}\n    Object.entries(values).forEach(([key, value]) => {fieldUpdates[key] = { $set: value }})\n    let newState = updateAuto(state, [table, 'entities', _id, 'values'], fieldUpdates)\n    if (newValues != null) {\n      for (const { _id, rep, repName, relTable, field } of newValues) {\n        newState = update(newState, { [table]: { valueLists: { [field]: { $push: [_id] } } } })\n        newState = updateItemWithFields(newState, relTable, _id, ['_id', repName], { _id, [repName]: rep })\n      }\n    }\n    for (const [relTable, relId, wf] of workflow) {\n      newState = updateAuto(newState, [relTable, 'entities', relId, 'workflow'], { $set: wf })\n    }\n    return newState\n  },\n  insertItem(state, { data, table, select }) {\n    if (data == null || data.length == 0) {return state}\n    let newState = state\n    for (const dataSlice of data) {\n      const { table: thisTable, ...dataRest } = dataSlice\n      const { values: { _id } } = dataRest\n      newState = updateAuto(newState, [thisTable, 'entities', _id], { $set: dataRest })\n      if (newState[thisTable][ALLIDS] != null) {\n        newState = updateAuto(newState, [thisTable, ALLIDS], { $push: [_id] }, true)\n      }\n      if (select === MYIDS && table === thisTable) {\n        newState = updateAuto(newState, [table, MYIDS], { $push: [_id] }, true)\n      }\n      newState = update(newState, {\n        [thisTable]: {\n          lastInserted: { $set: _id },\n        },\n      })\n    }\n    return newState\n  },\n  delItem(state, { data }) {\n    if (data == null || data.length == 0) {return state}\n    let newState = state\n    for (const dataSlice of data) {\n      const [thisTable, _id] = dataSlice\n      newState = update(newState, { [thisTable]: { entities: { $unset: [_id] } } })\n      const { [thisTable]: { myIds, allIds } } = newState\n      for (const [name, list] of Object.entries({ myIds, allIds})) {\n        if (list != null) {\n          const otherIds = list.filter(x => x !== _id)\n          newState = update(newState, { [thisTable]: { [name]: { $set: otherIds } } })\n        }\n      }\n    }\n    return newState\n  },\n}\n\nexport default makeReducer(flows)\n\n/* SELECTORS */\n\nexport const getTables = ({ tables }) => ({ tables })\n\n/* HELPERS */\n\nexport const toDb = memoize((table, eId, head, dispatch) => values => dispatch(modItem(table, eId, head, values)))\n\nconst hasTableKey = (tables, table, key, value = null) => {\n  if (tables == null) {return false}\n  const { [table]: tableData } = tables\n  if (tableData == null) {return false}\n  return tableData[key] != null && (value == null || tableData[key] === value)\n}\n\nexport const needTable = (tables, table, select = ALLIDS, complete) => {\n  if (!hasTableKey(tables, table, select)) {return true}\n  if (complete && !hasTableKey(tables, table, 'complete', true)) {return true}\n  const { [table]: { fieldSpecs } } = tables\n  const relTables = Array.from(\n    new Set(\n      Object.entries(fieldSpecs).\n      filter(entry => ((typeof entry[1].valType) === 'object') && entry[1].valType.relTable != null).\n      map(entry => entry[1].valType.relTable)\n    )\n  )\n  if (relTables.some(relTable => !hasTableKey(tables, relTable, ALLIDS))) {return true}\n  return false\n}\n\nexport const needTables = (tables, tableList) =>\n  tableList.some(([table, select = ALLIDS, complete = true]) =>\n    needTable(tables, table, select, complete)\n  )\n\nexport const needValues = (entities, eId) => (\n  entities == null\n  || entities[eId] == null\n  || entities[eId].fields == null\n  || entities[eId].perm == null\n)\n\nexport const listValues = memoize(({ tables, table, eId, field }) => (\n  tables == null\n  ? emptyA\n  : tables[table] == null\n    ? emptyA\n    : tables[table].entities[eId] == null\n      ? emptyA\n      : new Set(tables[table].entities[eId][field])\n), emptyO)\n\n/* Record and Field value representation\n *\n * In this dux (tables), we provide export functions to\n *\n * A. convert a raw entity into a string value that can act as a heading for that record\n *    headEntity()\n *\n * B. convert a raw value of any field into an appropriate string.\n *    repr()\n *\n * In the library file 'fields' we provide a function (wrappedRepr)\n * to get field values into appropriate elements * with appropriate attributes.\n *\n * There are complications.\n *\n * 1. tables are really special\n * 2. fields may have multiple values\n * 3. field values may refer to other tables by id\n *\n * Ad 1: Special tables\n * For special tables, such as user, country, and a bunch of others, we write special head functions.\n * headEntity() will make the switch, based on the name of the table.\n *\n * Ad 2: Multiplicity\n * Whenever we encounter fields with multiple values, we do the relevant operations value-wise.\n * repr() works such that if an array of values goes in, an array of representations goes out.\n * Unless the 'sep' parameter is passed.\n * In that case, if there are multiple values, their reps will be joined by means of the 'sep'.\n *\n * Ad 3: Releated tables\n * When a field is an id referring to an entity in another table,\n * there are various options.\n * The default case is to use the headEntity of the related record as representation.\n * It is also possible to pass a detail field name.\n * In that case, the repr of that field of the detail record will be taken.\n *\n * Combination of 2 and 3.\n * It is possible that a field that points to a related table, has multiple values.\n * It is possible that the detail field, used to represent the detail records, itself has multiple values.\n * repr() deals with all cases.\n * Without the sep parameter, it might return:\n *\n * (a) a single string (if field and detail field are both not multiple)\n * (b1) an array of strings (if field is not multiple, but detail field is multiple)\n * (b2) an array of strings (if field is multiple, but detail field is not multiple)\n * (c) an array of an array of strings (if field and detail field are both multiple)\n *\n * You can pass a 'sep' and a 'detail sep' to repr().\n * If you pass 'sep', and field is multiple, the resulting reps will be joined with sep.\n * If you pass 'detail sep' and detail field is multiple, the resulting detail reps will be joined with detail sep.\n *\n * One caveat: if both field and detail field are multiple, and sep is given, detail sep must also be given,\n * otherwise the detail reps would be arrays, which cannot be string-joined.\n * If a detail sep is not passed in this case, we assume a default value: a single space.\n *\n */\n\n/* The table specific head functions\n */\n\nconst headUser = memoize((tables, valId) => {\n  const { user: { entities: { [valId]: entity } } } = tables\n  if (entity) {\n    const { values } = entity\n    return presentUser(values)\n  }\n  else {return 'UNKNOWN'}\n}, emptyO)\n\nexport const presentUser = userInfo => {\n  const { name, firstName, lastName, email, eppn, authority, org } = userInfo\n  const orgRep = org ? ` (${org})` : emptyS\n  if (name) {return `${name}${orgRep}`}\n  if (firstName || lastName) {\n    return `${firstName || emptyS}${(firstName && lastName) ? ' ' : ''}${lastName || emptyS}`\n  }\n  if (email) {return `${email}${orgRep}`}\n  const authorityRep = authority ? ` - ${authority}` : emptyS\n  if (eppn) {return `${eppn}${authorityRep}${orgRep}`}\n  return '!unidentified user!'\n}\n\nconst headCountry = memoize((tables, valId) => {\n  const { country: { entities: { [valId]: entity } } } = tables\n  if (entity) {\n    const { values: { name, iso } } = entity\n    return `${iso}: ${name}`\n  }\n  else {return 'UNKNOWN'}\n}, emptyO)\n\nconst headType = memoize((tables, valId) => {\n  const { typeContribution: { entities: { [valId]: entity } } } = tables\n  if (entity) {\n    const { values: { mainType, subType } } = entity\n    const sep = (mainType && subType) ? ' / ' : emptyS\n    return `${mainType}${sep}${subType}`\n  }\n  else {return 'UNKNOWN'}\n}, emptyO)\n\nconst headScore = memoize((tables, valId) => {\n  let valRep\n  const { score: { entities: { [valId]: entity } } } = tables\n  if (entity) {\n    const { values: { score = 'N/A', level = 'N/A', description = emptyS } } = entity\n    valRep = (score || level)\n    ? `${score} - ${level}`\n    : description\n  }\n  else {valRep = 'UNKNOWN'}\n  return valRep\n}, emptyO)\n\nconst headRelated = relTable =>\n  memoize((tables, valId, settings) => {\n    const { [relTable]: { title = 'rep', entities: { [valId]: entity }, fieldSpecs } } = tables\n    if (entity) {\n      const { values: { [title]: rep } } = entity\n      const { [title]: { valType } } = fieldSpecs\n      return repr1Head(tables, relTable, title, valType, rep, settings)\n    }\n    else {return 'UNKNOWN'}\n  }, emptyO)\n\n/* The head switch function\n */\n\nconst headSwitch = {\n  user: headUser,\n  country: headCountry,\n  typeContribution: headType,\n  score: headScore,\n  default: headRelated,\n}\n\n/* The generic head function is exported\n */\n\nexport const headEntity = (tables, table, valId, settings) =>\n  (headSwitch[table] || headSwitch.default(table))(tables, valId, settings)\n\nconst trimDate = (text, table, field, settings) =>\n  text == null\n  ? emptyS\n  : !(settings.longDates[table] && settings.longDates[table][field])\n    ? text.replace(/T.*$/, emptyS)\n    : text.replace(/\\.[0-9]+/, emptyS)\n\n/*\n * The repr functions\n *\n * repr() has to deal with very many cases, so we break it down\n * into simpler functions.\n *\n * repr1Head()\n *\n * Deals with a single value\n * When a field points to a related record, headEntity() is used as representation.\n * So no complications with detail fields.\n * The result is always a string.\n *\n * reprHead()\n * Deals with single and multiple values.\n * When a field points to a related record, headEntity() is used as representation.\n * So no complications with detail fields.\n * If the field is multiple, it will be joined by sep, if sep is not null.\n * The result is a string, except when the field is multiple and sep is null.\n *\n */\nconst repr1Head = (tables, table, field, valType, value, settings) => {\n  if (value == null) {return emptyS}\n  if (valType == null || typeof valType === 'string') {\n    switch (valType) {\n      case 'datetime': return trimDate(value, table, field, settings)\n      case 'bool': return value ? 'Yes' : 'No'\n      default: return value\n    }\n  }\n  else {\n    const { relTable } = valType\n    return relTable == null\n    ? emptyS\n    : headEntity(tables, relTable, value)\n  }\n}\n\nconst reprHead = (tables, table, field, valType, multiple, value, settings, sep) => {\n  const rep = multiple\n  ? (value || emptyA).map(val => repr1Head(tables, table, field, valType, val, settings))\n  : repr1Head(tables, table, field, valType, value, settings)\n  return multiple && sep != null\n  ? rep.join(sep)\n  : rep\n}\n\n/*\n * The exported repr() function.\n *\n * It can deal with a detail field, with multiplicity in field and detail field, in any combination,\n * and it can do joining.\n * If sep is present, detail sep should also be present.\n * If not, we take a single space as default.\n */\nexport const repr = memoize(\n  (tables, table, field, valType, multiple, relField, value, settings, sep, relSep) => {\n    if (relField == null) {\n      return reprHead(tables, table, field, valType, multiple, value, settings, sep)\n    }\n\n    const { relTable } = valType\n    if (relTable == null) {return emptyS}\n    const {\n      [relTable]: {\n        fieldSpecs: { [relField]: { multiple: relMultiple, valType: relValType } },\n      },\n    } = tables\n    const relValues = multiple\n    ? value.map(val => tables[relTable].entities[val].values[relField])\n    : tables[relTable].entities[value].values[relField]\n\n    const theRelSep = multiple && relMultiple && sep != null && relSep == null\n    ? ' '\n    : relSep\n    const rep = multiple\n    ? relValues.map(relValue => reprHead(tables, relTable, relField, relValType, relMultiple, relValue, settings, theRelSep))\n    : reprHead(tables, relTable, relField, relValType, relMultiple, relValues, settings, relSep)\n\n    return multiple && sep != null\n    ? rep.join(sep)\n    : rep\n  },\n  emptyO,\n)\n\nexport const handleOpenAll = memoize((alter, alterSection, nAlts, initial, table, items, dispatch) => {\n  const makeAlternatives = compileAlternatives(alterSection, nAlts, initial, dispatch)\n  const theAlt = (initial + 1) % nAlts\n  return () => {\n    const alts = []\n    items.forEach(eId => {\n      const { getAlt } = makeAlternatives(eId)\n      const alt = getAlt(alter)\n      if (alt !== theAlt) {\n        alts.push(eId)\n      }\n    })\n    if (alts.length) {\n      dispatch(fetchItems(table, alts, alterSection, theAlt))\n    }\n  }\n}, emptyO)\n\nexport const handleCloseAll = memoize((alter, alterSection, nAlts, initial, items, dispatch) => {\n  const makeAlternatives = compileAlternatives(alterSection, nAlts, initial, dispatch)\n  const base = getUrlParts(browserHistory)[0]\n  return () => {\n    browserHistory.push(`${base}/`)\n    const alts = []\n    items.forEach(eId => {\n      const { getAlt } = makeAlternatives(eId)\n      const alt = getAlt(alter)\n      if (alt !== initial) {\n        alts.push(eId)\n      }\n    })\n    if (alts.length) {\n      dispatch(setItems(alts, alterSection, initial))\n    }\n  }\n}, emptyO)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/tables.js","import { makeReducer } from 'utils'\n\n/* ACTIONS */\n\nexport const changeWinDim = () => dispatch => {\n  dispatch({ type: 'windim', ...initWinDim() })\n}\n\n/* REDUCER */\n\nconst flows = {\n  windim(state, { height, width }) {return { height, width }},\n}\n\nconst initWinDim = () => {\n  const { innerHeight: height, innerWidth: width } = window\n  return { height, width }\n}\n\nexport default makeReducer(flows, initWinDim())\n\n/* SELECTORS */\n\nexport const getWinDim = ({ win }) => ({ win })\n\n/* HELPERS */\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/win.js","import { memoize } from 'memo'\nimport { emptyS, emptyA, emptyO, max, sum } from 'utils'\n\nimport { getDateTime, sortTimeInterval, sortStringTemplate } from 'fields'\n\n/* DEFINITIONS */\n\nexport const PACKAGE_TABLE = 'package'\nexport const CRITERIA_TABLE = 'criteria'\nexport const TYPE_TABLE = 'typeContribution'\nexport const TYPE_FIELD = 'typeContribution'\n\n/* CONFIGURATION */\n\nexport const loadExtra = {\n  contrib: [\n    ['package'],\n    ['criteria'],\n    ['typeContribution'],\n  ],\n}\n\n/* ACTIONS */\n\n/* REDUCER */\n\n/* SELECTORS */\n\n/* HELPERS */\n\nconst compileActiveItems = memoize((entitiesPkg, entitiesTyp, entitiesCri, field = null) => {\n  if ([entitiesPkg, entitiesTyp, entitiesCri].some(x => x == null)) {\n    return field ? null : emptyO\n  }\n  const resultSetPkg = new Set()\n  const resultSetTyp = new Set()\n  const resultSetCri = new Set()\n\n  const now = Date.now()\n  Object.entries(entitiesPkg).forEach(([_id, { values: { startDate, endDate, typeContribution } }]) => {\n    const startAsDateTime = getDateTime(startDate)\n    const endAsDateTime = getDateTime(endDate)\n    const noStartDate = startAsDateTime == null\n    const noEndDate = endAsDateTime == null\n    if (!noStartDate || !noEndDate) {\n      if ((noStartDate || startAsDateTime < now) && (noEndDate || now < endAsDateTime)) {\n        resultSetPkg.add(_id);\n        (typeContribution || emptyA).forEach(typ => resultSetTyp.add(typ))\n      }\n    }\n  })\n  Object.entries(entitiesCri).forEach(([_id, { values: { [PACKAGE_TABLE]: packageId } }]) => {\n    if (resultSetPkg.has(packageId)) {\n      resultSetCri.add(_id)\n    }\n  })\n  return field\n  ? field === TYPE_FIELD\n    ? resultSetTyp\n    : field === PACKAGE_TABLE\n      ? resultSetPkg\n      : field === CRITERIA_TABLE\n      ? resultSetCri\n        : null\n  : {\n    activeIdsPkg: Array.from(resultSetPkg)\n      .map(eId => entitiesPkg[eId].values)\n      .sort(sortTimeInterval('startDate', 'endDate'))\n      .map(e => e._id),\n    activeIdsTyp: Array.from(resultSetTyp)\n      .map(eId => entitiesTyp[eId].values)\n      .sort(sortStringTemplate(e => `${e.mainType || emptyS} / ${e.subType || emptyS}`))\n      .map(e => e._id),\n    activeIdsCri: Array.from(resultSetCri)\n      .map(eId => entitiesCri[eId].values)\n      .sort(sortStringTemplate(e => e.criterion))\n      .map(e => e._id),\n  }\n}, emptyO, { debug: 'compileActiveItems' })\n\nexport const compileActive = (tables, field) => {\n  if ([PACKAGE_TABLE, CRITERIA_TABLE, TYPE_TABLE].some(x => tables[x] == null)) {\n    return field ? null : emptyO\n  }\n  const {\n    [PACKAGE_TABLE]: { entities: entitiesPkg },\n    [CRITERIA_TABLE]: { entities: entitiesCri },\n    [TYPE_TABLE]: { entities: entitiesTyp },\n  } = tables\n  return compileActiveItems(entitiesPkg, entitiesTyp, entitiesCri, field)\n}\n\nexport const assessmentScore = memoize((tables, aId) => {\n  // get all loaded criteriaEntries and scores\n  const { criteriaEntry: { entities: ceEntities } = emptyO } = tables\n  const { score: { entities: sEntities } = emptyO } = tables\n\n  // get all criteria entries for this assessment and distill relevant information\n  const myCriteriaEntries = Object.keys(ceEntities)\n  .filter(ceId => ceEntities[ceId].values.assessment == aId)\n  .map(ceId => {\n    const {\n      [ceId]: {\n        values: {\n          criteria: thisCid,\n          score: thisSid,\n        },\n      },\n    } = ceEntities\n    const {\n      [thisSid]: {\n        values: {\n          score = 0,\n        } = emptyO,\n      } = emptyO,\n    } = sEntities\n    const maxScore = max(\n      Object.keys(sEntities)\n      .filter(sId => sEntities[sId].values.criteria == thisCid)\n      .map(sId => sEntities[sId].values.score)\n    )\n\n    return { criteria: thisCid, score, maxScore }\n  })\n\n  const allMax = sum(myCriteriaEntries.map(x => x.maxScore))\n  const allN = myCriteriaEntries.length\n\n  // correct for criteria entries that are \"non applicable\" ( < 0 )\n\n  const relevantCriteriaEntries = myCriteriaEntries\n  .filter(x => x.score >= 0)\n  const relevantMax = sum(relevantCriteriaEntries.map(x => x.maxScore))\n  const relevantScore = sum(relevantCriteriaEntries.map(x => x.score))\n  const relevantN = relevantCriteriaEntries.length\n  const overall = relevantMax == 0\n  ? 0\n  : Math.round(relevantScore * 100 / relevantMax)\n\n  return {\n    overall,\n    relevantScore,\n    relevantMax,\n    allMax,\n    relevantN,\n    allN,\n  }\n}, emptyO)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/dux/workflow.js","import React from 'react'\nimport { render } from 'react-dom'\nimport { Router, Route, Redirect, IndexRoute, IndexRedirect, browserHistory } from 'react-router'\n\nimport { ALLIDS, MYIDS } from 'tables'\n\nimport Root from 'Root'\nimport App from 'App'\nimport SubApp from 'SubApp'\nimport ListContainer from 'ListContainer'\nimport Doc from 'Doc'\nimport NotFound from 'NotFound'\nimport ErrorBoundary from 'ErrorBoundary'\n\nrender(\n  <Root>\n    <ErrorBoundary>\n      <Router history={browserHistory}>\n        <Redirect from={'/about'} to={'/docs/about.md'} />\n        <Redirect from={'/docs/about'} to={'/docs/about.md'} />\n        <Redirect from={'/about.md'} to={'/docs/about.md'} />\n        <Redirect from={'/login'} to={'/docs/about.md'} />\n        <Redirect from={'/logout'} to={'/docs/about.md'} />\n        <Redirect from={'/slogout'} to={'/docs/about.md'} />\n        <Route path={'/'} component={App} >\n          <IndexRoute component={App} />\n          <IndexRedirect to={'/docs/about.md'} />\n          <Route path={'docs/:docFile'} component={Doc} />\n          <Route path={'tech/docs/gen/:docFile'} component={Doc} />\n          <Route path={'tech/docs/:docFile'} component={Doc} />\n          <Route path={'data'} component={SubApp} >\n            <Route path={':table'} >\n              <Route path={'mylist(/item/:eId)'} component={ListContainer} select={MYIDS} mode={'list'} />\n              <Route path={'list(/item/:eId)'} component={ListContainer} select={ALLIDS} mode={'list'} />\n              <Route path={'grid(/item/:eId)'} component={ListContainer} select={ALLIDS} mode={'grid'} />\n              <Route path={'filter(/item/:eId)'} component={ListContainer} select={ALLIDS} mode={'list'} filtered={true} />\n            </Route>\n          </Route>\n        </Route>\n        <Route path={'*'} component={NotFound} />\n      </Router>\n    </ErrorBoundary>\n  </Root>\n  ,\n  document.getElementById('body')\n)\n\n\n\n\n// WEBPACK FOOTER //\n// src/js/app/main.jsx"],"mappings":";;;;;;AAAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACCA;;;;;;;;ACDA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACEA;;;;;;;;ACFA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;A","sourceRoot":""}