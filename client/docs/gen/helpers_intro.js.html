<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>helpers/intro.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Alternatives.html">Alternatives</a><ul class='methods'><li data-type='method'><a href="Alternatives.html#render">render</a></li></ul></li><li><a href="App.html">App</a></li><li><a href="ByValue.html">ByValue</a></li><li><a href="CheckboxI.html">CheckboxI</a></li><li><a href="Contrib.html">Contrib</a></li><li><a href="Contribs.html">Contribs</a></li><li><a href="ContribsFiltered.html">ContribsFiltered</a></li><li><a href="Doc.html">Doc</a></li><li><a href="DocHtml.html">DocHtml</a></li><li><a href="DocMd.html">DocMd</a></li><li><a href="DocPdf.html">DocPdf</a></li><li><a href="EUMap.html">EUMap</a></li><li><a href="Facet.html">Facet</a></li><li><a href="FilterCompute.html">FilterCompute</a></li><li><a href="Filters.html">Filters</a></li><li><a href="FullText.html">FullText</a></li><li><a href="Login.html">Login</a></li><li><a href="NavLink.html">NavLink</a></li><li><a href="NotFound.html">NotFound</a></li><li><a href="Notification.html">Notification</a><ul class='methods'><li data-type='method'><a href="Notification.html#computeProgress">computeProgress</a></li><li data-type='method'><a href="Notification.html#render">render</a></li><li data-type='method'><a href="Notification.html#setView">setView</a></li></ul></li><li><a href="Provider.html">Provider</a></li><li><a href="Stats.html">Stats</a></li><li><a href="Store.html">Store</a><ul class='methods'><li data-type='method'><a href="Store.html#get">get</a></li><li data-type='method'><a href="Store.html#load">load</a></li><li data-type='method'><a href="Store.html#save">save</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-data.html">data</a><ul class='methods'><li data-type='method'><a href="module-data.html#.getData">getData</a></li></ul></li><li><a href="module-europe_geo_js.html">europe_geo_js</a></li><li><a href="module-filters.html">filters</a><ul class='methods'><li data-type='method'><a href="module-filters.html#.compileFiltering">compileFiltering</a></li><li data-type='method'><a href="module-filters.html#.computeFiltering">computeFiltering</a></li><li data-type='method'><a href="module-filters.html#.newFilterSettings">newFilterSettings</a></li><li data-type='method'><a href="module-filters.html#.placeFacets">placeFacets</a></li><li data-type='method'><a href="module-filters.html#.testAllChecks">testAllChecks</a></li><li data-type='method'><a href="module-filters.html#~countFacets">countFacets</a></li><li data-type='method'><a href="module-filters.html#~facetCheck">facetCheck</a></li><li data-type='method'><a href="module-filters.html#~fullTextCheck">fullTextCheck</a></li></ul></li><li><a href="module-hoc.html">hoc</a><ul class='methods'><li data-type='method'><a href="module-hoc.html#.saveState">saveState</a></li><li data-type='method'><a href="module-hoc.html#.withContext">withContext</a></li></ul></li><li><a href="module-ui.html">ui</a><ul class='methods'><li data-type='method'><a href="module-ui.html#.columnStyle">columnStyle</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-Component.html">Component</a></li><li><a href="external-componentWillUnmount.html">componentWillUnmount</a></li><li><a href="external-constructor.html">constructor</a></li><li><a href="external-context.html">context</a></li><li><a href="external-LifeCycle.html">LifeCycle</a></li><li><a href="external-Map.html">Map</a></li><li><a href="external-Promise.html">Promise</a></li><li><a href="external-PropTypes.html">PropTypes</a></li><li><a href="external-Recompose.html">Recompose</a></li><li><a href="external-Redux.html">Redux</a></li><li><a href="external-render.html">render</a></li><li><a href="external-setState.html">setState</a></li><li><a href="external-StatePolicy.html">StatePolicy</a></li></ul><h3>Global</h3><ul><li><a href="global.html#globals">globals</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">helpers/intro.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file
 * Documentation references.
 *
 * This file does not contain javascript code.
 */

/**
 * ES6 datastructure to contain key-value pairs.
 * One could also use plain objects for this, but Maps are cleaner in a number of respects.
 *
 * @external Map
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map|Map}
 */

/**
 * @typedef Map
 * @type {external:Map}
 */

/**
 * ES6 datastructure to contain the result of an asynchronous function.
 * It has as state that is either *pending*, *failed* or *resolved*. 
 * Once the state is *failed* or *resolved*, it will not change anymore.
 * If the state is *resolved*, the return value is available, and will not change anymore.
 * The typical way to use a promise is
 *
 * ```
 *   const dataStore = {};
 *   const getData = url => fetch(url); 
 *   // assuming that fetch returns a Promise, we can then say
 *   getData('/api/blob/23').
 *   then(
 *     blob => {dataStore.url = blob},
 *     error => console.log(error),
 *   )
 * ```
 *
 * @external Promise
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise|Promise}
 */

/**
 * @typedef Promise
 * @type {external:Promise}
 */

/**
 * ## React Components
 *
 * React components represent pieces of the web page and their functionality.
 * Components are organized hierarchically.
 * Components can be parametrized by *properties*, which parents pass to children.
 * A component acts as a template instruction to build a piece of DOM.
 *
 * Components can be programmed as classes or as functions.
 * In both cases they can be given the
 * {@link external:PropTypes|types}. 
 * of their incoming properties as metadata.
 *
 * In this app we distinguish between three *capability levels* of components.
 *
 * ## Pure components
 * If a component knows how to build the DOM, purely on the basis of its properties and
 * a static template, it can be (and will be) coded as a pure function.
 *
 * We put all these components in a directory called **pure**.
 *
 * ## DOM-manipulating components
 * If a component has to handle the DOM after it has been constructed,
 * e.g. apply some hiding and showing, fill a div with a third party component, 
 * then we need to program the component as a class with so-called
 * {@link external:LifeCycle| life cycle methods}.
 *
 * We put all these components in a directory called **object**.
 *
 * ## Stateful components
 * If a component maintains a **state**, it is stateful.
 * We need to program this as a class, like in the previous case.
 * Stateful components may or may not manipulate the DOM.
 *
 * There are two main reasons for a component to maintain state:
 *
 * * getting external data
 * * reacting to user events
 *
 * In both cases, something happens in the outside world that must be remembered.
 * Components remember these things in their state, which only they can update.
 * They can compute derived data from their state and pass that as properties
 * to their children.
 * State updates trigger these computations automatically, and children
 * whose properties are dependent on this state, are rerendered automatically
 * (and economically). 
 *
 * We put all these components in a directory called **state**.
 *
 * @example &lt;caption>pure component&lt;/caption>
 * const Widget = ({shape, children}) => &lt;div className={shape}>{children}&lt;/div>
 *
 * @example &lt;caption>object component (DOM)&lt;/caption>
 * class Widget extends Component {
 *  render() {
 *    const {typed} = this.props;
 *    return (
 *      &lt;input ref="user" type="text" value={typed}/>
 *    )
 *  }
 *  componentDidUpdate() {
 *    this.refs.user.value = this.props.typed
 * }
 *
 * @example &lt;caption>stateful component&lt;/caption>
 * class Widget extends Component {
 *  constructor() {
 *    super();
 *    this.state = {data: []}
 *  }
 *  render() {
 *    return (
 *      &lt;div>
 *      {this.state.data.map((line, i) => &lt;p key={i}>{line}&lt;/p>)
 *      &lt;/div>
 *    )
 *  }
 *  componentDidMount() {
 *    const newData = getData();
 *    this.setState(data: newData);
 *  }
 * }
 *
 * @external Component
 * @see {@link https://facebook.github.io/react/docs/react-component.html|Component}
 */

/**
 * @typedef Component
 * @type {external:Component}
 */

/**
 * Type checking for React
 * {@link Component|components}
 * .
 *
 * @external PropTypes
 * @see {@link https://facebook.github.io/react/docs/typechecking-with-proptypes.html|PropTypes}
 */

/**
 * React mechanism to pass data directly  from ancestors to deep descendants.
 * The React documentation
 * considers context as a brittle part of itself, and warns
 * against over-use. At the same time,
 * {@link external:Redux|Redux}
 * depends critically on it, so I consider it safe to use.
 *
 * By wrapping the syntax of the React context mechanism into an enhancer, we
 * can survive API changes more easily.
 * See
 * {@link withContext}
 * .
 *
 * @external context
 * @see {@link https://facebook.github.io/react/docs/context.html|context}
 */

/**
 * The main function of a
 * {@link external:Component|component}
 * is to act as a template to be
 * {@link external:render|rendered}
 * .
 * But if there is additional work to be done, this can be hooked up at various
 * stages in the component's lifecycle.
 * Most stages occur during (re)rendering, and there is a stage of construction and unmounting.
 *
 * @external LifeCycle
 * @see {@link https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle|Lifecycle Methods}
 */

/**
 * When a
 * {@link external:Component|component}
 * is being
 * {@link https://facebook.github.io/react/docs/react-component.html#render|rendered}
 * this is the method to construct the corresponding React class.
 * It will set up the state.
 *
 * @external constructor
 * @see {@link https://facebook.github.io/react/docs/react-component.html#constructor|constructor()}
 */

/**
 * When a
 * {@link external:Component|component}
 * will be removed from the DOM, 
 * this method will be called just before.
 * If we want to save state, we can hook it up here.
 *
 * @external componentWillUnmount
 * @see {@link https://facebook.github.io/react/docs/react-component.html#componentwillunmount|componentWillUnmount()}
 */

/**
 * The main function of a
 * {@link external:Component|component}
 * is to act as a template to be rendered.
 * During rendering the template will be used as a set of instructions to build a real DOM
 * somewhere on the actual web page.
 *
 * @external render
 * @see {@link https://facebook.github.io/react/docs/react-component.html#render|render()}
 */

/**
 * ## Local State
 *
 * The vanilla React way is that
 * {@link external:Component|components}
 * have their own state, which only
 * they can modify through
 * {@link external:setState|setState()}
 * .
 *
 * But even in React, state is not completely local, because in many
 * cases several components need to have access to the state.
 * The preferred way of dealing with that is to lift state up to the nearest
 * common ancestor of all components that need the state.
 * Descendants that must modify ancestral state are passed a callback to do so.
 *
 * A widely used approach to *central* state is {@link external:Redux|Redux}
 * ,
 * our alternative is
 * {@link external:StatePolicy|local state plus backup}
 * .
 *
 * @external setState
 * @see {@link https://facebook.github.io/react/docs/react-component.html#setstate|setState()}
 */

/**
 * ## Central State
 *
 * This is a popular implementation of the idea that state is centralized
 * and all components have to subscribe to a state provider, the store.
 *
 * * If a component needs to update the state, it dispatches an action to the store.
 * * So-called *reducers* translate the action into a state update. 
 * * And then the component can re-render.
 *
 * Using Redux requires a lot of extra code in actions and reducers,
 * which get separated from the components for which it is used.
 *
 * The plain React alternative is
 * {@link external:setState|setState()}
 * ,
 * our alternative is
 * {@link external:StatePolicy|local state plus backup}
 * .
 *
 * @external Redux
 * @see {@link https://github.com/reactjs/react-redux|Redux}
 */

/**
 * ## Local with backup
 * This app manages state locally through
 * {@link external:setState|setState()}
 * but with the enhancement that components can save state in a global store.
 * 
 * So, we do not adopt the full
 * {@link external:Redux|Redux}
 * approach, but
 * we borrow just one idea from it: a central store of state.
 *
 * Our components will use that store not for normal state updates, but only
 * when they
 * {@link external:componentWillUnmount|unmount}
 * or
 * {@link external:constructor|mount}
 *
 * ## Why local state?
 * We want to keep the pieces of business logic close to the component that deals with them.
 * We want to avoid the extra book keeping of actions and labels that  
 * {@link external:Redux|Redux}
 * requires.
 *
 * ## Why back up state?
 * Not all components can be kept on the interface all the time.
 * But stateful components may harbour costly state: big data tables from a server,
 * or lots of user interaction events, e.g. the faceted filter settings.
 * When the user routes back to a component with state, we want to restore
 * the last state before the user left the component.
 *
 * @external StatePolicy
 */

/**
 * @typedef {Object} Source
 * @property {string} type - either
 * * `db` (mongo db access, results delivered as json)
 * * `json` (file contents delivered as json)  
 * @property {string} path - the remaining path to the controller function on the server
 * @property {string} branch - the subobject of the requesting component's state that will
 * receive the fetched data
 */

/**
 * @typedef {Object} Result
 * @property {string} data - the actual payload of the data transfer; this is what the component needs
 * to have to do its work
 * @property {Message[]} messages - messages issued at the server side when carrying out the request
 * @property {boolean} good - whether the server has successfully carried out the request
 */

/**
 * @typedef {Object} Message
 * @property {string} kind - one of the values `error`, `warning`, `good`, `special`, `info`
 * @property {string} text - the plain text of the message
 * @property {number} busy - an number that will be added by {@link getData}: +1 at the start of a request,
 * -1 when the waiting is over; the {@link Notification} object can use `busy` for displaying progress
 * indication. **NB:** The server does not supply the `busy` attribute, only {@link getData} does.
 */

</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Fri Nov 04 2016 08:46:49 GMT+0100 (CET) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
