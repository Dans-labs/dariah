<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"global.html":{"id":"global.html","title":"Global","body":" Documentation Classes AppStore Global globalssaveStatewithContext Global Members &lt;constant&gt; globals Application wide data Some things need to be practically global, or at least, application wide. We will not use the javascript window object to store globals. Instead we use the context mechanism of React to pass global information around within the app. StoreThe store is a container of component states. We use it for components with a costly state, that should be preserved when components are swapped in and out from the user interface. We pass a reference to the store as a parameter to all routes that invoke a component with state that should be preserved. We do not use central state. We only provide for components to store their state when they unmount, and to load it when they mount. A component can assign its state to the store using a self chosen key, preferably different for different instances. So the store consists of saved states keyed by component instances. The most important use cases for this app: if the big contrib list is loaded, the user must be able to go back and forth between docs like &quot;about&quot; and the contrib list without the need to reload the list all the time if a user has set up filters, the filter state should be preserved after navigating to other parts of the app Note that the DOM may be swapped out, but the state info needed to recreate the dom should be preserved. NotificationWe want one place on the interface for displaying notifications. &lt;constant&gt; globals Application wide data Some things need to be practically global, or at least, application wide. We will not use the javascript window object to store globals. Instead we use the context mechanism of React to pass global information around within the app. StoreThe store is a container of component states. We use it for components with a costly state, that should be preserved when components are swapped in and out from the user interface. We pass a reference to the store as a parameter to all routes that invoke a component with state that should be preserved. We do not use central state. We only provide for components to store their state when they unmount, and to load it when they mount. A component can assign its state to the store using a self chosen key, preferably different for different instances. So the store consists of saved states keyed by component instances. The most important use cases for this app: if the big contrib list is loaded, the user must be able to go back and forth between docs like &quot;about&quot; and the contrib list without the need to reload the list all the time if a user has set up filters, the filter state should be preserved after navigating to other parts of the app Note that the DOM may be swapped out, but the state info needed to recreate the dom should be preserved. NotificationWe want one place on the interface for displaying notifications. &lt;constant&gt; globals Application wide data Some things need to be practically global, or at least, application wide. We will not use the javascript window object to store globals. Instead we use the context mechanism of React to pass global information around within the app. StoreThe store is a container of component states. We use it for components with a costly state, that should be preserved when components are swapped in and out from the user interface. We pass a reference to the store as a parameter to all routes that invoke a component with state that should be preserved. We do not use central state. We only provide for components to store their state when they unmount, and to load it when they mount. A component can assign its state to the store using a self chosen key, preferably different for different instances. So the store consists of saved states keyed by component instances. The most important use cases for this app: if the big contrib list is loaded, the user must be able to go back and forth between docs like &quot;about&quot; and the contrib list without the need to reload the list all the time if a user has set up filters, the filter state should be preserved after navigating to other parts of the app Note that the DOM may be swapped out, but the state info needed to recreate the dom should be preserved. NotificationWe want one place on the interface for displaying notifications. Methods saveState(ComponentInner, key, object) Wraps a component to let it preserve its state across unmounts. Connnects ComponentInner with a global object called Store (provided by means of withContext). This one works by extending the ComponentInner class, and adding functionality to its constructor() and componentWillUnmount() methods. In order to use the Store object, a component needs to register itself with a key and an initial state value. The initialState can be passed as a concrete object, or as a function that computes the initialState on the basis of props. (See FilterCompute) Parameters: Name Type Description ComponentInner Component the incoming component (the wrappee) key string identifier to find the saved state back in the state store object initialState the state to start with Returns: ComponentOuter the enhanced component (the wrapper) Type Component saveState(ComponentInner, key, object) Wraps a component to let it preserve its state across unmounts. Connnects ComponentInner with a global object called Store (provided by means of withContext). This one works by extending the ComponentInner class, and adding functionality to its constructor() and componentWillUnmount() methods. In order to use the Store object, a component needs to register itself with a key and an initial state value. The initialState can be passed as a concrete object, or as a function that computes the initialState on the basis of props. (See FilterCompute) Parameters: Name Type Description ComponentInner Component the incoming component (the wrappee) key string identifier to find the saved state back in the state store object initialState the state to start with Returns: ComponentOuter the enhanced component (the wrapper) Type Component saveState(ComponentInner, key, object) Wraps a component to let it preserve its state across unmounts. Connnects ComponentInner with a global object called Store (provided by means of withContext). This one works by extending the ComponentInner class, and adding functionality to its constructor() and componentWillUnmount() methods. In order to use the Store object, a component needs to register itself with a key and an initial state value. The initialState can be passed as a concrete object, or as a function that computes the initialState on the basis of props. (See FilterCompute) Parameters: Name Type Description ComponentInner Component the incoming component (the wrappee) key string identifier to find the saved state back in the state store object initialState the state to start with Returns: ComponentOuter the enhanced component (the wrapper) Type Component withContext(ComponentInner) Wraps a component to provide it with context. Parameters: Name Type Description ComponentInner Component the incoming component (the wrappee) Returns: ComponentOuter the enhanced component (the wrapper) Supplies context to ComponentInner. ComponentOuter subscribes to context (a React mechanism to pass data directly from ancestors to deep descendants), and passes the content of context.globals to ComponentInner as props. These properties are then &quot;magically&quot; present in the methods of ComponentInner. By wrapping the syntax of the React context mechanism into this enhancer, we can survive API changes more easily. The React documentation considers context as a brittle part of itself, and warns against over-use. At the same time, react-redux, a very popular React extension, depends critically on it. So, our withContext enhancer is the only place in the code where context surfaces. Type Component withContext(ComponentInner) Wraps a component to provide it with context. Parameters: Name Type Description ComponentInner Component the incoming component (the wrappee) Returns: ComponentOuter the enhanced component (the wrapper) Supplies context to ComponentInner. ComponentOuter subscribes to context (a React mechanism to pass data directly from ancestors to deep descendants), and passes the content of context.globals to ComponentInner as props. These properties are then &quot;magically&quot; present in the methods of ComponentInner. By wrapping the syntax of the React context mechanism into this enhancer, we can survive API changes more easily. The React documentation considers context as a brittle part of itself, and warns against over-use. At the same time, react-redux, a very popular React extension, depends critically on it. So, our withContext enhancer is the only place in the code where context surfaces. Type Component withContext(ComponentInner) Wraps a component to provide it with context. Parameters: Name Type Description ComponentInner Component the incoming component (the wrappee) Returns: ComponentOuter the enhanced component (the wrapper) Supplies context to ComponentInner. ComponentOuter subscribes to context (a React mechanism to pass data directly from ancestors to deep descendants), and passes the content of context.globals to ComponentInner as props. These properties are then &quot;magically&quot; present in the methods of ComponentInner. By wrapping the syntax of the React context mechanism into this enhancer, we can survive API changes more easily. The React documentation considers context as a brittle part of itself, and warns against over-use. At the same time, react-redux, a very popular React extension, depends critically on it. So, our withContext enhancer is the only place in the code where context surfaces. Type Component × Search results Close Documentation generated by JSDoc 3.4.2 on November 3rd 2016, 7:31:32 am using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes AppStore Global globalssaveStatewithContext Classes Classes App App App Store Store Store × Search results Close Documentation generated by JSDoc 3.4.2 on November 3rd 2016, 7:31:33 am using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes AppStore Global globalssaveStatewithContext DARIAH InKind Assessment Tool The tool is in beta and currently live. General information: about (live), in this repo; Architecture: design (live), in this repo; Deployment: guide (live), in this repo. Index helpers/hoc.js Higher Order ComponentsReact embraces a functional paradigm, where you enhance existing functionality by composition rather than by class extension. Put otherwise, you write an enhancer as a decorator function, that takes a component function as input and returns that component wrapped in a function that can do extra things. Especially the react components that do not use life-cycle methods are very suitable to enhance. If a react component makes essential use of a life cycle method, it can still be useful to enhance it by class extension. But even that can be coded as function composition. Index helpers/hoc.js Higher Order ComponentsReact embraces a functional paradigm, where you enhance existing functionality by composition rather than by class extension. Put otherwise, you write an enhancer as a decorator function, that takes a component function as input and returns that component wrapped in a function that can do extra things. Especially the react components that do not use life-cycle methods are very suitable to enhance. If a react component makes essential use of a life cycle method, it can still be useful to enhance it by class extension. But even that can be coded as function composition. Index helpers/hoc.js Higher Order ComponentsReact embraces a functional paradigm, where you enhance existing functionality by composition rather than by class extension. Put otherwise, you write an enhancer as a decorator function, that takes a component function as input and returns that component wrapped in a function that can do extra things. Especially the react components that do not use life-cycle methods are very suitable to enhance. If a react component makes essential use of a life cycle method, it can still be useful to enhance it by class extension. But even that can be coded as function composition. Index helpers/store.js Local state versus ReduxThis app is organised in the vanilla react way, with components managing local state through setState(). An other approach (Redux) is to have a centralized store that contains all the state: If a component needs to update the state, it dispatches an action to the store. So-called reducers translate the action into a state update. And then the component can re-render. Using Redux requires a lot of extra code in actions and reducers, which get separated from the components for which it is used. But local state has a pitfall: when a component is swapped out from the interface (because of routing), its state is lost. So if you have applied a lot of filter settings, or have fetched a big table of data, and you switch to /docs/about and back, a lot of ui-work and fetch-work must be done again, by you and the client and the server. So, a global state outside the components is an attractive asset indeed! The compromise we make is: components can load and save state from/to a store when they mount/unmount That keeps the business logic closer to the component and we can keep the state when components are temporarily wiped from the interface. Index helpers/store.js Local state versus ReduxThis app is organised in the vanilla react way, with components managing local state through setState(). An other approach (Redux) is to have a centralized store that contains all the state: If a component needs to update the state, it dispatches an action to the store. So-called reducers translate the action into a state update. And then the component can re-render. Using Redux requires a lot of extra code in actions and reducers, which get separated from the components for which it is used. But local state has a pitfall: when a component is swapped out from the interface (because of routing), its state is lost. So if you have applied a lot of filter settings, or have fetched a big table of data, and you switch to /docs/about and back, a lot of ui-work and fetch-work must be done again, by you and the client and the server. So, a global state outside the components is an attractive asset indeed! The compromise we make is: components can load and save state from/to a store when they mount/unmount That keeps the business logic closer to the component and we can keep the state when components are temporarily wiped from the interface. Index helpers/store.js Local state versus ReduxThis app is organised in the vanilla react way, with components managing local state through setState(). An other approach (Redux) is to have a centralized store that contains all the state: If a component needs to update the state, it dispatches an action to the store. So-called reducers translate the action into a state update. And then the component can re-render. Using Redux requires a lot of extra code in actions and reducers, which get separated from the components for which it is used. But local state has a pitfall: when a component is swapped out from the interface (because of routing), its state is lost. So if you have applied a lot of filter settings, or have fetched a big table of data, and you switch to /docs/about and back, a lot of ui-work and fetch-work must be done again, by you and the client and the server. So, a global state outside the components is an attractive asset indeed! The compromise we make is: components can load and save state from/to a store when they mount/unmount That keeps the business logic closer to the component and we can keep the state when components are temporarily wiped from the interface. × Search results Close Documentation generated by JSDoc 3.4.2 on November 3rd 2016, 7:31:33 am using the DocStrap template. "},"App.html":{"id":"App.html","title":"Class: App","body":" Documentation Classes AppStore Global globalssaveStatewithContext Class: App App new App() Class: App App new App() Class: App App new App() × Search results Close Documentation generated by JSDoc 3.4.2 on November 3rd 2016, 7:31:33 am using the DocStrap template. "},"Store.html":{"id":"Store.html","title":"Class: Store","body":" Documentation Classes AppStore Global globalssaveStatewithContext Class: Store Store The Store is a helper class for components that want to save state when they unmount, and load saved state when they mount. It is basically a key-value store, where there components store there state data under a specific key. NB: Do not use the Store directly. Provide it to your App on context by means of the withContext enhancer, and enable its functionality by means of the saveState enhancer in. new Store() Methods get(key) get(key) Parameters: Name Type Description key string Key for the store Other parts of the program retrieve states from under a given key. They can also modify the members inside that state. Typically, get() is called to perform state updates for components that are not currently mounted. As an example, you could use this to emit notifications before the Notification pseudo-element is mounted. get(key) get(key) Parameters: Name Type Description key string Key for the store Other parts of the program retrieve states from under a given key. They can also modify the members inside that state. Typically, get() is called to perform state updates for components that are not currently mounted. As an example, you could use this to emit notifications before the Notification pseudo-element is mounted. get(key) get(key) Parameters: Name Type Description key string Key for the store Other parts of the program retrieve states from under a given key. They can also modify the members inside that state. Typically, get() is called to perform state updates for components that are not currently mounted. As an example, you could use this to emit notifications before the Notification pseudo-element is mounted. register(component, key, initialState) register a component to the store Parameters: Name Type Description component Component The component that wants to be registered key string Identifier under which the saved state for this component will reside in the store initialState object The initial state to use for a component A Component needs to register itself with a key and an initial state. The Store is a map, and stores states under keys. The key can be just any string. If your Component has multiple instances that need a separate key, make sure that the instances use different keys. After registering it will be initialized with a state that has been saved under that key. If there is no previously save state, it will be initialized with initialState. This is either a concrete object, or a function that computes an object from props that are passed to it. Typically, register() is called in the constructor method of Component. register(component, key, initialState) register a component to the store Parameters: Name Type Description component Component The component that wants to be registered key string Identifier under which the saved state for this component will reside in the store initialState object The initial state to use for a component A Component needs to register itself with a key and an initial state. The Store is a map, and stores states under keys. The key can be just any string. If your Component has multiple instances that need a separate key, make sure that the instances use different keys. After registering it will be initialized with a state that has been saved under that key. If there is no previously save state, it will be initialized with initialState. This is either a concrete object, or a function that computes an object from props that are passed to it. Typically, register() is called in the constructor method of Component. register(component, key, initialState) register a component to the store Parameters: Name Type Description component Component The component that wants to be registered key string Identifier under which the saved state for this component will reside in the store initialState object The initial state to use for a component A Component needs to register itself with a key and an initial state. The Store is a map, and stores states under keys. The key can be just any string. If your Component has multiple instances that need a separate key, make sure that the instances use different keys. After registering it will be initialized with a state that has been saved under that key. If there is no previously save state, it will be initialized with initialState. This is either a concrete object, or a function that computes an object from props that are passed to it. Typically, register() is called in the constructor method of Component. save(key) save(key) Parameters: Name Type Description key string Key for the store A Component saves its state in the Store under key. Typically, save() is called in the componentWillUnmount() method of Component. save(key) save(key) Parameters: Name Type Description key string Key for the store A Component saves its state in the Store under key. Typically, save() is called in the componentWillUnmount() method of Component. save(key) save(key) Parameters: Name Type Description key string Key for the store A Component saves its state in the Store under key. Typically, save() is called in the componentWillUnmount() method of Component. Class: Store Store The Store is a helper class for components that want to save state when they unmount, and load saved state when they mount. It is basically a key-value store, where there components store there state data under a specific key. NB: Do not use the Store directly. Provide it to your App on context by means of the withContext enhancer, and enable its functionality by means of the saveState enhancer in. new Store() Methods get(key) get(key) Parameters: Name Type Description key string Key for the store Other parts of the program retrieve states from under a given key. They can also modify the members inside that state. Typically, get() is called to perform state updates for components that are not currently mounted. As an example, you could use this to emit notifications before the Notification pseudo-element is mounted. get(key) get(key) Parameters: Name Type Description key string Key for the store Other parts of the program retrieve states from under a given key. They can also modify the members inside that state. Typically, get() is called to perform state updates for components that are not currently mounted. As an example, you could use this to emit notifications before the Notification pseudo-element is mounted. get(key) get(key) Parameters: Name Type Description key string Key for the store Other parts of the program retrieve states from under a given key. They can also modify the members inside that state. Typically, get() is called to perform state updates for components that are not currently mounted. As an example, you could use this to emit notifications before the Notification pseudo-element is mounted. register(component, key, initialState) register a component to the store Parameters: Name Type Description component Component The component that wants to be registered key string Identifier under which the saved state for this component will reside in the store initialState object The initial state to use for a component A Component needs to register itself with a key and an initial state. The Store is a map, and stores states under keys. The key can be just any string. If your Component has multiple instances that need a separate key, make sure that the instances use different keys. After registering it will be initialized with a state that has been saved under that key. If there is no previously save state, it will be initialized with initialState. This is either a concrete object, or a function that computes an object from props that are passed to it. Typically, register() is called in the constructor method of Component. register(component, key, initialState) register a component to the store Parameters: Name Type Description component Component The component that wants to be registered key string Identifier under which the saved state for this component will reside in the store initialState object The initial state to use for a component A Component needs to register itself with a key and an initial state. The Store is a map, and stores states under keys. The key can be just any string. If your Component has multiple instances that need a separate key, make sure that the instances use different keys. After registering it will be initialized with a state that has been saved under that key. If there is no previously save state, it will be initialized with initialState. This is either a concrete object, or a function that computes an object from props that are passed to it. Typically, register() is called in the constructor method of Component. register(component, key, initialState) register a component to the store Parameters: Name Type Description component Component The component that wants to be registered key string Identifier under which the saved state for this component will reside in the store initialState object The initial state to use for a component A Component needs to register itself with a key and an initial state. The Store is a map, and stores states under keys. The key can be just any string. If your Component has multiple instances that need a separate key, make sure that the instances use different keys. After registering it will be initialized with a state that has been saved under that key. If there is no previously save state, it will be initialized with initialState. This is either a concrete object, or a function that computes an object from props that are passed to it. Typically, register() is called in the constructor method of Component. save(key) save(key) Parameters: Name Type Description key string Key for the store A Component saves its state in the Store under key. Typically, save() is called in the componentWillUnmount() method of Component. save(key) save(key) Parameters: Name Type Description key string Key for the store A Component saves its state in the Store under key. Typically, save() is called in the componentWillUnmount() method of Component. save(key) save(key) Parameters: Name Type Description key string Key for the store A Component saves its state in the Store under key. Typically, save() is called in the componentWillUnmount() method of Component. Class: Store Store The Store is a helper class for components that want to save state when they unmount, and load saved state when they mount. It is basically a key-value store, where there components store there state data under a specific key. NB: Do not use the Store directly. Provide it to your App on context by means of the withContext enhancer, and enable its functionality by means of the saveState enhancer in. new Store() Methods get(key) get(key) Parameters: Name Type Description key string Key for the store Other parts of the program retrieve states from under a given key. They can also modify the members inside that state. Typically, get() is called to perform state updates for components that are not currently mounted. As an example, you could use this to emit notifications before the Notification pseudo-element is mounted. get(key) get(key) Parameters: Name Type Description key string Key for the store Other parts of the program retrieve states from under a given key. They can also modify the members inside that state. Typically, get() is called to perform state updates for components that are not currently mounted. As an example, you could use this to emit notifications before the Notification pseudo-element is mounted. get(key) get(key) Parameters: Name Type Description key string Key for the store Other parts of the program retrieve states from under a given key. They can also modify the members inside that state. Typically, get() is called to perform state updates for components that are not currently mounted. As an example, you could use this to emit notifications before the Notification pseudo-element is mounted. register(component, key, initialState) register a component to the store Parameters: Name Type Description component Component The component that wants to be registered key string Identifier under which the saved state for this component will reside in the store initialState object The initial state to use for a component A Component needs to register itself with a key and an initial state. The Store is a map, and stores states under keys. The key can be just any string. If your Component has multiple instances that need a separate key, make sure that the instances use different keys. After registering it will be initialized with a state that has been saved under that key. If there is no previously save state, it will be initialized with initialState. This is either a concrete object, or a function that computes an object from props that are passed to it. Typically, register() is called in the constructor method of Component. register(component, key, initialState) register a component to the store Parameters: Name Type Description component Component The component that wants to be registered key string Identifier under which the saved state for this component will reside in the store initialState object The initial state to use for a component A Component needs to register itself with a key and an initial state. The Store is a map, and stores states under keys. The key can be just any string. If your Component has multiple instances that need a separate key, make sure that the instances use different keys. After registering it will be initialized with a state that has been saved under that key. If there is no previously save state, it will be initialized with initialState. This is either a concrete object, or a function that computes an object from props that are passed to it. Typically, register() is called in the constructor method of Component. register(component, key, initialState) register a component to the store Parameters: Name Type Description component Component The component that wants to be registered key string Identifier under which the saved state for this component will reside in the store initialState object The initial state to use for a component A Component needs to register itself with a key and an initial state. The Store is a map, and stores states under keys. The key can be just any string. If your Component has multiple instances that need a separate key, make sure that the instances use different keys. After registering it will be initialized with a state that has been saved under that key. If there is no previously save state, it will be initialized with initialState. This is either a concrete object, or a function that computes an object from props that are passed to it. Typically, register() is called in the constructor method of Component. save(key) save(key) Parameters: Name Type Description key string Key for the store A Component saves its state in the Store under key. Typically, save() is called in the componentWillUnmount() method of Component. save(key) save(key) Parameters: Name Type Description key string Key for the store A Component saves its state in the Store under key. Typically, save() is called in the componentWillUnmount() method of Component. save(key) save(key) Parameters: Name Type Description key string Key for the store A Component saves its state in the Store under key. Typically, save() is called in the componentWillUnmount() method of Component. × Search results Close Documentation generated by JSDoc 3.4.2 on November 3rd 2016, 7:31:33 am using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
