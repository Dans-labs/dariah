<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>helpers/react.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Alternatives.html">Alternatives</a></li><li><a href="App.html">App</a></li><li><a href="ContribsFiltered.html">ContribsFiltered</a></li><li><a href="Notification.html">Notification</a></li><li><a href="Store.html">Store</a><ul class='methods'><li data-type='method'><a href="Store.html#get">get</a></li><li data-type='method'><a href="Store.html#load">load</a></li><li data-type='method'><a href="Store.html#save">save</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-hoc.html">hoc</a><ul class='methods'><li data-type='method'><a href="module-hoc.html#.saveState">saveState</a></li><li data-type='method'><a href="module-hoc.html#.withContext">withContext</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-Component.html">Component</a></li><li><a href="external-componentWillUnmount.html">componentWillUnmount</a></li><li><a href="external-constructor.html">constructor</a></li><li><a href="external-context.html">context</a></li><li><a href="external-LifeCycle.html">LifeCycle</a></li><li><a href="external-Map.html">Map</a></li><li><a href="external-PropTypes.html">PropTypes</a></li><li><a href="external-Recompose.html">Recompose</a></li><li><a href="external-Redux.html">Redux</a></li><li><a href="external-render.html">render</a></li><li><a href="external-setState.html">setState</a></li></ul><h3>Global</h3><ul><li><a href="global.html#globals">globals</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">helpers/react.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file
 * Documentation references.
 *
 * This file does not contain javascript code.
 */

/**
 * # React Components
 *
 * React components represent pieces of the web page and their functionality.
 * Components are organized hierarchically.
 * Components can be parametrized by *properties*, which parents pass to children.
 * A component acts as a template instruction to build a piece of DOM.
 *
 * Components can be programmed as classes or as functions.
 * In both cases they can be given the
 * {@link external:PropTypes|types}. 
 * of their incoming properties as metadata.
 *
 * In this app we distinguish between three *capability levels* of components.
 *
 * ## Pure components
 * If a component knows how to build the DOM, purely on the basis of its properties and
 * a static template, it can be (and will be) coded as a pure function.
 *
 * We put all these components in a directory called **pure**.
 *
 * ## DOM-manipulating components
 * If a component has to handle the DOM after it has been constructed,
 * e.g. apply some hiding and showing, fill a div with a third party component, 
 * then we need to program the component as a class with so-called
 * {@link external:LifeCycle| life cycle methods}.
 *
 * We put all these components in a directory called **object**.
 *
 * ## Stateful components
 * If a component maintains a **state**, it is stateful.
 * We need to program this as a class, like in the previous case.
 * Stateful components may or may not manipulate the DOM.
 *
 * There are two main reasons for a component to maintain state:
 *
 * * getting external data
 * * reacting to user events
 *
 * In both cases, something happens in the outside world that must be remembered.
 * Components remember these things in their state, which only they can update.
 * They can compute derived data from their state and pass that as properties
 * to their children.
 * State updates trigger these computations automatically, and children
 * whose properties are dependent on this state, are rerendered automatically
 * (and economically). 
 *
 * We put all these components in a directory called **state**.
 *
 * @example &lt;caption>pure component&lt;/caption>
 * const Widget = ({shape, children}) => &lt;div className={shape}>{children}&lt;/div>
 *
 * @example &lt;caption>object component (DOM)&lt;/caption>
 * class Widget extends Component {
 *  render() {
 *    const {typed} = this.props;
 *    return (
 *      &lt;input ref="user" type="text" value={typed}/>
 *    )
 *  }
 *  componentDidUpdate() {
 *    this.refs.user.value = this.props.typed
 * }
 *
 * @example &lt;caption>stateful component&lt;/caption>
 * class Widget extends Component {
 *  constructor() {
 *    super();
 *    this.state = {data: []}
 *  }
 *  render() {
 *    return (
 *      &lt;div>
 *      {this.state.data.map((line, i) => &lt;p key={i}>{line}&lt;/p>)
 *      &lt;/div>
 *    )
 *  }
 *  componentDidMount() {
 *    const newData = getData();
 *    this.setState(data: newData);
 *  }
 * }
 *
 * @external Component
 * @see {@link https://facebook.github.io/react/docs/react-component.html|Component}
 */

/**
 * @typedef Component
 * @type {external:Component}
 */

/**
 * Type checking for React
 * {@link Component|components}
 * .
 *
 * @external PropTypes
 * @see {@link https://facebook.github.io/react/docs/typechecking-with-proptypes.html|PropTypes}
 */

/**
 * The main function of a
 * {@link external:Component|component}
 * is to act as a template to be
 * {@link external:render|rendered}
 * .
 * But if there is additional work to be done, this can be hooked up at various
 * stages in the component's lifecycle.
 * Most stages occur during (re)rendering, and there is a stage of construction and unmounting.
 *
 * @external LifeCycle
 * @see {@link https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle|Lifecycle Methods}
 */

/**
 * When a
 * {@link external:Component|component}
 * is being
 * @see {@link https://facebook.github.io/react/docs/react-component.html#render|rendered}
 * this is the method to construct the corresponding React class.
 * It will set up the state.
 *
 * @external constructor
 * @see {@link https://facebook.github.io/react/docs/react-component.html#constructor|constructor()}
 */

/**
 * When a
 * {@link external:Component|component}
 * will be removed from the DOM, 
 * this method will be called just before.
 * If we want to save state, we can hook it up here.
 *
 * @external componentWillUnmount
 * @see {@link https://facebook.github.io/react/docs/react-component.html#componentwillunmount|componentWillUnmount()}
 */

/**
 * The main function of a
 * {@link external:Component|component}
 * is to act as a template to be rendered.
 * During rendering the template will be used as a set of instructions to build a real DOM
 * somewhere on the actual web page.
 *
 * @external render
 * @see {@link https://facebook.github.io/react/docs/react-component.html#render|render()}
 */

/**
 * ## Local State
 *
 * The vanilla React way is that
 * {@link external:Component|components}
 * have their own state, which only
 * they can modify through
 * {@link external:setState|setState()}
 * .
 *
 * But even in React, state is not completely local, because in many
 * cases several components need to have access to the state.
 * The preferred way of dealing with that is to lift state up to the nearest
 * common ancestor of all components that need the state.
 * Descendants that must modify ancestral state are passed a callback to do so.
 *
 * A widely used approach to *central* state is {@link external:Redux|Redux}.
 *
 * @external setState
 * @see {@link https://facebook.github.io/react/docs/react-component.html#setstate|setState()}
 */

/**
 * ## Central State
 *
 * This is a popular implementation of the idea that state is centralized
 * and all components have to subscribe to a state provider, the store.
 *
 * * If a component needs to update the state, it dispatches an action to the store.
 * * So-called *reducers* translate the action into a state update. 
 * * And then the component can re-render.
 *
 * Using Redux requires a lot of extra code in actions and reducers,
 * which get separated from the components for which it is used.
 *
 * The plain React alternative is
 * {@link external:setState|setState()}
 * .
 *
 * @external Redux
 * @see {@link https://github.com/reactjs/react-redux|Redux}
 */

/**
 * ES6 datastructure to contain key-value pairs.
 * One could also use plain objects for this, but Maps are cleaner in a number of respects.
 *
 * @external Map
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map|Map}
 */

</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Thu Nov 03 2016 12:54:53 GMT+0100 (CET) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
