<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app/state/ItemField.jsx - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Alternative.html">Alternative</a><ul class='methods'><li data-type='method'><a href="Alternative.html#next">next</a></li><li data-type='method'><a href="Alternative.html#render">render</a></li></ul></li><li><a href="App.html">App</a></li><li><a href="Backoffice.html">Backoffice</a></li><li><a href="ByValue.html">ByValue</a></li><li><a href="CheckboxI.html">CheckboxI</a><ul class='methods'><li data-type='method'><a href="CheckboxI.html#onCheck">onCheck</a></li></ul></li><li><a href="DocHtml.html">DocHtml</a></li><li><a href="DocPdf.html">DocPdf</a></li><li><a href="Facet.html">Facet</a></li><li><a href="FilterCompute.html">FilterCompute</a><ul class='methods'><li data-type='method'><a href="FilterCompute.html#render">render</a></li></ul></li><li><a href="FullText.html">FullText</a></li><li><a href="ItemField.html">ItemField</a><ul class='methods'><li data-type='method'><a href="ItemField.html#fetchValues">fetchValues</a></li><li data-type='method'><a href="ItemField.html#setValToState">setValToState</a></li></ul></li><li><a href="ItemFiltered.html">ItemFiltered</a><ul class='methods'><li data-type='method'><a href="ItemFiltered.html#componentDidMount">componentDidMount</a></li><li data-type='method'><a href="ItemFiltered.html#render">render</a></li></ul></li><li><a href="ItemHead.html">ItemHead</a></li><li><a href="ItemList.html">ItemList</a></li><li><a href="ItemMy.html">ItemMy</a><ul class='methods'><li data-type='method'><a href="ItemMy.html#componentDidMount">componentDidMount</a></li><li data-type='method'><a href="ItemMy.html#inserted">inserted</a></li></ul></li><li><a href="ItemRecord.html">ItemRecord</a><ul class='methods'><li data-type='method'><a href="ItemRecord.html#fetchRow">fetchRow</a></li><li data-type='method'><a href="ItemRecord.html#updMod">updMod</a></li></ul></li><li><a href="LocalSettings.html">LocalSettings</a></li><li><a href="Login.html">Login</a><ul class='methods'><li data-type='method'><a href="Login.html#componentDidMount">componentDidMount</a></li></ul></li><li><a href="module-DocMd-DocMd.html">DocMd</a><ul class='methods'><li data-type='method'><a href="module-DocMd-DocMd.html#fetchText">fetchText</a></li><li data-type='method'><a href="module-DocMd-DocMd.html#render">render</a></li></ul></li><li><a href="module-Doc-Doc.html">Doc</a></li><li><a href="module-EUMap-EUMap.html">EUMap</a><ul class='methods'><li data-type='method'><a href="module-EUMap-EUMap.html#componentDidMount">componentDidMount</a></li><li data-type='method'><a href="module-EUMap-EUMap.html#componentDidUpdate">componentDidUpdate</a></li><li data-type='method'><a href="module-EUMap-EUMap.html#render">render</a></li></ul></li><li><a href="module-Filter-Filter.html">Filter</a></li><li><a href="module-ItemRecordPre-ItemRecordPre.html">ItemRecordPre</a></li><li><a href="NavLink.html">NavLink</a></li><li><a href="NotFound.html">NotFound</a></li><li><a href="Notification.html">Notification</a><ul class='methods'><li data-type='method'><a href="Notification.html#computeProgress">computeProgress</a></li><li data-type='method'><a href="Notification.html#refDom">refDom</a></li><li data-type='method'><a href="Notification.html#setView">setView</a></li></ul></li><li><a href="Provider.html">Provider</a><ul class='methods'><li data-type='method'><a href="Provider.html#getChildContext">getChildContext</a></li></ul></li><li><a href="Stat.html">Stat</a></li><li><a href="Static.html">Static</a></li><li><a href="Store.html">Store</a><ul class='methods'><li data-type='method'><a href="Store.html#get">get</a></li><li data-type='method'><a href="Store.html#load">load</a></li><li data-type='method'><a href="Store.html#save">save</a></li></ul></li><li><a href="SubApp.html">SubApp</a></li><li><a href="ValueList.html">ValueList</a><ul class='methods'><li data-type='method'><a href="ValueList.html#componentDidMount">componentDidMount</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-data.html">data</a><ul class='methods'><li data-type='method'><a href="module-data.html#.getData">getData</a></li></ul></li><li><a href="module-Doc.html">Doc</a></li><li><a href="module-DocMd.html">DocMd</a><ul class='methods'><li data-type='method'><a href="module-DocMd.html#~RouterLink">RouterLink</a></li></ul></li><li><a href="module-ES6.html">ES6</a></li><li><a href="module-EUMap.html">EUMap</a><ul class='methods'><li data-type='method'><a href="module-EUMap.html#~computeRadius">computeRadius</a></li></ul></li><li><a href="module-europe_geo_js.html">europe_geo_js</a></li><li><a href="module-Filter.html">Filter</a></li><li><a href="module-filtering.html">filtering</a><ul class='methods'><li data-type='method'><a href="module-filtering.html#.computeFiltering">computeFiltering</a></li><li data-type='method'><a href="module-filtering.html#.newFilterSettings">newFilterSettings</a></li><li data-type='method'><a href="module-filtering.html#.placeFacets">placeFacets</a></li><li data-type='method'><a href="module-filtering.html#.testAllChecks">testAllChecks</a></li><li data-type='method'><a href="module-filtering.html#~countFacets">countFacets</a></li><li data-type='method'><a href="module-filtering.html#~facetCheck">facetCheck</a></li><li data-type='method'><a href="module-filtering.html#~fullTextCheck">fullTextCheck</a></li><li data-type='method'><a href="module-filtering.html#~initf">initf</a></li></ul></li><li><a href="module-hoc.html">hoc</a><ul class='methods'><li data-type='method'><a href="module-hoc.html#.withContext">withContext</a></li><li data-type='method'><a href="module-hoc.html#~getTag">getTag</a></li></ul></li><li><a href="module-ItemRecordPre.html">ItemRecordPre</a></li><li><a href="module-main.html">main</a></li><li><a href="module-React.html">React</a></li><li><a href="module-ui.html">ui</a><ul class='methods'><li data-type='method'><a href="module-ui.html#.columnStyle">columnStyle</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-Component.html">Component</a></li><li><a href="external-componentDidMount.html">componentDidMount</a></li><li><a href="external-componentDidUpdate.html">componentDidUpdate</a></li><li><a href="external-componentWillMount.html">componentWillMount</a></li><li><a href="external-componentWillReceiveProps.html">componentWillReceiveProps</a></li><li><a href="external-componentWillUnmount.html">componentWillUnmount</a></li><li><a href="external-constructor.html">constructor</a></li><li><a href="external-context.html">context</a></li><li><a href="external-ControlledComponent.html">ControlledComponent</a></li><li><a href="external-DOM.html">DOM</a></li><li><a href="external-Fragment.html">Fragment</a></li><li><a href="external-LifeCycle.html">LifeCycle</a></li><li><a href="external-Map.html">Map</a></li><li><a href="external-Promise.html">Promise</a></li><li><a href="external-PropTypes.html">PropTypes</a></li><li><a href="external-Recompose.html">Recompose</a></li><li><a href="external-Reconciliation.html">Reconciliation</a></li><li><a href="external-Redux.html">Redux</a></li><li><a href="external-render.html">render</a></li><li><a href="external-Routing.html">Routing</a></li><li><a href="external-setState.html">setState</a></li><li><a href="external-state.html">state</a></li><li><a href="external-StatePolicy.html">StatePolicy</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">app/state/ItemField.jsx</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { Component } from 'react'
import Markdown from 'react-markdown'

import RelSelect from 'RelSelect.jsx'
import Alternative from 'Alternative.jsx'

import { getData } from 'data.js'
import { withContext, saveState } from 'hoc.js'

const sizes = {
  url: 50,
  email: 30,
  range: 6,
  datetime: 25,
  text: 50,
  _max: 50,
}

const trimDate = text => ({ full: text, text: (text == null) ? '' : (text.replace(/\.[0-9]+/, ''))})

const condense = text => ({ full: text, text: (text == null) ? '' : ((text.length > 20)?`${text.slice(0,8)}...${text.slice(-8)}`:text)})

const readonlyMakeFragment = obj => ({
  url: obj.urlFragment.bind(obj),
  email: obj.emailFragment.bind(obj),
  textarea: obj.textareaFragment.bind(obj),
  _default: obj.defaultFragment.bind(obj),
})

const editMakeFragment = obj => ({
  rel: obj.relEditFragment.bind(obj),
  textarea: obj.textareaEditFragment.bind(obj),
  _default: obj.defaultEditFragment.bind(obj),
})

const normalizeValues = ({initValues, relValuesMap, table, name }) => {
  const savedValues = (initValues == null) ? [] : initValues;
  const curValues = [...savedValues];
  const relValues = relValuesMap.has(table)?(relValuesMap.get(table).has(name)?relValuesMap.get(table).get(name):null):null;
  return { curValues, savedValues, reasons: {}, saving: {}, changed: false, valid: true, relValues }
}

const userAsString = (valRaw, userMap) => {
  const valId = valRaw._id;
  let valRep;
  let valShort;
  if (!userMap.has(valId)) {
    valRep = 'UNKNOWN';
    valShort = '??';
  }
  else {
    const userData = userMap.get(valId);
    const fname = userData.firstName || '';
    const lname = userData.lastName || '';
    const email = userData.email || '';
    const eppn = userData.eppn || '';
    const authority = userData.authority || '';
    const mayLogin = userData.mayLogin?'yes':'no';
    let linkText = [fname, lname].filter(x => x).join(' '); 
    if (linkText == '') {linkText = email}
    const namePart = (linkText &amp;&amp; email)? (
      `[${linkText}](mailto:${email})`
    ) : (
      linkText+email
    );
    const eppnPart = eppn?` eppn=${eppn} `:'';
    const authorityPart = authority?` authenticated by=${authority} `:'';
    const mayLoginPart = mayLogin?` active=${mayLogin} `:'';
    valRep = [namePart, eppnPart, authorityPart, mayLoginPart].filter(x => x).join('; ');
    valShort = [fname, lname, eppn].filter(x => x).slice(0, 2).join(' ');
  }
  return {text: valShort , full: valRep}
}

const countryAsString = (valRaw, countryMap) => {
  const valId = valRaw._id;
  let valRep;
  let valShort;
  if (!countryMap.has(valId)) {
    valRep = 'UNKNOWN';
    valShort = '??';
  }
  else {
    const countryData = countryMap.get(valId);
    valShort = countryData.name;
    valRep = `${countryData.iso}: ${countryData.name}`;
  }
  return {text: valShort, full:valRep}
}

const validate = (val, valType, validation) => {
  let vstatus = true;
  let reason = '';
  if (validation.nonEmpty &amp;&amp; (val == null || val == '')) {
    reason = `field may not be empty`;
    vstatus =  false;
  }
  if (validation.min != null || validation.max != null) {
    if (isNaN(val)) {
      reason = `value must be a number`;
      vstatus = false;
    }
    else {
      const valn = parseInt(val);
      if (!(validation.min &lt;= valn)){
        reason = `value must be at least ${validation.min}`;
        vstatus = false;
      }
        if (!(validation.max >= val)) {
        reason = `value must be at most ${validation.max}`;
        vstatus = false;
      }
    }
  }
  if (valType == 'datetime') {
    let times;
    try {
      times = Date.parse(val);
    }
    catch (error) {
      reason = `not a valid date/time - ${error}`;
      vstatus = false;
    }
    if (isNaN(times)) {
      reason = `not a valid date/time`;
      vstatus = false;
    }
  }
  return { vstatus, reason };
}

/**
 * @class
 * @classdesc
 *
 * **stateful** {@link external:Component|Component}
 *
 * ## A single record
 *
 * Displays all fields that the user is allowed to read.
 * With a control to edit the record.
 * 
 */
class ItemField extends Component {
/**
 *
 * @method
 * @param {Item[]} listData (from *state*) The list of records as it comes form mongo db,
 * plus a list of fields that is provided for each row (dependent on user permissions)
 * @returns {Fragment}
*/

  setValToState(i, newVal, _id, doSave) {
    const { reasons } = this.state;
    let newReasons;
    let newValues = [...this.state.curValues];
    if (newVal == null) {
      newValues = newValues.filter((x,j) => j != i) 
      newReasons = reasons;
    }
    else {
      const { valType, validation, table, name, relValuesMap } = this.props;
      const { vstatus, reason } = validate(newVal, valType, validation);
      const sendVal = (valType == 'rel')? ((typeof newVal != 'string')? newVal : { _id, value: newVal }) : newVal;
      if (vstatus &amp;&amp; valType == 'rel' &amp;&amp; _id == null) {
        /* add new value to value list
         * assume that fields that have allowNew, do not have an associated value table.
         * This app gleans the value of such fields from the actual values encountered in the big table.
         * We maintain the related values in the relValuesMap, so we have to update it with {_id: null, value: sendVal}
         * What if we have multiple new values, all with _id: null, will that go wrong?
         * Yes.
         * It is better to fetch the relValues anew. 
         * In order to do this, we do two things:
         * 1. set the current state for relValues to null
         * 2. set the prop relValuesMap.table.name to null
         * 
         * This is surprisingly difficult to achieve.
         * And a simple refresh also solves the problem. 
         * So: put a (limited) refresh button on the interface, also for the filters.
         */
      }
      const refI = (i == -1)?newValues.length:i;
      if (i == -1) {newValues.push(sendVal)}
      else {newValues[i] = sendVal}
      newReasons = {...this.state.reasons, [refI]: reason};
    }
    const { valid, changed } = this.checkForSave({ newValues, newReasons });
    if (!doSave || !valid || !changed) {
      this.setState({
        ...this.state,
        curValues: newValues,
        reasons: newReasons,
        saving: {},
        valid,
        changed,
      })
    }
    else {
      this.toDb(newValues);
    }
  }

  changeVal(i, event) {
    event.preventDefault();
    this.setValToState(i, event.target.value, null, false);
  }

  keyUp(i, event) {
    if (event.keyCode === 13) {
      event.target.blur();
      this.setValToState(i, event.target.value, null, true);
    }
  }

  changeRelVal(i, _id, value) {
    this.setValToState(i, value, _id, true);
  }

  removeVal(i, _id, event) {
    event.preventDefault();
    this.setValToState(i, null, null, true);
  }

  checkForSave(info) {
    const { newValues, newReasons } = info;
    const { rowId, name, valType, validation, multiple, allowNew, updEdit } = this.props;
    const { savedValues } = this.state;
    const valid = Object.keys(newReasons).every(i => !newReasons[i]);
    let changed = false;
    if (newValues.length != savedValues.length) {
      changed = true
    }
    else {
      for (const i in newValues) {
        const cv = newValues[i];
        const sv = savedValues[i];
        if (sv == null) {
          changed = true
        }
        else if (typeof cv == 'object') {
          for (const k of Object.keys(cv)) {
            if (cv[k] != sv[k]) {
              changed = true;
              break;
            }
          }
        }
        else {
          if (cv != sv) {
            changed = true;
          }
        }
        if (changed) {
          break;
        }
      }
    }
    updEdit(name, changed, valid, newValues);
    return { valid , changed }
  }

  saveField() {
    const { valid, changed, saving } = this.state;
    if (valid &amp;&amp; changed &amp;&amp; !saving.status) {
      this.toDb();
    }
  }

  saved(data) {
    const { name, updMod, updEdit } = this.props;
    if (data == null) {
      this.setState({
        ...this.state,
        saving: {status: 'error'},
      });
    }
    else {
      const { [name]: newValues, ...modValues } = data;
      this.setState({
        ...this.state,
        saving: {status: 'saved'},
        savedValues: newValues,
        curValues: newValues,
        changed: false,
        valid: true,
      });
      updMod(modValues);
      updEdit(name, false, true, newValues);
    }
  }

  toDb(newValues) {
    const { curValues } = this.state;
    const { table, name, rowId, valType } = this.props;
    let sendValues = (newValues == null)?curValues:newValues;
    this.setState({
      ...this.state,
      reasons: {},
      saving: {status: 'saving'},
    });
    getData([
        {
          type: 'db',
          path: `/mod?table=${table}&amp;action=update`,
          branch: `save ${name}`,
          callback: this.saved.bind(this),
          data: {_id: rowId, name, values: sendValues},
        },
      ],
      this,
      this.props.notification.component
    );
  }

  fullfillSave() {
    const { editable, saveConcern } = this.props;
    const { name } = this.props;
    if (editable &amp;&amp; saveConcern) { this.saveField() }
  }

  valueAsString(valRaw) {
    const { valType, convert, userMap, countryMap, initial } = this.props;
    if (valRaw == null) {return { text: '', full: '', initial: (valType == 'rel')? true : initial }}
    switch (valType) {
      case 'rel': {
        switch (convert) {
          case 'user': {
            return userAsString(valRaw, userMap)
          }
          case 'country': {
            return countryAsString(valRaw, countryMap)
          }
          default: {return condense(valRaw.value)}
        }
      }
      case 'datetime': {
        return trimDate(valRaw);
      }
      default: {
        return {text: valRaw, full: valRaw}
      }
    }
  }

  urlFragment(i, valType, valText) {
    const { text, full } = valText;
    return &lt;a key={i} target="_blank" href={full} className="link">{text}&lt;/a>
  }
  emailFragment(i, valType, valText) {
    const { text, full } = valText;
    return &lt;a key={i} target="_blank" href={`mailto:${full}`} className="link">{full}&lt;/a>
  }
  textareaFragment(i, valType, valText) {
    const { text, full } = valText;
    return (
      &lt;Markdown
        key={i}
        source={full}
      />
    )
    //return &lt;p key={i} className="varia-large">{full}&lt;/p>
  }
  defaultFragment(i, valType, valText) {
    const { text, full } = valText;
    const cl = `${(valType == 'rel')?'tag':'varia'}-medium`;
    return &lt;span key={i} className={cl} title={full}>{text}&lt;/span>
  }

  relOptions() {
    const { relValues } = this.state;
    return relValues.map(rv => [rv._id, condense(rv.value)])
  }
  userOptions() {
    const { userMap } = this.props;
    return [...userMap.values()].map(rv => [rv._id,  this.valueAsString(rv)])
  }
  countryOptions() {
    const { countryMap } = this.props;
    return [...countryMap.values()].map(rv => [rv._id,  this.valueAsString(rv)])
  }

  relSelect(i, _id, isNew, extraClasses, valText) {
    const { text, full } = valText;
    const { table, convert, allowNew, name, rowId } = this.props;
    const { valid } = this.state;
    const valueList = (convert == 'user')? this.userOptions() : ((convert == 'country')? this.countryOptions() : this.relOptions())
    return &lt;RelSelect
      tag={`relselect_${table}_${rowId}_${name}_${i}`}
      table={table}
      key={i}
      isNew={isNew}
      allowNew={allowNew}
      valid={valid}
      valueList={valueList}
      initVal={_id}
      initText={text}
      initFull={full}
      onChange={this.changeRelVal.bind(this, i)}
      extraClasses={extraClasses}
    />
  }
  editValControl(i, _id, isNew) {
    const { multiple } = this.props;
    return (isNew || !multiple)? null : (
      &lt;span
        className="button-small fa fa-close"
        onClick={this.removeVal.bind(this, i, _id)}
      />
    )
  }

  relEditFragment(i, _id, isNew, valType, extraClasses, valText) {
    const { text, full } = valText;
    const { multiple } = this.props;
    return ((!multiple &amp;&amp; i == 0) || isNew)? (
      this.relSelect(i, _id, isNew, extraClasses, valText)
    ) : (
      &lt;span key={i} className="tag-medium" title={full}>{text}{' '}
        {this.editValControl(i, _id, isNew)}
      &lt;/span>
    )
  }
  textareaEditFragment(i, _id, isNew, valType, extraClasses, valText, cols=100, rows=10) {
    const { table, rowId, name } = this.props;
    const { text, full } = valText;
    this.saveLater = true;
    return (
      &lt;Alternative key={i} tag={`md_${table}_${rowId}_${name}`}
        controlPlacement={control => (&lt;p className="stick">{control}&lt;/p>)}
        controls={[
          (handler => &lt;span className="button-small fa fa-pencil" onClick={handler}/>),
          (handler => &lt;span className="button-small fa fa-hand-o-down" onClick={handler}/>),
        ]}
        alternatives={[
          &lt;Markdown
            source={full}
          />,
          &lt;span>
            &lt;textarea
              className={`input ${valType} ${extraClasses.join(' ')}`}
              value={full}
              onChange={this.changeVal.bind(this, i)}
              cols={cols}
              rows={rows}
              placeholder={valText.initial}
              wrap="soft"
            />
            {this.editValControl(i, _id, isNew)}
          &lt;/span>
        ]}
        initial={0}
      />
    )
  }
  defaultEditFragment(i, _id, isNew, valType, extraClasses, valText, size=50) {
    const { text, full } = valText;
    this.saveLater = true;
    return (
      &lt;span key={i}>
        &lt;input type="text"
          className={`input ${valType} ${extraClasses.join(' ')}`}
          value={full}
          placeholder={valText.initial}
          onChange={this.changeVal.bind(this, i)}
          onKeyUp={this.keyUp.bind(this, i)}
          size={size}
        />
        {this.editValControl(i, _id, isNew)}
      &lt;/span>
    )
  }

  progIcon() {
    const { editable } = this.props;
    let progIcon;
    if (editable) {
      const { saving, changed, valid } = this.state;
      const cs = saving.status;
      if (cs == 'saving') {progIcon = 'fa-spinner fa-spin'}
      else if (cs == 'saved') {progIcon = 'fa-check good'}
      else if (cs == 'error') {progIcon = 'fa-exclamation error'}
      else if (!valid) {progIcon = 'fa-close error'}
      else if (changed) {progIcon = 'fa-pencil warning'}
      else {progIcon = 'fa-circle-o hidden'}
      progIcon += ' fa progress';
    }
    else {
      progIcon = 'fa fa-lock progress info';
    }
    return (&lt;span key={name} className={progIcon}/>)
  }

  valuesAsReadonly() {
    const { curValues } = this.state;
    const { name } = this.props;
    if (curValues.length == 0) {return &lt;span className='warning'>no value&lt;/span>}
    const { valType, multiple, appearance } = this.props;
    const methods = readonlyMakeFragment(this);
    const makeFragment = methods[valType] || methods._default;
    const cutoff = appearance.cutoff;
    const alt2 = []
    const alt1 = [];
    alt1.push(' ');
    const processValues = appearance.reverse?[...curValues].reverse():curValues;
    processValues.forEach((v, i) => {
      let destAlt = (!cutoff || i &lt;= cutoff-1)?alt1:alt2;
      const valText = this.valueAsString(v);
      const fragment = makeFragment(i, valType, valText);
      if (multiple || i == 0) {destAlt.push(fragment)}
      if (multiple) {destAlt.push(' ')}
    });
    return this.knead(alt1, alt2)
  }

  valuesAsControls() {
    const { curValues, reasons } = this.state;
    const { savedValues } = this.state;
    const { name, valType, multiple, validation, allowNew, appearance } = this.props;
    const methods = editMakeFragment(this);
    const makeFragment = methods[valType] || methods._default;
    const cutoff = appearance.cutoff;
    const alt2 = []
    const alt1 = []
    const enumCurValues = curValues.map((v,i) => [i, v])
    const nValues = curValues.length;
    const processValues = appearance.reverse?enumCurValues.reverse():enumCurValues;
    if (multiple || nValues == 0) {
      processValues.push([nValues, null])
    }
    const size = sizes[valType] || sizes._max;
    let destAlt = alt1;
    let extraClasses = []
    processValues.forEach((ev, j) => {
      const [i, v] = ev;
      const isNew = j == nValues;
      destAlt = (!cutoff || j &lt;= cutoff-1)?alt1:alt2;
      const valText = this.valueAsString(v);
      const _id = (v == null)? null : v._id;
      extraClasses = []
      const reason = reasons[i] || '';
      if (reason != '') {
        extraClasses.push('error');
      }
      const fragment = makeFragment(i, _id, isNew, valType, extraClasses, valText, size);
      if (multiple || j == 0) {
        destAlt.push(fragment);
        if (reason != '') {
          destAlt.push(' ');
          destAlt.push(&lt;span key={`r_${i}`} className="reason">{reason}&lt;/span>)
        }
        destAlt.push(' ');
      }
    });
    return this.knead(alt1, alt2)
  }

  knead(alt1, alt2) {
    const { table, rowId, name } = this.props;
    if (alt2.length == 0) {return alt1}
    return (
      &lt;Alternative tag={`field_${table}_${rowId}_${name}`}
        controlPlacement={control => (&lt;span>{alt1}{' '}{control}&lt;/span>)}
        controls={[
          (handler => &lt;span className="button-small" onClick={handler}>show more&lt;/span>),
          (handler => &lt;span className="button-small" onClick={handler}>show less&lt;/span>),
        ]}
        alternatives={[
          '',
          alt2,
        ]}
        initial={0}
      />
    )
  }

  render() {
    const { relValues } = this.state;
    const { name, label, editable, valType, convert } = this.props;
    const { curValues } = this.state;
    if (editable &amp;&amp; relValues == null &amp;&amp; valType == 'rel' &amp;&amp; convert != 'user' &amp;&amp; convert != 'country') {
      return null;
    }
    const classNames = editable?'editable':'readonly';
    const prog = this.progIcon();
    const values = editable?this.valuesAsControls():this.valuesAsReadonly();
    const onClick = (editable &amp;&amp; this.saveLater) ? {onClick: this.saveField.bind(this)} : {};
    return (
      &lt;tr>
        &lt;td className="label" {...onClick} >{label}&lt;/td>
        &lt;td className="label" {...onClick} >{prog}&lt;/td>
        &lt;td>&lt;div className="values">{values}&lt;/div>&lt;/td>
      &lt;/tr>
    )
  }

/**
 * @method
 * @param {Item[]} records (from *state*) The list of records as it comes form mongo db
 * @returns {Object} The data fetched from the server.
*/
  fetchValues() {
    let { relValues } = this.state;
    const { valType, getValues, relValuesMap, convert, userMap, countryMap, table, rowId, name } = this.props;
    if (valType == 'rel' &amp;&amp; convert != 'user' &amp;&amp; convert != 'country')  {
      if (relValues == null) {
        getData([
            {
              type: 'db',
              path: getValues,
              branch: 'relValues'
            },
          ],
          this,
          this.props.notification.component
        )
      }
      else {
        if (!relValuesMap.has(table)) {relValuesMap.set(table, new Map())}
        if (!relValuesMap.get(table).has(name)) {relValuesMap.get(table).set(name, relValues)}
      }
    }
  }
  componentDidMount()  {this.fetchValues(); this.fullfillSave()}
  componentDidUpdate() {this.fetchValues(); this.fullfillSave()}
}

export default withContext(saveState(ItemField, 'ItemField', normalizeValues))
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Fri Mar 03 2017 10:55:29 GMT+0100 (CET) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
